/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#undef slots

#ifndef SWIG_GENERATED
#define SWIG_GENERATED
#endif

// we want visual assist to ignore this file, because it's a *lot* of generated code and has no
// useful results. This macro does nothing on normal builds, but is defined to _asm { in va_stdafx.h
#define VA_IGNORE_REST_OF_FILE
VA_IGNORE_REST_OF_FILE



#ifndef SWIGPYTHON
#define SWIGPYTHON
#endif

#define SWIG_PYTHON_NO_BUILD_NONE
#define SWIG_PYTHON_DIRECTOR_NO_VTABLE
#define SWIGPYTHON_BUILTIN


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#if defined(_DEBUG) && defined(SWIG_PYTHON_INTERPRETER_NO_DEBUG)
/* Use debug wrappers with the Python release dll */
# undef _DEBUG
# include <Python.h>
# define _DEBUG
#else
# include <Python.h>
#endif

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* Compatibility macros for Python 3 */
#if PY_VERSION_HEX >= 0x03000000

#define PyClass_Check(obj) PyObject_IsInstance(obj, (PyObject *)&PyType_Type)
#define PyInt_Check(x) PyLong_Check(x)
#define PyInt_AsLong(x) PyLong_AsLong(x)
#define PyInt_FromLong(x) PyLong_FromLong(x)
#define PyInt_FromSize_t(x) PyLong_FromSize_t(x)
#define PyString_Check(name) PyBytes_Check(name)
#define PyString_FromString(x) PyUnicode_FromString(x)
#define PyString_Format(fmt, args)  PyUnicode_Format(fmt, args)
#define PyString_AsString(str) PyBytes_AsString(str)
#define PyString_Size(str) PyBytes_Size(str)	
#define PyString_InternFromString(key) PyUnicode_InternFromString(key)
#define Py_TPFLAGS_HAVE_CLASS Py_TPFLAGS_BASETYPE
#define PyString_AS_STRING(x) PyUnicode_AS_STRING(x)
#define _PyLong_FromSsize_t(x) PyLong_FromSsize_t(x)

#endif

#ifndef Py_TYPE
#  define Py_TYPE(op) ((op)->ob_type)
#endif

/* SWIG APIs for compatibility of both Python 2 & 3 */

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_FromFormat PyUnicode_FromFormat
#else
#  define SWIG_Python_str_FromFormat PyString_FromFormat
#endif


/* Warning: This function will allocate a new string in Python 3,
 * so please call SWIG_Python_str_DelForPy3(x) to free the space.
 */
SWIGINTERN char*
SWIG_Python_str_AsChar(PyObject *str)
{
#if PY_VERSION_HEX >= 0x03000000
  char *cstr;
  char *newstr;
  Py_ssize_t len;
  str = PyUnicode_AsUTF8String(str);
  PyBytes_AsStringAndSize(str, &cstr, &len);
  newstr = (char *) malloc(len+1);
  memcpy(newstr, cstr, len+1);
  Py_XDECREF(str);
  return newstr;
#else
  return PyString_AsString(str);
#endif
}

#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_Python_str_DelForPy3(x) free( (void*) (x) )
#else
#  define SWIG_Python_str_DelForPy3(x) 
#endif


SWIGINTERN PyObject*
SWIG_Python_str_FromChar(const char *c)
{
#if PY_VERSION_HEX >= 0x03000000
  return PyUnicode_FromString(c); 
#else
  return PyString_FromString(c);
#endif
}

/* Add PyOS_snprintf for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# if defined(_MSC_VER) || defined(__BORLANDC__) || defined(_WATCOM)
#  define PyOS_snprintf _snprintf
# else
#  define PyOS_snprintf snprintf
# endif
#endif

/* A crude PyString_FromFormat implementation for old Pythons */
#if PY_VERSION_HEX < 0x02020000

#ifndef SWIG_PYBUFFER_SIZE
# define SWIG_PYBUFFER_SIZE 1024
#endif

static PyObject *
PyString_FromFormat(const char *fmt, ...) {
  va_list ap;
  char buf[SWIG_PYBUFFER_SIZE * 2];
  int res;
  va_start(ap, fmt);
  res = vsnprintf(buf, sizeof(buf), fmt, ap);
  va_end(ap);
  return (res < 0 || res >= (int)sizeof(buf)) ? 0 : PyString_FromString(buf);
}
#endif

#ifndef PyObject_DEL
# define PyObject_DEL PyObject_Del
#endif

/* A crude PyExc_StopIteration exception for old Pythons */
#if PY_VERSION_HEX < 0x02020000
# ifndef PyExc_StopIteration
#  define PyExc_StopIteration PyExc_RuntimeError
# endif
# ifndef PyObject_GenericGetAttr
#  define PyObject_GenericGetAttr 0
# endif
#endif

/* Py_NotImplemented is defined in 2.1 and up. */
#if PY_VERSION_HEX < 0x02010000
# ifndef Py_NotImplemented
#  define Py_NotImplemented PyExc_RuntimeError
# endif
#endif

/* A crude PyString_AsStringAndSize implementation for old Pythons */
#if PY_VERSION_HEX < 0x02010000
# ifndef PyString_AsStringAndSize
#  define PyString_AsStringAndSize(obj, s, len) {*s = PyString_AsString(obj); *len = *s ? strlen(*s) : 0;}
# endif
#endif

/* PySequence_Size for old Pythons */
#if PY_VERSION_HEX < 0x02000000
# ifndef PySequence_Size
#  define PySequence_Size PySequence_Length
# endif
#endif

/* PyBool_FromLong for old Pythons */
#if PY_VERSION_HEX < 0x02030000
static
PyObject *PyBool_FromLong(long ok)
{
  PyObject *result = ok ? Py_True : Py_False;
  Py_INCREF(result);
  return result;
}
#endif

/* Py_ssize_t for old Pythons */
/* This code is as recommended by: */
/* http://www.python.org/dev/peps/pep-0353/#conversion-guidelines */
#if PY_VERSION_HEX < 0x02050000 && !defined(PY_SSIZE_T_MIN)
typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intintargfunc ssizessizeargfunc;
typedef intobjargproc ssizeobjargproc;
typedef intintobjargproc ssizessizeobjargproc;
typedef getreadbufferproc readbufferproc;
typedef getwritebufferproc writebufferproc;
typedef getsegcountproc segcountproc;
typedef getcharbufferproc charbufferproc;
static long PyNumber_AsSsize_t (PyObject *x, void *SWIGUNUSEDPARM(exc))
{
  long result = 0;
  PyObject *i = PyNumber_Int(x);
  if (i) {
    result = PyInt_AsLong(i);
    Py_DECREF(i);
  }
  return result;
}
#endif

#if PY_VERSION_HEX < 0x02050000
#define PyInt_FromSize_t(x) PyInt_FromLong((long)x)
#endif

#if PY_VERSION_HEX < 0x02040000
#define Py_VISIT(op)				\
  do { 						\
    if (op) {					\
      int vret = visit((op), arg);		\
      if (vret)					\
        return vret;				\
    }						\
  } while (0)
#endif

#if PY_VERSION_HEX < 0x02030000
typedef struct {
  PyTypeObject type;
  PyNumberMethods as_number;
  PyMappingMethods as_mapping;
  PySequenceMethods as_sequence;
  PyBufferProcs as_buffer;
  PyObject *name, *slots;
} PyHeapTypeObject;
#endif

#if PY_VERSION_HEX < 0x02030000
typedef destructor freefunc;
#endif

#if ((PY_MAJOR_VERSION == 2 && PY_MINOR_VERSION > 6) || \
     (PY_MAJOR_VERSION == 3 && PY_MINOR_VERSION > 0) || \
     (PY_MAJOR_VERSION > 3))
# define SWIGPY_USE_CAPSULE
# define SWIGPY_CAPSULE_NAME ((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION ".type_pointer_capsule" SWIG_TYPE_TABLE_NAME)
#endif

#if PY_VERSION_HEX < 0x03020000
#define PyDescr_TYPE(x) (((PyDescrObject *)(x))->d_type)
#define PyDescr_NAME(x) (((PyDescrObject *)(x))->d_name)
#define Py_hash_t long
#endif

/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIME PyObject*
SWIG_Python_ErrorType(int code) {
  PyObject* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = PyExc_MemoryError;
    break;
  case SWIG_IOError:
    type = PyExc_IOError;
    break;
  case SWIG_RuntimeError:
    type = PyExc_RuntimeError;
    break;
  case SWIG_IndexError:
    type = PyExc_IndexError;
    break;
  case SWIG_TypeError:
    type = PyExc_TypeError;
    break;
  case SWIG_DivisionByZero:
    type = PyExc_ZeroDivisionError;
    break;
  case SWIG_OverflowError:
    type = PyExc_OverflowError;
    break;
  case SWIG_SyntaxError:
    type = PyExc_SyntaxError;
    break;
  case SWIG_ValueError:
    type = PyExc_ValueError;
    break;
  case SWIG_SystemError:
    type = PyExc_SystemError;
    break;
  case SWIG_AttributeError:
    type = PyExc_AttributeError;
    break;
  default:
    type = PyExc_RuntimeError;
  }
  return type;
}


SWIGRUNTIME void
SWIG_Python_AddErrorMsg(const char* mesg)
{
  PyObject *type = 0;
  PyObject *value = 0;
  PyObject *traceback = 0;

  if (PyErr_Occurred()) PyErr_Fetch(&type, &value, &traceback);
  if (value) {
    char *tmp;
    PyObject *old_str = PyObject_Str(value);
    PyErr_Clear();
    Py_XINCREF(type);

    PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(old_str);
    Py_DECREF(value);
  } else {
    PyErr_SetString(PyExc_RuntimeError, mesg);
  }
}

#if defined(SWIG_PYTHON_NO_THREADS)
#  if defined(SWIG_PYTHON_THREADS)
#    undef SWIG_PYTHON_THREADS
#  endif
#endif
#if defined(SWIG_PYTHON_THREADS) /* Threading support is enabled */
#  if !defined(SWIG_PYTHON_USE_GIL) && !defined(SWIG_PYTHON_NO_USE_GIL)
#    if (PY_VERSION_HEX >= 0x02030000) /* For 2.3 or later, use the PyGILState calls */
#      define SWIG_PYTHON_USE_GIL
#    endif
#  endif
#  if defined(SWIG_PYTHON_USE_GIL) /* Use PyGILState threads calls */
#    ifndef SWIG_PYTHON_INITIALIZE_THREADS
#     define SWIG_PYTHON_INITIALIZE_THREADS  PyEval_InitThreads() 
#    endif
#    ifdef __cplusplus /* C++ code */
       class SWIG_Python_Thread_Block {
         bool status;
         PyGILState_STATE state;
       public:
         void end() { if (status) { PyGILState_Release(state); status = false;} }
         SWIG_Python_Thread_Block() : status(true), state(PyGILState_Ensure()) {}
         ~SWIG_Python_Thread_Block() { end(); }
       };
       class SWIG_Python_Thread_Allow {
         bool status;
         PyThreadState *save;
       public:
         void end() { if (status) { PyEval_RestoreThread(save); status = false; }}
         SWIG_Python_Thread_Allow() : status(true), save(PyEval_SaveThread()) {}
         ~SWIG_Python_Thread_Allow() { end(); }
       };
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   SWIG_Python_Thread_Block _swig_thread_block
#      define SWIG_PYTHON_THREAD_END_BLOCK     _swig_thread_block.end()
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   SWIG_Python_Thread_Allow _swig_thread_allow
#      define SWIG_PYTHON_THREAD_END_ALLOW     _swig_thread_allow.end()
#    else /* C code */
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK   PyGILState_STATE _swig_thread_block = PyGILState_Ensure()
#      define SWIG_PYTHON_THREAD_END_BLOCK     PyGILState_Release(_swig_thread_block)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW   PyThreadState *_swig_thread_allow = PyEval_SaveThread()
#      define SWIG_PYTHON_THREAD_END_ALLOW     PyEval_RestoreThread(_swig_thread_allow)
#    endif
#  else /* Old thread way, not implemented, user must provide it */
#    if !defined(SWIG_PYTHON_INITIALIZE_THREADS)
#      define SWIG_PYTHON_INITIALIZE_THREADS
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_BLOCK)
#      define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_BLOCK)
#      define SWIG_PYTHON_THREAD_END_BLOCK
#    endif
#    if !defined(SWIG_PYTHON_THREAD_BEGIN_ALLOW)
#      define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#    endif
#    if !defined(SWIG_PYTHON_THREAD_END_ALLOW)
#      define SWIG_PYTHON_THREAD_END_ALLOW
#    endif
#  endif
#else /* No thread support */
#  define SWIG_PYTHON_INITIALIZE_THREADS
#  define SWIG_PYTHON_THREAD_BEGIN_BLOCK
#  define SWIG_PYTHON_THREAD_END_BLOCK
#  define SWIG_PYTHON_THREAD_BEGIN_ALLOW
#  define SWIG_PYTHON_THREAD_END_ALLOW
#endif

/* -----------------------------------------------------------------------------
 * Python API portion that goes into the runtime
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
  int type;
  char *name;
  long lvalue;
  double dvalue;
  void   *pvalue;
  swig_type_info **ptype;
} swig_const_info;


/* -----------------------------------------------------------------------------
 * Wrapper of PyInstanceMethod_New() used in Python 3
 * It is exported to the generated module, used for -fastproxy
 * ----------------------------------------------------------------------------- */
#if PY_VERSION_HEX >= 0x03000000
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *func)
{
  return PyInstanceMethod_New(func);
}
#else
SWIGRUNTIME PyObject* SWIG_PyInstanceMethod_New(PyObject *SWIGUNUSEDPARM(self), PyObject *SWIGUNUSEDPARM(func))
{
  return NULL;
}
#endif

#ifdef __cplusplus
}
#endif


/* -----------------------------------------------------------------------------
 * pyrun.swg
 *
 * This file contains the runtime support for Python modules
 * and includes code for managing global variables and pointer
 * type checking.
 *
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_Python_ConvertPtr(obj, pptr, type, flags)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, 0)
#define SWIG_ConvertPtr(obj, pptr, type, flags)         SWIG_Python_ConvertPtr(obj, pptr, type, flags)
#define SWIG_ConvertPtrAndOwn(obj,pptr,type,flags,own)  SWIG_Python_ConvertPtrAndOwn(obj, pptr, type, flags, own)

#ifdef SWIGPYTHON_BUILTIN
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(self, ptr, type, flags)
#else
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Python_NewPointerObj(NULL, ptr, type, flags)
#endif

#define SWIG_InternalNewPointerObj(ptr, type, flags)	SWIG_Python_NewPointerObj(NULL, ptr, type, flags)

#define SWIG_CheckImplicit(ty)                          SWIG_Python_CheckImplicit(ty) 
#define SWIG_AcquirePtr(ptr, src)                       SWIG_Python_AcquirePtr(ptr, src)
#define swig_owntype                                    int

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_ConvertPtr(obj, pptr, type, flags)
#define SWIG_NewInstanceObj(ptr, type, flags)           SWIG_NewPointerObj(ptr, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Python_ConvertFunctionPtr(obj, pptr, type)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Python_NewPointerObj(NULL, ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Python_ConvertPacked(obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Python_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Python_GetModule(clientdata)
#define SWIG_SetModule(clientdata, pointer)             SWIG_Python_SetModule(pointer)
#define SWIG_NewClientData(obj)                         SwigPyClientData_New(obj)

#define SWIG_SetErrorObj                                SWIG_Python_SetErrorObj                            
#define SWIG_SetErrorMsg                        	SWIG_Python_SetErrorMsg				   
#define SWIG_ErrorType(code)                    	SWIG_Python_ErrorType(code)                        
#define SWIG_Error(code, msg)            		SWIG_Python_SetErrorMsg(SWIG_ErrorType(code), msg) 
#define SWIG_fail                        		goto fail					   


/* Runtime API implementation */

/* Error manipulation */

SWIGINTERN void 
SWIG_Python_SetErrorObj(PyObject *errtype, PyObject *obj) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK; 
  PyErr_SetObject(errtype, obj);
  Py_DECREF(obj);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

SWIGINTERN void 
SWIG_Python_SetErrorMsg(PyObject *errtype, const char *msg) {
  SWIG_PYTHON_THREAD_BEGIN_BLOCK;
  PyErr_SetString(errtype, msg);
  SWIG_PYTHON_THREAD_END_BLOCK;
}

#define SWIG_Python_Raise(obj, type, desc)  SWIG_Python_SetErrorObj(SWIG_Python_ExceptionType(desc), obj)

/* Set a constant value */

#if defined(SWIGPYTHON_BUILTIN)

SWIGINTERN void
SwigPyBuiltin_AddPublicSymbol(PyObject *seq, const char *key) {
  PyObject *s = PyString_InternFromString(key);
  PyList_Append(seq, s);
  Py_DECREF(s);
}

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, PyObject *public_interface, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);
  if (public_interface)
    SwigPyBuiltin_AddPublicSymbol(public_interface, name);
}

#else

SWIGINTERN void
SWIG_Python_SetConstant(PyObject *d, const char *name, PyObject *obj) {   
#if PY_VERSION_HEX < 0x02030000
  PyDict_SetItemString(d, (char *)name, obj);
#else
  PyDict_SetItemString(d, name, obj);
#endif
  Py_DECREF(obj);                            
}

#endif

/* Append a value to the result obj */

SWIGINTERN PyObject*
SWIG_Python_AppendOutput(PyObject* result, PyObject* obj) {
#if !defined(SWIG_PYTHON_OUTPUT_TUPLE)
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyList_Check(result)) {
      PyObject *o2 = result;
      result = PyList_New(1);
      PyList_SetItem(result, 0, o2);
    }
    PyList_Append(result,obj);
    Py_DECREF(obj);
  }
  return result;
#else
  PyObject*   o2;
  PyObject*   o3;
  if (!result) {
    result = obj;
  } else if (result == Py_None) {
    Py_DECREF(result);
    result = obj;
  } else {
    if (!PyTuple_Check(result)) {
      o2 = result;
      result = PyTuple_New(1);
      PyTuple_SET_ITEM(result, 0, o2);
    }
    o3 = PyTuple_New(1);
    PyTuple_SET_ITEM(o3, 0, obj);
    o2 = result;
    result = PySequence_Concat(o2, o3);
    Py_DECREF(o2);
    Py_DECREF(o3);
  }
  return result;
#endif
}

/* Unpack the argument tuple */

SWIGINTERN Py_ssize_t
SWIG_Python_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, PyObject **objs)
{
  if (!args) {
    if (!min && !max) {
      return 1;
    } else {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got none", 
		   name, (min == max ? "" : "at least "), (int)min);
      return 0;
    }
  }  
  if (!PyTuple_Check(args)) {
    if (min <= 1 && max >= 1) {
      Py_ssize_t i;
      objs[0] = args;
      for (i = 1; i < max; ++i) {
	objs[i] = 0;
      }
      return 2;
    }
    PyErr_SetString(PyExc_SystemError, "UnpackTuple() argument list is not a tuple");
    return 0;
  } else {
    Py_ssize_t l = PyTuple_GET_SIZE(args);
    if (l < min) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at least "), (int)min, (int)l);
      return 0;
    } else if (l > max) {
      PyErr_Format(PyExc_TypeError, "%s expected %s%d arguments, got %d", 
		   name, (min == max ? "" : "at most "), (int)max, (int)l);
      return 0;
    } else {
      Py_ssize_t i;
      for (i = 0; i < l; ++i) {
	objs[i] = PyTuple_GET_ITEM(args, i);
      }
      for (; l < max; ++l) {
	objs[l] = 0;
      }
      return i + 1;
    }    
  }
}

/* A functor is a function object with one single object argument */
#if PY_VERSION_HEX >= 0x02020000
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunctionObjArgs(functor, obj, NULL);
#else
#define SWIG_Python_CallFunctor(functor, obj)	        PyObject_CallFunction(functor, "O", obj);
#endif

/*
  Helper for static pointer initialization for both C and C++ code, for example
  static PyObject *SWIG_STATIC_POINTER(MyVar) = NewSomething(...);
*/
#ifdef __cplusplus
#define SWIG_STATIC_POINTER(var)  var
#else
#define SWIG_STATIC_POINTER(var)  var = 0; if (!var) var
#endif

/* -----------------------------------------------------------------------------
 * Pointer declarations
 * ----------------------------------------------------------------------------- */

/* Flags for new pointer objects */
#define SWIG_POINTER_NOSHADOW       (SWIG_POINTER_OWN      << 1)
#define SWIG_POINTER_NEW            (SWIG_POINTER_NOSHADOW | SWIG_POINTER_OWN)

#define SWIG_POINTER_IMPLICIT_CONV  (SWIG_POINTER_DISOWN   << 1)

#define SWIG_BUILTIN_TP_INIT	    (SWIG_POINTER_OWN << 2)
#define SWIG_BUILTIN_INIT	    (SWIG_BUILTIN_TP_INIT | SWIG_POINTER_OWN)

#ifdef __cplusplus
extern "C" {
#endif

/*  How to access Py_None */
#if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#  ifndef SWIG_PYTHON_NO_BUILD_NONE
#    ifndef SWIG_PYTHON_BUILD_NONE
#      define SWIG_PYTHON_BUILD_NONE
#    endif
#  endif
#endif

#ifdef SWIG_PYTHON_BUILD_NONE
#  ifdef Py_None
#   undef Py_None
#   define Py_None SWIG_Py_None()
#  endif
SWIGRUNTIMEINLINE PyObject * 
_SWIG_Py_None(void)
{
  PyObject *none = Py_BuildValue((char*)"");
  Py_DECREF(none);
  return none;
}
SWIGRUNTIME PyObject * 
SWIG_Py_None(void)
{
  static PyObject *SWIG_STATIC_POINTER(none) = _SWIG_Py_None();
  return none;
}
#endif

/* The python void return value */

SWIGRUNTIMEINLINE PyObject * 
SWIG_Py_Void(void)
{
  PyObject *none = Py_None;
  Py_INCREF(none);
  return none;
}

/* SwigPyClientData */

typedef struct {
  PyObject *klass;
  PyObject *newraw;
  PyObject *newargs;
  PyObject *destroy;
  int delargs;
  int implicitconv;
  PyTypeObject *pytype;
} SwigPyClientData;

SWIGRUNTIMEINLINE int 
SWIG_Python_CheckImplicit(swig_type_info *ty)
{
  SwigPyClientData *data = (SwigPyClientData *)ty->clientdata;
  return data ? data->implicitconv : 0;
}

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_ExceptionType(swig_type_info *desc) {
  SwigPyClientData *data = desc ? (SwigPyClientData *) desc->clientdata : 0;
  PyObject *klass = data ? data->klass : 0;
  return (klass ? klass : PyExc_RuntimeError);
}


SWIGRUNTIME SwigPyClientData * 
SwigPyClientData_New(PyObject* obj)
{
  if (!obj) {
    return 0;
  } else {
    SwigPyClientData *data = (SwigPyClientData *)malloc(sizeof(SwigPyClientData));
    /* the klass element */
    data->klass = obj;
    Py_INCREF(data->klass);
    /* the newraw method and newargs arguments used to create a new raw instance */
    if (PyClass_Check(obj)) {
      data->newraw = 0;
      data->newargs = obj;
      Py_INCREF(obj);
    } else {
#if (PY_VERSION_HEX < 0x02020000)
      data->newraw = 0;
#else
      data->newraw = PyObject_GetAttrString(data->klass, (char *)"__new__");
#endif
      if (data->newraw) {
	Py_INCREF(data->newraw);
	data->newargs = PyTuple_New(1);
	PyTuple_SetItem(data->newargs, 0, obj);
      } else {
	data->newargs = obj;
      }
      Py_INCREF(data->newargs);
    }
    /* the destroy method, aka as the C++ delete method */
    data->destroy = PyObject_GetAttrString(data->klass, (char *)"__swig_destroy__");
    if (PyErr_Occurred()) {
      PyErr_Clear();
      data->destroy = 0;
    }
    if (data->destroy) {
      int flags;
      Py_INCREF(data->destroy);
      flags = PyCFunction_GET_FLAGS(data->destroy);
#ifdef METH_O
      data->delargs = !(flags & (METH_O));
#else
      data->delargs = 0;
#endif
    } else {
      data->delargs = 0;
    }
    data->implicitconv = 0;
    data->pytype = 0;
    return data;
  }
}

SWIGRUNTIME void 
SwigPyClientData_Del(SwigPyClientData *data) {
  Py_XDECREF(data->newraw);
  Py_XDECREF(data->newargs);
  Py_XDECREF(data->destroy);
}

/* =============== SwigPyObject =====================*/

typedef struct {
  PyObject_HEAD
  void *ptr;
  swig_type_info *ty;
  int own;
  PyObject *parent;
  PyObject *next;
#ifdef SWIGPYTHON_BUILTIN
  PyObject *dict;
#endif
} SwigPyObject;


#ifdef SWIGPYTHON_BUILTIN

SWIGRUNTIME PyObject *
SwigPyObject_get___dict__(PyObject *v, PyObject *SWIGUNUSEDPARM(args))
{
  SwigPyObject *sobj = (SwigPyObject *)v;

  if (!sobj->dict)
    sobj->dict = PyDict_New();

  Py_INCREF(sobj->dict);
  return sobj->dict;
}

#endif

SWIGRUNTIME PyObject *
SwigPyObject_long(SwigPyObject *v)
{
  return PyLong_FromVoidPtr(v->ptr);
}

SWIGRUNTIME PyObject *
SwigPyObject_format(const char* fmt, SwigPyObject *v)
{
  PyObject *res = NULL;
  PyObject *args = PyTuple_New(1);
  if (args) {
    if (PyTuple_SetItem(args, 0, SwigPyObject_long(v)) == 0) {
      PyObject *ofmt = SWIG_Python_str_FromChar(fmt);
      if (ofmt) {
#if PY_VERSION_HEX >= 0x03000000
	res = PyUnicode_Format(ofmt,args);
#else
	res = PyString_Format(ofmt,args);
#endif
	Py_DECREF(ofmt);
      }
      Py_DECREF(args);
    }
  }
  return res;
}

SWIGRUNTIME PyObject *
SwigPyObject_oct(SwigPyObject *v)
{
  return SwigPyObject_format("%o",v);
}

SWIGRUNTIME PyObject *
SwigPyObject_hex(SwigPyObject *v)
{
  return SwigPyObject_format("%x",v);
}

SWIGRUNTIME PyObject *
#ifdef METH_NOARGS
SwigPyObject_repr(SwigPyObject *v)
#else
SwigPyObject_repr(SwigPyObject *v, PyObject *args)
#endif
{
  const char *name = SWIG_TypePrettyName(v->ty);
  PyObject *repr = SWIG_Python_str_FromFormat("<Swig Object of type '%s' at %p>", (name ? name : "unknown"), (void *)v);
  if (v->next) {
# ifdef METH_NOARGS
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next);
# else
    PyObject *nrep = SwigPyObject_repr((SwigPyObject *)v->next, args);
# endif
# if PY_VERSION_HEX >= 0x03000000
    PyObject *joined = PyUnicode_Concat(repr, nrep);
    Py_DecRef(repr);
    Py_DecRef(nrep);
    repr = joined;
# else
    PyString_ConcatAndDel(&repr,nrep);
# endif
  }
  return repr;  
}

SWIGRUNTIME int
SwigPyObject_compare(SwigPyObject *v, SwigPyObject *w)
{
  void *i = v->ptr;
  void *j = w->ptr;
  return (i < j) ? -1 : ((i > j) ? 1 : 0);
}

/* Added for Python 3.x, would it also be useful for Python 2.x? */
SWIGRUNTIME PyObject*
SwigPyObject_richcompare(SwigPyObject *v, SwigPyObject *w, int op)
{
  PyObject* res;
  if( PyErr_Occurred() ) {
    return NULL;
  }
  if( op != Py_EQ && op != Py_NE ) {
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
  }
  res = PyBool_FromLong( (SwigPyObject_compare(v, w)==0) == (op == Py_EQ) ? 1 : 0);
  return res;  
}


SWIGRUNTIME PyTypeObject* SwigPyObject_TypeOnce(void);

#ifdef SWIGPYTHON_BUILTIN
static swig_type_info *SwigPyObject_stype = 0;
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
    SwigPyClientData *cd;
    assert(SwigPyObject_stype);
    cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
    assert(cd);
    assert(cd->pytype);
    return cd->pytype;
}
#else
SWIGRUNTIME PyTypeObject*
SwigPyObject_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyObject_TypeOnce();
  return type;
}
#endif

SWIGRUNTIMEINLINE int
SwigPyObject_Check(PyObject *op) {
  if (op == NULL) return 0;
#ifdef SWIGPYTHON_BUILTIN
  PyTypeObject *target_tp = SwigPyObject_type();
  if (PyType_IsSubtype(op->ob_type, target_tp))
    return 1;
  return (strcmp(op->ob_type->tp_name, "SwigPyObject") == 0);
#else
  return (Py_TYPE(op) == SwigPyObject_type())
    || (strcmp(Py_TYPE(op)->tp_name,"SwigPyObject") == 0);
#endif
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own);

SWIGRUNTIME void
SwigPyObject_dealloc(PyObject *v)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  PyObject *next = sobj->next;
  if (sobj->own == SWIG_POINTER_OWN) {
    swig_type_info *ty = sobj->ty;
    SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
    PyObject *destroy = data ? data->destroy : 0;
    if (destroy) {
      /* destroy is always a VARARGS method */
      PyObject *res;

      /* PyObject_CallFunction() has the potential to silently drop
         the active active exception.  In cases of unnamed temporary
         variable or where we just finished iterating over a generator
         StopIteration will be active right now, and this needs to
         remain true upon return from SwigPyObject_dealloc.  So save
         and restore. */
      
      PyObject *val = NULL, *type = NULL, *tb = NULL;
      PyErr_Fetch(&val, &type, &tb);

      if (data->delargs) {
        /* we need to create a temporary object to carry the destroy operation */
        PyObject *tmp = SwigPyObject_New(sobj->ptr, ty, 0);
        res = SWIG_Python_CallFunctor(destroy, tmp);
        Py_DECREF(tmp);
      } else {
        PyCFunction meth = PyCFunction_GET_FUNCTION(destroy);
        PyObject *mself = PyCFunction_GET_SELF(destroy);
        res = ((*meth)(mself, v));
      }
      if (!res)
        PyErr_WriteUnraisable(destroy);

      PyErr_Restore(val, type, tb);

      Py_XDECREF(res);
    } 
#if !defined(SWIG_PYTHON_SILENT_MEMLEAK)
    else {
      const char *name = SWIG_TypePrettyName(ty);
      printf("swig/python detected a memory leak of type '%s', no destructor found.\n", (name ? name : "unknown"));
    }
#endif
  } 
  Py_XDECREF(next);
  PyObject_DEL(v);
}

SWIGRUNTIME PyObject* 
SwigPyObject_append(PyObject* v, PyObject* next)
{
  SwigPyObject *sobj = (SwigPyObject *) v;
#ifndef METH_O
  PyObject *tmp = 0;
  if (!PyArg_ParseTuple(next,(char *)"O:append", &tmp)) return NULL;
  next = tmp;
#endif
  if (!SwigPyObject_Check(next)) {
    PyErr_SetString(PyExc_TypeError, "Attempt to append a non SwigPyObject");
    return NULL;
  }
  sobj->next = next;
  Py_INCREF(next);
  return SWIG_Py_Void();
}

SWIGRUNTIME PyObject* 
#ifdef METH_NOARGS
SwigPyObject_next(PyObject* v)
#else
SwigPyObject_next(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *) v;
  if (sobj->next) {    
    Py_INCREF(sobj->next);
    return sobj->next;
  } else {
    return SWIG_Py_Void();
  }
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_disown(PyObject *v)
#else
SwigPyObject_disown(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = 0;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
#ifdef METH_NOARGS
SwigPyObject_acquire(PyObject *v)
#else
SwigPyObject_acquire(PyObject* v, PyObject *SWIGUNUSEDPARM(args))
#endif
{
  SwigPyObject *sobj = (SwigPyObject *)v;
  sobj->own = SWIG_POINTER_OWN;
  return SWIG_Py_Void();
}

SWIGINTERN PyObject*
SwigPyObject_own(PyObject *v, PyObject *args)
{
  PyObject *val = 0;
#if (PY_VERSION_HEX < 0x02020000)
  if (!PyArg_ParseTuple(args,(char *)"|O:own",&val))
#elif (PY_VERSION_HEX < 0x02050000)
  if (!PyArg_UnpackTuple(args, (char *)"own", 0, 1, &val)) 
#else
  if (!PyArg_UnpackTuple(args, "own", 0, 1, &val)) 
#endif
    {
      return NULL;
    } 
  else
    {
      SwigPyObject *sobj = (SwigPyObject *)v;
      PyObject *obj = PyBool_FromLong(sobj->own);
      if (val) {
#ifdef METH_NOARGS
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v);
	} else {
	  SwigPyObject_disown(v);
	}
#else
	if (PyObject_IsTrue(val)) {
	  SwigPyObject_acquire(v,args);
	} else {
	  SwigPyObject_disown(v,args);
	}
#endif
      } 
      return obj;
    }
}

#ifdef METH_O
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_NOARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_NOARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS, (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_O,       (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_NOARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,    METH_NOARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#else
static PyMethodDef
swigobject_methods[] = {
  {(char *)"disown",  (PyCFunction)SwigPyObject_disown,  METH_VARARGS,  (char *)"releases ownership of the pointer"},
  {(char *)"acquire", (PyCFunction)SwigPyObject_acquire, METH_VARARGS,  (char *)"acquires ownership of the pointer"},
  {(char *)"own",     (PyCFunction)SwigPyObject_own,     METH_VARARGS,  (char *)"returns/sets ownership of the pointer"},
  {(char *)"append",  (PyCFunction)SwigPyObject_append,  METH_VARARGS,  (char *)"appends another 'this' object"},
  {(char *)"next",    (PyCFunction)SwigPyObject_next,    METH_VARARGS,  (char *)"returns the next 'this' object"},
  {(char *)"__repr__",(PyCFunction)SwigPyObject_repr,   METH_VARARGS,  (char *)"returns object representation"},
  {0, 0, 0, 0}  
};
#endif

#if PY_VERSION_HEX < 0x02020000
SWIGINTERN PyObject *
SwigPyObject_getattr(SwigPyObject *sobj,char *name)
{
  return Py_FindMethod(swigobject_methods, (PyObject *)sobj, name);
}
#endif

SWIGRUNTIME PyTypeObject*
SwigPyObject_TypeOnce(void) {
  static char swigobject_doc[] = "Swig object carries a C/C++ instance pointer";

  static PyNumberMethods SwigPyObject_as_number = {
    (binaryfunc)0, /*nb_add*/
    (binaryfunc)0, /*nb_subtract*/
    (binaryfunc)0, /*nb_multiply*/
    /* nb_divide removed in Python 3 */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc)0, /*nb_divide*/
#endif
    (binaryfunc)0, /*nb_remainder*/
    (binaryfunc)0, /*nb_divmod*/
    (ternaryfunc)0,/*nb_power*/
    (unaryfunc)0,  /*nb_negative*/
    (unaryfunc)0,  /*nb_positive*/
    (unaryfunc)0,  /*nb_absolute*/
    (inquiry)0,    /*nb_nonzero*/
    0,		   /*nb_invert*/
    0,		   /*nb_lshift*/
    0,		   /*nb_rshift*/
    0,		   /*nb_and*/
    0,		   /*nb_xor*/
    0,		   /*nb_or*/
#if PY_VERSION_HEX < 0x03000000
    0,   /*nb_coerce*/
#endif
    (unaryfunc)SwigPyObject_long, /*nb_int*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_long, /*nb_long*/
#else
    0, /*nb_reserved*/
#endif
    (unaryfunc)0,                 /*nb_float*/
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc)SwigPyObject_oct,  /*nb_oct*/
    (unaryfunc)SwigPyObject_hex,  /*nb_hex*/
#endif
#if PY_VERSION_HEX >= 0x03050000 /* 3.5 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_matrix_multiply */
#elif PY_VERSION_HEX >= 0x03000000 /* 3.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index, nb_inplace_divide removed */
#elif PY_VERSION_HEX >= 0x02050000 /* 2.5.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_index */
#elif PY_VERSION_HEX >= 0x02020000 /* 2.2.0 */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_true_divide */
#elif PY_VERSION_HEX >= 0x02000000 /* 2.0.0 */
    0,0,0,0,0,0,0,0,0,0,0 /* nb_inplace_add -> nb_inplace_or */
#endif
  };

  static PyTypeObject swigpyobject_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyObject",               /* tp_name */
      sizeof(SwigPyObject),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyObject_dealloc,     /* tp_dealloc */
      0,                                    /* tp_print */
#if PY_VERSION_HEX < 0x02020000
      (getattrfunc)SwigPyObject_getattr,    /* tp_getattr */
#else
      (getattrfunc)0,                       /* tp_getattr */
#endif
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
      0, /* tp_reserved in 3.0.1, tp_compare in 3.0.0 but not used */
#else
      (cmpfunc)SwigPyObject_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyObject_repr,          /* tp_repr */
      &SwigPyObject_as_number,              /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      0,                                    /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigobject_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      (richcmpfunc)SwigPyObject_richcompare,/* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      swigobject_methods,                   /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpyobject_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpyobject_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobject_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobject_type;
}

SWIGRUNTIME PyObject *
SwigPyObject_New(void *ptr, swig_type_info *ty, int own)
{
  SwigPyObject *sobj = PyObject_NEW(SwigPyObject, SwigPyObject_type());
  if (sobj) {
    sobj->ptr  = ptr;
    sobj->ty   = ty;
    sobj->own  = own;
    sobj->next = 0;
  }
  return (PyObject *)sobj;
}

/* -----------------------------------------------------------------------------
 * Implements a simple Swig Packed type, and use it instead of string
 * ----------------------------------------------------------------------------- */

typedef struct {
  PyObject_HEAD
  void *pack;
  swig_type_info *ty;
  size_t size;
} SwigPyPacked;

SWIGRUNTIME int
SwigPyPacked_print(SwigPyPacked *v, FILE *fp, int SWIGUNUSEDPARM(flags))
{
  char result[SWIG_BUFFER_SIZE];
  fputs("<Swig Packed ", fp); 
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    fputs("at ", fp); 
    fputs(result, fp); 
  }
  fputs(v->ty->name,fp); 
  fputs(">", fp);
  return 0; 
}
  
SWIGRUNTIME PyObject *
SwigPyPacked_repr(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))) {
    return SWIG_Python_str_FromFormat("<Swig Packed at %s%s>", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromFormat("<Swig Packed %s>", v->ty->name);
  }  
}

SWIGRUNTIME PyObject *
SwigPyPacked_str(SwigPyPacked *v)
{
  char result[SWIG_BUFFER_SIZE];
  if (SWIG_PackDataName(result, v->pack, v->size, 0, sizeof(result))){
    return SWIG_Python_str_FromFormat("%s%s", result, v->ty->name);
  } else {
    return SWIG_Python_str_FromChar(v->ty->name);
  }  
}

SWIGRUNTIME int
SwigPyPacked_compare(SwigPyPacked *v, SwigPyPacked *w)
{
  size_t i = v->size;
  size_t j = w->size;
  int s = (i < j) ? -1 : ((i > j) ? 1 : 0);
  return s ? s : strncmp((char *)v->pack, (char *)w->pack, 2*v->size);
}

SWIGRUNTIME PyTypeObject* SwigPyPacked_TypeOnce(void);

SWIGRUNTIME PyTypeObject*
SwigPyPacked_type(void) {
  static PyTypeObject *SWIG_STATIC_POINTER(type) = SwigPyPacked_TypeOnce();
  return type;
}

SWIGRUNTIMEINLINE int
SwigPyPacked_Check(PyObject *op) {
  return ((op)->ob_type == SwigPyPacked_TypeOnce()) 
    || (strcmp((op)->ob_type->tp_name,"SwigPyPacked") == 0);
}

SWIGRUNTIME void
SwigPyPacked_dealloc(PyObject *v)
{
  if (SwigPyPacked_Check(v)) {
    SwigPyPacked *sobj = (SwigPyPacked *) v;
    free(sobj->pack);
  }
  PyObject_DEL(v);
}

SWIGRUNTIME PyTypeObject*
SwigPyPacked_TypeOnce(void) {
  static char swigpacked_doc[] = "Swig object carries a C/C++ instance pointer";
  static PyTypeObject swigpypacked_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX>=0x03000000
      PyVarObject_HEAD_INIT(NULL, 0)
#else
      PyObject_HEAD_INIT(NULL)
      0,                                    /* ob_size */
#endif
      (char *)"SwigPyPacked",               /* tp_name */
      sizeof(SwigPyPacked),                 /* tp_basicsize */
      0,                                    /* tp_itemsize */
      (destructor)SwigPyPacked_dealloc,     /* tp_dealloc */
      (printfunc)SwigPyPacked_print,        /* tp_print */
      (getattrfunc)0,                       /* tp_getattr */
      (setattrfunc)0,                       /* tp_setattr */
#if PY_VERSION_HEX>=0x03000000
      0, /* tp_reserved in 3.0.1 */
#else
      (cmpfunc)SwigPyPacked_compare,        /* tp_compare */
#endif
      (reprfunc)SwigPyPacked_repr,          /* tp_repr */
      0,                                    /* tp_as_number */
      0,                                    /* tp_as_sequence */
      0,                                    /* tp_as_mapping */
      (hashfunc)0,                          /* tp_hash */
      (ternaryfunc)0,                       /* tp_call */
      (reprfunc)SwigPyPacked_str,           /* tp_str */
      PyObject_GenericGetAttr,              /* tp_getattro */
      0,                                    /* tp_setattro */
      0,                                    /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT,                   /* tp_flags */
      swigpacked_doc,                       /* tp_doc */
      0,                                    /* tp_traverse */
      0,                                    /* tp_clear */
      0,                                    /* tp_richcompare */
      0,                                    /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
      0,                                    /* tp_iter */
      0,                                    /* tp_iternext */
      0,                                    /* tp_methods */
      0,                                    /* tp_members */
      0,                                    /* tp_getset */
      0,                                    /* tp_base */
      0,                                    /* tp_dict */
      0,                                    /* tp_descr_get */
      0,                                    /* tp_descr_set */
      0,                                    /* tp_dictoffset */
      0,                                    /* tp_init */
      0,                                    /* tp_alloc */
      0,                                    /* tp_new */
      0,                                    /* tp_free */
      0,                                    /* tp_is_gc */
      0,                                    /* tp_bases */
      0,                                    /* tp_mro */
      0,                                    /* tp_cache */
      0,                                    /* tp_subclasses */
      0,                                    /* tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
      0,                                    /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                    /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                    /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                    /* tp_allocs */
      0,                                    /* tp_frees */
      0,                                    /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                    /* tp_prev */
#endif
      0                                     /* tp_next */
#endif
    };
    swigpypacked_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    swigpypacked_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpypacked_type) < 0)
      return NULL;
#endif
  }
  return &swigpypacked_type;
}

SWIGRUNTIME PyObject *
SwigPyPacked_New(void *ptr, size_t size, swig_type_info *ty)
{
  SwigPyPacked *sobj = PyObject_NEW(SwigPyPacked, SwigPyPacked_type());
  if (sobj) {
    void *pack = malloc(size);
    if (pack) {
      memcpy(pack, ptr, size);
      sobj->pack = pack;
      sobj->ty   = ty;
      sobj->size = size;
    } else {
      PyObject_DEL((PyObject *) sobj);
      sobj = 0;
    }
  }
  return (PyObject *) sobj;
}

SWIGRUNTIME swig_type_info *
SwigPyPacked_UnpackData(PyObject *obj, void *ptr, size_t size)
{
  if (SwigPyPacked_Check(obj)) {
    SwigPyPacked *sobj = (SwigPyPacked *)obj;
    if (sobj->size != size) return 0;
    memcpy(ptr, sobj->pack, size);
    return sobj->ty;
  } else {
    return 0;
  }
}

/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

SWIGRUNTIMEINLINE PyObject *
_SWIG_This(void)
{
    return SWIG_Python_str_FromChar("this");
}

static PyObject *swig_this = NULL;

SWIGRUNTIME PyObject *
SWIG_This(void)
{
  if (swig_this == NULL)
    swig_this = _SWIG_This();
  return swig_this;
}

/* #define SWIG_PYTHON_SLOW_GETSET_THIS */

/* TODO: I don't know how to implement the fast getset in Python 3 right now */
#if PY_VERSION_HEX>=0x03000000
#define SWIG_PYTHON_SLOW_GETSET_THIS 
#endif

SWIGRUNTIME SwigPyObject *
SWIG_Python_GetSwigThis(PyObject *pyobj) 
{
  PyObject *obj;

  if (SwigPyObject_Check(pyobj))
    return (SwigPyObject *) pyobj;

#ifdef SWIGPYTHON_BUILTIN
  (void)obj;
# ifdef PyWeakref_CheckProxy
  if (PyWeakref_CheckProxy(pyobj)) {
    pyobj = PyWeakref_GET_OBJECT(pyobj);
    if (pyobj && SwigPyObject_Check(pyobj))
      return (SwigPyObject*) pyobj;
  }
# endif
  return NULL;
#else

  obj = 0;

#if (!defined(SWIG_PYTHON_SLOW_GETSET_THIS) && (PY_VERSION_HEX >= 0x02030000))
  if (PyInstance_Check(pyobj)) {
    obj = _PyInstance_Lookup(pyobj, SWIG_This());      
  } else {
    PyObject **dictptr = _PyObject_GetDictPtr(pyobj);
    if (dictptr != NULL) {
      PyObject *dict = *dictptr;
      obj = dict ? PyDict_GetItem(dict, SWIG_This()) : 0;
    } else {
#ifdef PyWeakref_CheckProxy
      if (PyWeakref_CheckProxy(pyobj)) {
	PyObject *wobj = PyWeakref_GET_OBJECT(pyobj);
	return wobj ? SWIG_Python_GetSwigThis(wobj) : 0;
      }
#endif
      obj = PyObject_GetAttr(pyobj,SWIG_This());
      if (obj) {
	Py_DECREF(obj);
      } else {
	if (PyErr_Occurred()) PyErr_Clear();
	return 0;
      }
    }
  }
#else
  obj = PyObject_GetAttr(pyobj,SWIG_This());
  if (obj) {
    Py_DECREF(obj);
  } else {
    if (PyErr_Occurred()) PyErr_Clear();
    return 0;
  }
#endif
  if (obj && !SwigPyObject_Check(obj)) {
    /* a PyObject is called 'this', try to get the 'real this'
       SwigPyObject from it */ 
    return SWIG_Python_GetSwigThis(obj);
  }
  return (SwigPyObject *)obj;
#endif
}

/* Acquire a pointer value */

SWIGRUNTIME int
SWIG_Python_AcquirePtr(PyObject *obj, int own) {
  if (own == SWIG_POINTER_OWN) {
    SwigPyObject *sobj = SWIG_Python_GetSwigThis(obj);
    if (sobj) {
      int oldown = sobj->own;
      sobj->own = own;
      return oldown;
    }
  }
  return 0;
}

/* Convert a pointer value */

SWIGRUNTIME int
SWIG_Python_ConvertPtrAndOwn(PyObject *obj, void **ptr, swig_type_info *ty, int flags, int *own) {
  int res;
  SwigPyObject *sobj;
  int implicit_conv = (flags & SWIG_POINTER_IMPLICIT_CONV) != 0;

  if (!obj)
    return SWIG_ERROR;
  if (obj == Py_None && !implicit_conv) {
    if (ptr)
      *ptr = 0;
    return SWIG_OK;
  }

  res = SWIG_ERROR;

  sobj = SWIG_Python_GetSwigThis(obj);
  if (own)
    *own = 0;
  while (sobj) {
    void *vptr = sobj->ptr;
    if (ty) {
      swig_type_info *to = sobj->ty;
      if (to == ty) {
        /* no type cast needed */
        if (ptr) *ptr = vptr;
        break;
      } else {
        swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
        if (!tc) {
          sobj = (SwigPyObject *)sobj->next;
        } else {
          if (ptr) {
            int newmemory = 0;
            *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
            if (newmemory == SWIG_CAST_NEW_MEMORY) {
              assert(own); /* badly formed typemap which will lead to a memory leak - it must set and use own to delete *ptr */
              if (own)
                *own = *own | SWIG_CAST_NEW_MEMORY;
            }
          }
          break;
        }
      }
    } else {
      if (ptr) *ptr = vptr;
      break;
    }
  }
  if (sobj) {
    if (own)
      *own = *own | sobj->own;
    if (flags & SWIG_POINTER_DISOWN) {
      sobj->own = 0;
    }
    res = SWIG_OK;
  } else {
    if (implicit_conv) {
      SwigPyClientData *data = ty ? (SwigPyClientData *) ty->clientdata : 0;
      if (data && !data->implicitconv) {
        PyObject *klass = data->klass;
        if (klass) {
          PyObject *impconv;
          data->implicitconv = 1; /* avoid recursion and call 'explicit' constructors*/
          impconv = SWIG_Python_CallFunctor(klass, obj);
          data->implicitconv = 0;
          if (PyErr_Occurred()) {
            PyErr_Clear();
            impconv = 0;
          }
          if (impconv) {
            SwigPyObject *iobj = SWIG_Python_GetSwigThis(impconv);
            if (iobj) {
              void *vptr;
              res = SWIG_Python_ConvertPtrAndOwn((PyObject*)iobj, &vptr, ty, 0, 0);
              if (SWIG_IsOK(res)) {
                if (ptr) {
                  *ptr = vptr;
                  /* transfer the ownership to 'ptr' */
                  iobj->own = 0;
                  res = SWIG_AddCast(res);
                  res = SWIG_AddNewMask(res);
                } else {
                  res = SWIG_AddCast(res);		    
                }
              }
            }
            Py_DECREF(impconv);
          }
        }
      }
    }
    if (!SWIG_IsOK(res) && obj == Py_None) {
      if (ptr)
        *ptr = 0;
      if (PyErr_Occurred())
        PyErr_Clear();
      res = SWIG_OK;
    }
  }
  return res;
}

/* Convert a function ptr value */

SWIGRUNTIME int
SWIG_Python_ConvertFunctionPtr(PyObject *obj, void **ptr, swig_type_info *ty) {
  if (!PyCFunction_Check(obj)) {
    return SWIG_ConvertPtr(obj, ptr, ty, 0);
  } else {
    void *vptr = 0;
    
    /* here we get the method pointer for callbacks */
    const char *doc = (((PyCFunctionObject *)obj) -> m_ml -> ml_doc);
    const char *desc = doc ? strstr(doc, "swig_ptr: ") : 0;
    if (desc)
      desc = ty ? SWIG_UnpackVoidPtr(desc + 10, &vptr, ty->name) : 0;
    if (!desc) 
      return SWIG_ERROR;
    if (ty) {
      swig_cast_info *tc = SWIG_TypeCheck(desc,ty);
      if (tc) {
        int newmemory = 0;
        *ptr = SWIG_TypeCast(tc,vptr,&newmemory);
        assert(!newmemory); /* newmemory handling not yet implemented */
      } else {
        return SWIG_ERROR;
      }
    } else {
      *ptr = vptr;
    }
    return SWIG_OK;
  }
}

/* Convert a packed value value */

SWIGRUNTIME int
SWIG_Python_ConvertPacked(PyObject *obj, void *ptr, size_t sz, swig_type_info *ty) {
  swig_type_info *to = SwigPyPacked_UnpackData(obj, ptr, sz);
  if (!to) return SWIG_ERROR;
  if (ty) {
    if (to != ty) {
      /* check type cast? */
      swig_cast_info *tc = SWIG_TypeCheck(to->name,ty);
      if (!tc) return SWIG_ERROR;
    }
  }
  return SWIG_OK;
}  

/* -----------------------------------------------------------------------------
 * Create a new pointer object
 * ----------------------------------------------------------------------------- */

/*
  Create a new instance object, without calling __init__, and set the
  'this' attribute.
*/

SWIGRUNTIME PyObject* 
SWIG_Python_NewShadowInstance(SwigPyClientData *data, PyObject *swig_this)
{
#if (PY_VERSION_HEX >= 0x02020000)
  PyObject *inst = 0;
  PyObject *newraw = data->newraw;
  if (newraw) {
    inst = PyObject_Call(newraw, data->newargs, NULL);
    if (inst) {
#if !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
      PyObject **dictptr = _PyObject_GetDictPtr(inst);
      if (dictptr != NULL) {
	PyObject *dict = *dictptr;
	if (dict == NULL) {
	  dict = PyDict_New();
	  *dictptr = dict;
	  PyDict_SetItem(dict, SWIG_This(), swig_this);
	}
      }
#else
      PyObject *key = SWIG_This();
      PyObject_SetAttr(inst, key, swig_this);
#endif
    }
  } else {
#if PY_VERSION_HEX >= 0x03000000
    inst = ((PyTypeObject*) data->newargs)->tp_new((PyTypeObject*) data->newargs, Py_None, Py_None);
    if (inst) {
      PyObject_SetAttr(inst, SWIG_This(), swig_this);
      Py_TYPE(inst)->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
    }
#else
    PyObject *dict = PyDict_New();
    if (dict) {
      PyDict_SetItem(dict, SWIG_This(), swig_this);
      inst = PyInstance_NewRaw(data->newargs, dict);
      Py_DECREF(dict);
    }
#endif
  }
  return inst;
#else
#if (PY_VERSION_HEX >= 0x02010000)
  PyObject *inst = 0;
  PyObject *dict = PyDict_New();
  if (dict) {
    PyDict_SetItem(dict, SWIG_This(), swig_this);
    inst = PyInstance_NewRaw(data->newargs, dict);
    Py_DECREF(dict);
  }
  return (PyObject *) inst;
#else
  PyInstanceObject *inst = PyObject_NEW(PyInstanceObject, &PyInstance_Type);
  if (inst == NULL) {
    return NULL;
  }
  inst->in_class = (PyClassObject *)data->newargs;
  Py_INCREF(inst->in_class);
  inst->in_dict = PyDict_New();
  if (inst->in_dict == NULL) {
    Py_DECREF(inst);
    return NULL;
  }
#ifdef Py_TPFLAGS_HAVE_WEAKREFS
  inst->in_weakreflist = NULL;
#endif
#ifdef Py_TPFLAGS_GC
  PyObject_GC_Init(inst);
#endif
  PyDict_SetItem(inst->in_dict, SWIG_This(), swig_this);
  return (PyObject *) inst;
#endif
#endif
}

SWIGRUNTIME void
SWIG_Python_SetSwigThis(PyObject *inst, PyObject *swig_this)
{
 PyObject *dict;
#if (PY_VERSION_HEX >= 0x02020000) && !defined(SWIG_PYTHON_SLOW_GETSET_THIS)
 PyObject **dictptr = _PyObject_GetDictPtr(inst);
 if (dictptr != NULL) {
   dict = *dictptr;
   if (dict == NULL) {
     dict = PyDict_New();
     *dictptr = dict;
   }
   PyDict_SetItem(dict, SWIG_This(), swig_this);
   return;
 }
#endif
 dict = PyObject_GetAttrString(inst, (char*)"__dict__");
 PyDict_SetItem(dict, SWIG_This(), swig_this);
 Py_DECREF(dict);
} 


SWIGINTERN PyObject *
SWIG_Python_InitShadowInstance(PyObject *args) {
  PyObject *obj[2];
  if (!SWIG_Python_UnpackTuple(args, "swiginit", 2, 2, obj)) {
    return NULL;
  } else {
    SwigPyObject *sthis = SWIG_Python_GetSwigThis(obj[0]);
    if (sthis) {
      SwigPyObject_append((PyObject*) sthis, obj[1]);
    } else {
      SWIG_Python_SetSwigThis(obj[0], obj[1]);
    }
    return SWIG_Py_Void();
  }
}

/* Create a new pointer object */

SWIGRUNTIME PyObject *
SWIG_Python_NewPointerObj(PyObject *self, void *ptr, swig_type_info *type, int flags) {
  SwigPyClientData *clientdata;
  PyObject * robj;
  int own;

  if (!ptr)
    return SWIG_Py_Void();

  clientdata = type ? (SwigPyClientData *)(type->clientdata) : 0;
  own = (flags & SWIG_POINTER_OWN) ? SWIG_POINTER_OWN : 0;
  if (clientdata && clientdata->pytype) {
    SwigPyObject *newobj;
    if (flags & SWIG_BUILTIN_TP_INIT) {
      newobj = (SwigPyObject*) self;
      if (newobj->ptr) {
        PyObject *next_self = clientdata->pytype->tp_alloc(clientdata->pytype, 0);
        while (newobj->next)
	  newobj = (SwigPyObject *) newobj->next;
        newobj->next = next_self;
        newobj = (SwigPyObject *)next_self;
        newobj->parent = 0;
#ifdef SWIGPYTHON_BUILTIN
        newobj->dict = 0;
#endif
      }
    } else {
      newobj = PyObject_New(SwigPyObject, clientdata->pytype);
      newobj->parent = 0;
#ifdef SWIGPYTHON_BUILTIN
      newobj->dict = 0;
#endif
    }
    if (newobj) {
      newobj->ptr = ptr;
      newobj->ty = type;
      newobj->own = own;
      newobj->next = 0;
      return (PyObject*) newobj;
    }
    return SWIG_Py_Void();
  }

  assert(!(flags & SWIG_BUILTIN_TP_INIT));

  robj = SwigPyObject_New(ptr, type, own);
  if (robj && clientdata && !(flags & SWIG_POINTER_NOSHADOW)) {
    PyObject *inst = SWIG_Python_NewShadowInstance(clientdata, robj);
    Py_DECREF(robj);
    robj = inst;
  }
  return robj;
}

/* Create a new packed object */

SWIGRUNTIMEINLINE PyObject *
SWIG_Python_NewPackedObj(void *ptr, size_t sz, swig_type_info *type) {
  return ptr ? SwigPyPacked_New((void *) ptr, sz, type) : SWIG_Py_Void();
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

#ifdef SWIG_LINK_RUNTIME
void *SWIG_ReturnGlobalTypeList(void *);
#endif

SWIGRUNTIME swig_module_info *
SWIG_Python_GetModule(void *SWIGUNUSEDPARM(clientdata)) {
  static void *type_pointer = (void *)0;
  /* first check if module already created */
  if (!type_pointer) {
#ifdef SWIG_LINK_RUNTIME
    type_pointer = SWIG_ReturnGlobalTypeList((void *)0);
#else
# ifdef SWIGPY_USE_CAPSULE
    type_pointer = PyCapsule_Import(SWIGPY_CAPSULE_NAME, 0);
# else
    type_pointer = PyCObject_Import((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION,
				    (char*)"type_pointer" SWIG_TYPE_TABLE_NAME);
# endif
    if (PyErr_Occurred()) {
      PyErr_Clear();
      type_pointer = (void *)0;
    }
#endif
  }
  return (swig_module_info *) type_pointer;
}

#if PY_MAJOR_VERSION < 2
/* PyModule_AddObject function was introduced in Python 2.0.  The following function
   is copied out of Python/modsupport.c in python version 2.3.4 */
SWIGINTERN int
PyModule_AddObject(PyObject *m, char *name, PyObject *o)
{
  PyObject *dict;
  if (!PyModule_Check(m)) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs module as first arg");
    return SWIG_ERROR;
  }
  if (!o) {
    PyErr_SetString(PyExc_TypeError, "PyModule_AddObject() needs non-NULL value");
    return SWIG_ERROR;
  }
  
  dict = PyModule_GetDict(m);
  if (dict == NULL) {
    /* Internal error -- modules must have a dict! */
    PyErr_Format(PyExc_SystemError, "module '%s' has no __dict__",
		 PyModule_GetName(m));
    return SWIG_ERROR;
  }
  if (PyDict_SetItemString(dict, name, o))
    return SWIG_ERROR;
  Py_DECREF(o);
  return SWIG_OK;
}
#endif

SWIGRUNTIME void
#ifdef SWIGPY_USE_CAPSULE
SWIG_Python_DestroyModule(PyObject *obj)
#else
SWIG_Python_DestroyModule(void *vptr)
#endif
{
#ifdef SWIGPY_USE_CAPSULE
  swig_module_info *swig_module = (swig_module_info *) PyCapsule_GetPointer(obj, SWIGPY_CAPSULE_NAME);
#else
  swig_module_info *swig_module = (swig_module_info *) vptr;
#endif
  swig_type_info **types = swig_module->types;
  size_t i;
  for (i =0; i < swig_module->size; ++i) {
    swig_type_info *ty = types[i];
    if (ty->owndata) {
      SwigPyClientData *data = (SwigPyClientData *) ty->clientdata;
      if (data) SwigPyClientData_Del(data);
    }
  }
  Py_DECREF(SWIG_This());
  swig_this = NULL;
}

SWIGRUNTIME void
SWIG_Python_SetModule(swig_module_info *swig_module) {
#if PY_VERSION_HEX >= 0x03000000
 /* Add a dummy module object into sys.modules */
  PyObject *module = PyImport_AddModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION);
#else
  static PyMethodDef swig_empty_runtime_method_table[] = { {NULL, NULL, 0, NULL} }; /* Sentinel */
  PyObject *module = Py_InitModule((char*)"swig_runtime_data" SWIG_RUNTIME_VERSION, swig_empty_runtime_method_table);
#endif
#ifdef SWIGPY_USE_CAPSULE
  PyObject *pointer = PyCapsule_New((void *) swig_module, SWIGPY_CAPSULE_NAME, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer_capsule" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#else
  PyObject *pointer = PyCObject_FromVoidPtr((void *) swig_module, SWIG_Python_DestroyModule);
  if (pointer && module) {
    PyModule_AddObject(module, (char*)"type_pointer" SWIG_TYPE_TABLE_NAME, pointer);
  } else {
    Py_XDECREF(pointer);
  }
#endif
}

/* The python cached type query */
SWIGRUNTIME PyObject *
SWIG_Python_TypeCache(void) {
  static PyObject *SWIG_STATIC_POINTER(cache) = PyDict_New();
  return cache;
}

SWIGRUNTIME swig_type_info *
SWIG_Python_TypeQuery(const char *type)
{
  PyObject *cache = SWIG_Python_TypeCache();
  PyObject *key = SWIG_Python_str_FromChar(type); 
  PyObject *obj = PyDict_GetItem(cache, key);
  swig_type_info *descriptor;
  if (obj) {
#ifdef SWIGPY_USE_CAPSULE
    descriptor = (swig_type_info *) PyCapsule_GetPointer(obj, NULL);
#else
    descriptor = (swig_type_info *) PyCObject_AsVoidPtr(obj);
#endif
  } else {
    swig_module_info *swig_module = SWIG_GetModule(0);
    descriptor = SWIG_TypeQueryModule(swig_module, swig_module, type);
    if (descriptor) {
#ifdef SWIGPY_USE_CAPSULE
      obj = PyCapsule_New((void*) descriptor, NULL, NULL);
#else
      obj = PyCObject_FromVoidPtr(descriptor, NULL);
#endif
      PyDict_SetItem(cache, key, obj);
      Py_DECREF(obj);
    }
  }
  Py_DECREF(key);
  return descriptor;
}

/* 
   For backward compatibility only
*/
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_arg_fail(arg)      SWIG_Python_ArgFail(arg)
#define SWIG_MustGetPtr(p, type, argnum, flags)  SWIG_Python_MustGetPtr(p, type, argnum, flags)

SWIGRUNTIME int
SWIG_Python_AddErrMesg(const char* mesg, int infront)
{  
  if (PyErr_Occurred()) {
    PyObject *type = 0;
    PyObject *value = 0;
    PyObject *traceback = 0;
    PyErr_Fetch(&type, &value, &traceback);
    if (value) {
      char *tmp;
      PyObject *old_str = PyObject_Str(value);
      Py_XINCREF(type);
      PyErr_Clear();
      if (infront) {
	PyErr_Format(type, "%s %s", mesg, tmp = SWIG_Python_str_AsChar(old_str));
      } else {
	PyErr_Format(type, "%s %s", tmp = SWIG_Python_str_AsChar(old_str), mesg);
      }
      SWIG_Python_str_DelForPy3(tmp);
      Py_DECREF(old_str);
    }
    return 1;
  } else {
    return 0;
  }
}
  
SWIGRUNTIME int
SWIG_Python_ArgFail(int argnum)
{
  if (PyErr_Occurred()) {
    /* add information about failing argument */
    char mesg[256];
    PyOS_snprintf(mesg, sizeof(mesg), "argument number %d:", argnum);
    return SWIG_Python_AddErrMesg(mesg, 1);
  } else {
    return 0;
  }
}

SWIGRUNTIMEINLINE const char *
SwigPyObject_GetDesc(PyObject *self)
{
  SwigPyObject *v = (SwigPyObject *)self;
  swig_type_info *ty = v ? v->ty : 0;
  return ty ? ty->str : "";
}

SWIGRUNTIME void
SWIG_Python_TypeError(const char *type, PyObject *obj)
{
  if (type) {
#if defined(SWIG_COBJECT_TYPES)
    if (obj && SwigPyObject_Check(obj)) {
      const char *otype = (const char *) SwigPyObject_GetDesc(obj);
      if (otype) {
	PyErr_Format(PyExc_TypeError, "a '%s' is expected, 'SwigPyObject(%s)' is received",
		     type, otype);
	return;
      }
    } else 
#endif      
    {
      const char *otype = (obj ? obj->ob_type->tp_name : 0); 
      if (otype) {
	PyObject *str = PyObject_Str(obj);
	const char *cstr = str ? SWIG_Python_str_AsChar(str) : 0;
	if (cstr) {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s(%s)' is received",
		       type, otype, cstr);
          SWIG_Python_str_DelForPy3(cstr);
	} else {
	  PyErr_Format(PyExc_TypeError, "a '%s' is expected, '%s' is received",
		       type, otype);
	}
	Py_XDECREF(str);
	return;
      }
    }   
    PyErr_Format(PyExc_TypeError, "a '%s' is expected", type);
  } else {
    PyErr_Format(PyExc_TypeError, "unexpected type is received");
  }
}


/* Convert a pointer value, signal an exception on a type mismatch */
SWIGRUNTIME void *
SWIG_Python_MustGetPtr(PyObject *obj, swig_type_info *ty, int SWIGUNUSEDPARM(argnum), int flags) {
  void *result;
  if (SWIG_Python_ConvertPtr(obj, &result, ty, flags) == -1) {
    PyErr_Clear();
#if SWIG_POINTER_EXCEPTION
    if (flags) {
      SWIG_Python_TypeError(SWIG_TypePrettyName(ty), obj);
      SWIG_Python_ArgFail(argnum);
    }
#endif
  }
  return result;
}

#ifdef SWIGPYTHON_BUILTIN
SWIGRUNTIME int
SWIG_Python_NonDynamicSetAttr(PyObject *obj, PyObject *name, PyObject *value) {
  PyTypeObject *tp = obj->ob_type;
  PyObject *descr;
  PyObject *encoded_name;
  descrsetfunc f;
  int res = -1;

# ifdef Py_USING_UNICODE
  if (PyString_Check(name)) {
    name = PyUnicode_Decode(PyString_AsString(name), PyString_Size(name), NULL, NULL);
    if (!name)
      return -1;
  } else if (!PyUnicode_Check(name))
# else
  if (!PyString_Check(name))
# endif
  {
    PyErr_Format(PyExc_TypeError, "attribute name must be string, not '%.200s'", name->ob_type->tp_name);
    return -1;
  } else {
    Py_INCREF(name);
  }

  if (!tp->tp_dict) {
    if (PyType_Ready(tp) < 0)
      goto done;
  }

  descr = _PyType_Lookup(tp, name);
  f = NULL;
  if (descr != NULL)
    f = descr->ob_type->tp_descr_set;
  if (!f) {
    if (PyString_Check(name)) {
      encoded_name = name;
      Py_INCREF(name);
    } else {
      encoded_name = PyUnicode_AsUTF8String(name);
    }
    PyErr_Format(PyExc_AttributeError, "'%.100s' object has no attribute '%.200s'", tp->tp_name, PyString_AsString(encoded_name));
    Py_DECREF(encoded_name);
  } else {
    res = f(descr, obj, value);
  }
  
  done:
  Py_DECREF(name);
  return res;
}
#endif


#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SWIGINTERN Py_hash_t
SwigPyObject_hash(PyObject *obj) {
  SwigPyObject *sobj = (SwigPyObject *)obj;
  void *ptr = sobj->ptr;
  return (Py_hash_t)ptr;
}

SWIGINTERN Py_hash_t
SWIG_PyNumber_AsPyHash(PyObject *obj) {
  Py_hash_t result = -1;
#if PY_VERSION_HEX < 0x03020000
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj))
    result = PyInt_AsLong(obj);
  else
#endif
  if (PyLong_Check(obj))
    result = PyLong_AsLong(obj);
#else
  if (PyNumber_Check(obj))
    result = PyNumber_AsSsize_t(obj, NULL);
#endif
  else
    PyErr_Format(PyExc_TypeError, "Wrong type for hash function");
  return PyErr_Occurred() ? -1 : result;
}

SWIGINTERN int
SwigPyBuiltin_BadInit(PyObject *self, PyObject *SWIGUNUSEDPARM(args), PyObject *SWIGUNUSEDPARM(kwds)) {
  PyErr_Format(PyExc_TypeError, "Cannot create new instances of type '%.300s'", self->ob_type->tp_name);
  return -1;
}

SWIGINTERN void
SwigPyBuiltin_BadDealloc(PyObject *obj) {
  SwigPyObject *sobj = (SwigPyObject *)obj;
  if (sobj->own) {
    PyErr_Format(PyExc_TypeError, "Swig detected a memory leak in type '%.300s': no callable destructor found.", obj->ob_type->tp_name);
  }
}

typedef struct {
  PyCFunction get;
  PyCFunction set;
} SwigPyGetSet;

SWIGINTERN PyObject *
SwigPyBuiltin_GetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  tuple = PyTuple_New(0);
  assert(tuple);
  result = (*getset->get)(obj, tuple);
  Py_DECREF(tuple);
  return result;
}

SWIGINTERN PyObject *
SwigPyBuiltin_FunpackGetterClosure (PyObject *obj, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure)
    return SWIG_Py_Void();
  getset = (SwigPyGetSet *)closure;
  if (!getset->get)
    return SWIG_Py_Void();
  result = (*getset->get)(obj, NULL);
  return result;
}

SWIGINTERN int
SwigPyBuiltin_SetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *tuple, *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, val);
  Py_XINCREF(val);
  result = (*getset->set)(obj, tuple);
  Py_DECREF(tuple);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN int
SwigPyBuiltin_FunpackSetterClosure (PyObject *obj, PyObject *val, void *closure) {
  SwigPyGetSet *getset;
  PyObject *result;
  if (!closure) {
    PyErr_Format(PyExc_TypeError, "Missing getset closure");
    return -1;
  }
  getset = (SwigPyGetSet *)closure;
  if (!getset->set) {
    PyErr_Format(PyExc_TypeError, "Illegal member variable assignment in type '%.300s'", obj->ob_type->tp_name);
    return -1;
  }
  result = (*getset->set)(obj, val);
  Py_XDECREF(result);
  return result ? 0 : -1;
}

SWIGINTERN void
SwigPyStaticVar_dealloc(PyDescrObject *descr) {
  PyObject_GC_UnTrack(descr);
  Py_XDECREF(PyDescr_TYPE(descr));
  Py_XDECREF(PyDescr_NAME(descr));
  PyObject_GC_Del(descr);
}

SWIGINTERN PyObject *
SwigPyStaticVar_repr(PyGetSetDescrObject *descr) {
#if PY_VERSION_HEX >= 0x03000000

  return PyUnicode_FromFormat("<class attribute '%S' of type '%s'>", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  return PyString_FromFormat("<class attribute '%s' of type '%s'>", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
}

SWIGINTERN int
SwigPyStaticVar_traverse(PyObject *self, visitproc visit, void *arg) {
  PyDescrObject *descr;
  descr = (PyDescrObject *)self;
  Py_VISIT((PyObject*) PyDescr_TYPE(descr));
  return 0;
}

SWIGINTERN PyObject *
SwigPyStaticVar_get(PyGetSetDescrObject *descr, PyObject *obj, PyObject *SWIGUNUSEDPARM(type)) {
  if (descr->d_getset->get != NULL)
    return descr->d_getset->get(obj, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not readable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not readable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return NULL;
}

SWIGINTERN int
SwigPyStaticVar_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value) {
  if (descr->d_getset->set != NULL)
    return descr->d_getset->set(obj, value, descr->d_getset->closure);
#if PY_VERSION_HEX >= 0x03000000
  PyErr_Format(PyExc_AttributeError, "attribute '%.300S' of '%.100s' objects is not writable", PyDescr_NAME(descr), PyDescr_TYPE(descr)->tp_name);
#else
  PyErr_Format(PyExc_AttributeError, "attribute '%.300s' of '%.100s' objects is not writable", PyString_AsString(PyDescr_NAME(descr)), PyDescr_TYPE(descr)->tp_name);
#endif
  return -1;
}

SWIGINTERN int
SwigPyObjectType_setattro(PyObject *typeobject, PyObject *name, PyObject *value) {
  PyObject *attribute;
  PyTypeObject *type;
  descrsetfunc local_set;

  assert(PyType_Check(typeobject));
  type = (PyTypeObject *)typeobject;
  attribute = _PyType_Lookup(type, name);
  if (attribute != NULL) {
    /* Implement descriptor functionality, if any */
    local_set = attribute->ob_type->tp_descr_set;
    if (local_set != NULL)
      return local_set(attribute, (PyObject *)type, value);
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400S'", type->tp_name, name);
#else 
    PyErr_Format(PyExc_AttributeError, "cannot modify read-only attribute '%.50s.%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  } else {
#if PY_VERSION_HEX >= 0x03000000
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400S'", type->tp_name, name);
#else
    PyErr_Format(PyExc_AttributeError, "type '%.50s' has no attribute '%.400s'", type->tp_name, PyString_AS_STRING(name));
#endif
  }

  return -1;
}

SWIGINTERN PyTypeObject*
SwigPyStaticVar_Type(void) {
  static PyTypeObject staticvar_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(&PyType_Type)
      0,                                        /* ob_size */
#endif
      "swig_static_var_getset_descriptor",      /* tp_name */
      sizeof(PyGetSetDescrObject),              /* tp_basicsize */
      0,                                        /* tp_itemsize */
      (destructor)SwigPyStaticVar_dealloc,      /* tp_dealloc */
      0,                                        /* tp_print */
      0,                                        /* tp_getattr */
      0,                                        /* tp_setattr */
      0,                                        /* tp_compare */
      (reprfunc)SwigPyStaticVar_repr,           /* tp_repr */
      0,                                        /* tp_as_number */
      0,                                        /* tp_as_sequence */
      0,                                        /* tp_as_mapping */
      0,                                        /* tp_hash */
      0,                                        /* tp_call */
      0,                                        /* tp_str */
      PyObject_GenericGetAttr,                  /* tp_getattro */
      0,                                        /* tp_setattro */
      0,                                        /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_GC|Py_TPFLAGS_HAVE_CLASS, /* tp_flags */
      0,                                        /* tp_doc */
      SwigPyStaticVar_traverse,                 /* tp_traverse */
      0,                                        /* tp_clear */
      0,                                        /* tp_richcompare */
      0,                                        /* tp_weaklistoffset */
      0,                                        /* tp_iter */
      0,                                        /* tp_iternext */
      0,                                        /* tp_methods */
      0,                                        /* tp_members */
      0,                                        /* tp_getset */
      0,                                        /* tp_base */
      0,                                        /* tp_dict */
      (descrgetfunc)SwigPyStaticVar_get,        /* tp_descr_get */
      (descrsetfunc)SwigPyStaticVar_set,        /* tp_descr_set */
      0,                                        /* tp_dictoffset */
      0,                                        /* tp_init */
      0,                                        /* tp_alloc */
      0,                                        /* tp_new */
      0,                                        /* tp_free */
      0,                                        /* tp_is_gc */
      0,                                        /* tp_bases */
      0,                                        /* tp_mro */
      0,                                        /* tp_cache */
      0,                                        /* tp_subclasses */
      0,                                        /* tp_weaklist */
#if PY_VERSION_HEX >= 0x02030000
      0,                                        /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                        /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                        /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                        /* tp_allocs */
      0,                                        /* tp_frees */
      0,                                        /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                        /* tp_prev */
#endif
      0                                         /* tp_next */
#endif
    };
    staticvar_type = tmp;
    type_init = 1;
#if PY_VERSION_HEX < 0x02020000
    staticvar_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&staticvar_type) < 0)
      return NULL;
#endif
  }
  return &staticvar_type;
}

SWIGINTERN PyTypeObject*
SwigPyObjectType(void) {
  static char swigpyobjecttype_doc[] = "Metaclass for SWIG wrapped types";
  static PyTypeObject swigpyobjecttype_type;
  static int type_init = 0;
  if (!type_init) {
    const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
      PyVarObject_HEAD_INIT(&PyType_Type, 0)
#else
      PyObject_HEAD_INIT(&PyType_Type)
      0,                                        /* ob_size */
#endif
      "SwigPyObjectType",                       /* tp_name */
      PyType_Type.tp_basicsize,                 /* tp_basicsize */
      0,                                        /* tp_itemsize */
      0,                                        /* tp_dealloc */
      0,                                        /* tp_print */
      0,                                        /* tp_getattr */
      0,                                        /* tp_setattr */
      0,                                        /* tp_compare */
      0,                                        /* tp_repr */
      0,                                        /* tp_as_number */
      0,                                        /* tp_as_sequence */
      0,                                        /* tp_as_mapping */
      0,                                        /* tp_hash */
      0,                                        /* tp_call */
      0,                                        /* tp_str */
      0,                                        /* tp_getattro */
      SwigPyObjectType_setattro,                /* tp_setattro */
      0,                                        /* tp_as_buffer */
      Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_CLASS, /* tp_flags */
      swigpyobjecttype_doc,                     /* tp_doc */
      0,                                        /* tp_traverse */
      0,                                        /* tp_clear */
      0,                                        /* tp_richcompare */
      0,                                        /* tp_weaklistoffset */
      0,                                        /* tp_iter */
      0,                                        /* tp_iternext */
      0,                                        /* tp_methods */
      0,                                        /* tp_members */
      0,                                        /* tp_getset */
      0,                                        /* tp_base */
      0,                                        /* tp_dict */
      0,                                        /* tp_descr_get */
      0,                                        /* tp_descr_set */
      0,                                        /* tp_dictoffset */
      0,                                        /* tp_init */
      0,                                        /* tp_alloc */
      0,                                        /* tp_new */
      0,                                        /* tp_free */
      0,                                        /* tp_is_gc */
      0,                                        /* tp_bases */
      0,                                        /* tp_mro */
      0,                                        /* tp_cache */
      0,                                        /* tp_subclasses */
      0,                                        /* tp_weaklist */
#if PY_VERSION_HEX >= 0x02030000
      0,                                        /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
      0,                                        /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
      0,                                        /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
      0,                                        /* tp_allocs */
      0,                                        /* tp_frees */
      0,                                        /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
      0,                                        /* tp_prev */
#endif
      0                                         /* tp_next */
#endif
    };
    swigpyobjecttype_type = tmp;
    type_init = 1;
    swigpyobjecttype_type.tp_base = &PyType_Type;
#if PY_VERSION_HEX < 0x02020000
    swigpyobjecttype_type.ob_type = &PyType_Type;
#else
    if (PyType_Ready(&swigpyobjecttype_type) < 0)
      return NULL;
#endif
  }
  return &swigpyobjecttype_type;
}

SWIGINTERN PyGetSetDescrObject *
SwigPyStaticVar_new_getset(PyTypeObject *type, PyGetSetDef *getset) {

  PyGetSetDescrObject *descr;
  descr = (PyGetSetDescrObject *)PyType_GenericAlloc(SwigPyStaticVar_Type(), 0);
  assert(descr);
  Py_XINCREF(type);
  PyDescr_TYPE(descr) = type;
  PyDescr_NAME(descr) = PyString_InternFromString(getset->name);
  descr->d_getset = getset;
  if (PyDescr_NAME(descr) == NULL) {
    Py_DECREF(descr);
    descr = NULL;
  }
  return descr;
}

SWIGINTERN void
SwigPyBuiltin_InitBases (PyTypeObject *type, PyTypeObject **bases) {
  int base_count = 0;
  PyTypeObject **b;
  PyObject *tuple;
  int i;

  if (!bases[0]) {
    bases[0] = SwigPyObject_type();
    bases[1] = NULL;
  }
  type->tp_base = bases[0];
  Py_INCREF((PyObject *)bases[0]);
  for (b = bases; *b != NULL; ++b)
    ++base_count;
  tuple = PyTuple_New(base_count);
  for (i = 0; i < base_count; ++i) {
    PyTuple_SET_ITEM(tuple, i, (PyObject *)bases[i]);
    Py_INCREF((PyObject *)bases[i]);
  }
  type->tp_bases = tuple;
}

SWIGINTERN PyObject *
SwigPyBuiltin_ThisClosure (PyObject *self, void *SWIGUNUSEDPARM(closure)) {
  PyObject *result;
  result = (PyObject *)SWIG_Python_GetSwigThis(self);
  Py_XINCREF(result);
  return result;
}

SWIGINTERN void
SwigPyBuiltin_SetMetaType (PyTypeObject *type, PyTypeObject *metatype)
{
#if PY_VERSION_HEX >= 0x03000000
    type->ob_base.ob_base.ob_type = metatype;
#else
    type->ob_type = metatype;
#endif
}


/* Start of callback function macros for use in PyTypeObject */

typedef PyObject *(*SwigPyWrapperFunction)(PyObject *, PyObject *);

#define SWIGPY_UNARYFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_unaryfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_unaryfunc_closure(wrapper, a);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_unaryfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

#define SWIGPY_DESTRUCTOR_CLOSURE(wrapper)			\
SWIGINTERN void							\
wrapper##_destructor_closure(PyObject *a) {			\
    SwigPyBuiltin_destructor_closure(wrapper, #wrapper, a);	\
}
SWIGINTERN void
SwigPyBuiltin_destructor_closure(SwigPyWrapperFunction wrapper, const char *wrappername, PyObject *a) {
  SwigPyObject *sobj;
  sobj = (SwigPyObject *)a;
  Py_XDECREF(sobj->dict);
  Py_XDECREF(sobj->parent);
  if (sobj->own) {
    PyObject *o;
    PyObject *val = 0, *type = 0, *tb = 0;
    PyErr_Fetch(&val, &type, &tb);
    o = wrapper(a, NULL);
    if (!o) {
      PyObject *deallocname = PyString_FromString(wrappername);
      PyErr_WriteUnraisable(deallocname);
      Py_DECREF(deallocname);
    }
    PyErr_Restore(val, type, tb);
    Py_XDECREF(o);
  }
  if (PyType_IS_GC(a->ob_type)) {
    PyObject_GC_Del(a);
  } else {
    PyObject_Del(a);
  }
}

#define SWIGPY_INQUIRY_CLOSURE(wrapper)			\
SWIGINTERN int						\
wrapper##_inquiry_closure(PyObject *a) {		\
  return SwigPyBuiltin_inquiry_closure(wrapper, a);	\
}
SWIGINTERN int
SwigPyBuiltin_inquiry_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  PyObject *pyresult;
  int result;
  pyresult = wrapper(a, NULL);
  result = pyresult && PyObject_IsTrue(pyresult) ? 1 : 0;
  Py_XDECREF(pyresult);
  return result;
}

#define SWIGPY_GETITERFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_getiterfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_getiterfunc_closure(wrapper, a);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_getiterfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

#define SWIGPY_BINARYFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *						\
wrapper##_binaryfunc_closure(PyObject *a, PyObject *b) {	\
  return SwigPyBuiltin_binaryfunc_closure(wrapper, a, b);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_binaryfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, b);
  Py_XINCREF(b);
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

typedef ternaryfunc ternarycallfunc;

#define SWIGPY_TERNARYFUNC_CLOSURE(wrapper)				\
SWIGINTERN PyObject *							\
wrapper##_ternaryfunc_closure(PyObject *a, PyObject *b, PyObject *c) {	\
  return SwigPyBuiltin_ternaryfunc_closure(wrapper, a, b, c);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ternaryfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b, PyObject *c) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, b);
  PyTuple_SET_ITEM(tuple, 1, c);
  Py_XINCREF(b);
  Py_XINCREF(c);
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_TERNARYCALLFUNC_CLOSURE(wrapper)					\
SWIGINTERN PyObject *								\
wrapper##_ternarycallfunc_closure(PyObject *a, PyObject *b, PyObject *c) {	\
  return SwigPyBuiltin_ternarycallfunc_closure(wrapper, a, b, c);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ternarycallfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b, PyObject *c) {
  (void) c;
  return wrapper(a, b);
}

#define SWIGPY_LENFUNC_CLOSURE(wrapper)			\
SWIGINTERN Py_ssize_t					\
wrapper##_lenfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_lenfunc_closure(wrapper, a);	\
}
SWIGINTERN Py_ssize_t
SwigPyBuiltin_lenfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  PyObject *resultobj;
  Py_ssize_t result;
  resultobj = wrapper(a, NULL);
  result = PyNumber_AsSsize_t(resultobj, NULL);
  Py_DECREF(resultobj);
  return result;
}

#define SWIGPY_SSIZESSIZEARGFUNC_CLOSURE(wrapper)				\
SWIGINTERN PyObject *								\
wrapper##_ssizessizeargfunc_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c) {	\
  return SwigPyBuiltin_ssizessizeargfunc_closure(wrapper, a, b, c);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ssizessizeargfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b, Py_ssize_t c) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_SSIZESSIZEOBJARGPROC_CLOSURE(wrapper)						\
SWIGINTERN int											\
wrapper##_ssizessizeobjargproc_closure(PyObject *a, Py_ssize_t b, Py_ssize_t c, PyObject *d) {	\
  return SwigPyBuiltin_ssizessizeobjargproc_closure(wrapper, a, b, c, d);			\
}
SWIGINTERN int
SwigPyBuiltin_ssizessizeobjargproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b, Py_ssize_t c, PyObject *d) {
  PyObject *tuple, *resultobj;
  int result;
  tuple = PyTuple_New(d ? 3 : 2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  PyTuple_SET_ITEM(tuple, 1, _PyLong_FromSsize_t(c));
  if (d) {
    PyTuple_SET_ITEM(tuple, 2, d);
    Py_INCREF(d);
  }
  resultobj = wrapper(a, tuple);
  result = resultobj ? 0 : -1;
  Py_DECREF(tuple);
  Py_XDECREF(resultobj);
  return result;
}

#define SWIGPY_SSIZEARGFUNC_CLOSURE(wrapper)				\
SWIGINTERN PyObject *							\
wrapper##_ssizeargfunc_closure(PyObject *a, Py_ssize_t b) {		\
  return SwigPyBuiltin_funpack_ssizeargfunc_closure(wrapper, a, b);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_funpack_ssizeargfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b) {
  PyObject *tuple, *result;
  tuple = PyTuple_New(1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  result = wrapper(a, tuple);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_FUNPACK_SSIZEARGFUNC_CLOSURE(wrapper)			\
SWIGINTERN PyObject *							\
wrapper##_ssizeargfunc_closure(PyObject *a, Py_ssize_t b) {		\
  return SwigPyBuiltin_ssizeargfunc_closure(wrapper, a, b);		\
}
SWIGINTERN PyObject *
SwigPyBuiltin_ssizeargfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b) {
  PyObject *arg, *result;
  arg = _PyLong_FromSsize_t(b);
  result = wrapper(a, arg);
  Py_DECREF(arg);
  return result;
}

#define SWIGPY_SSIZEOBJARGPROC_CLOSURE(wrapper)					\
SWIGINTERN int									\
wrapper##_ssizeobjargproc_closure(PyObject *a, Py_ssize_t b, PyObject *c) {	\
  return SwigPyBuiltin_ssizeobjargproc_closure(wrapper, a, b, c);		\
}
SWIGINTERN int
SwigPyBuiltin_ssizeobjargproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, Py_ssize_t b, PyObject *c) {
  PyObject *tuple, *resultobj;
  int result;
  tuple = PyTuple_New(2);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, _PyLong_FromSsize_t(b));
  PyTuple_SET_ITEM(tuple, 1, c);
  Py_XINCREF(c);
  resultobj = wrapper(a, tuple);
  result = resultobj ? 0 : -1;
  Py_XDECREF(resultobj);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_OBJOBJARGPROC_CLOSURE(wrapper)					\
SWIGINTERN int									\
wrapper##_objobjargproc_closure(PyObject *a, PyObject *b, PyObject *c) {	\
  return SwigPyBuiltin_objobjargproc_closure(wrapper, a, b, c);			\
}
SWIGINTERN int
SwigPyBuiltin_objobjargproc_closure(SwigPyWrapperFunction wrapper, PyObject *a, PyObject *b, PyObject *c) {
  PyObject *tuple, *resultobj;
  int result;
  tuple = PyTuple_New(c ? 2 : 1);
  assert(tuple);
  PyTuple_SET_ITEM(tuple, 0, b);
  Py_XINCREF(b);
  if (c) {
    PyTuple_SET_ITEM(tuple, 1, c);
    Py_XINCREF(c);
  }
  resultobj = wrapper(a, tuple);
  result = resultobj ? 0 : -1;
  Py_XDECREF(resultobj);
  Py_DECREF(tuple);
  return result;
}

#define SWIGPY_REPRFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_reprfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_reprfunc_closure(wrapper, a);	\
}
SWIGINTERN PyObject *
SwigPyBuiltin_reprfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

#define SWIGPY_HASHFUNC_CLOSURE(wrapper)		\
SWIGINTERN Py_hash_t					\
wrapper##_hashfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_hashfunc_closure(wrapper, a);	\
}
SWIGINTERN Py_hash_t
SwigPyBuiltin_hashfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  PyObject *pyresult;
  Py_hash_t result;
  pyresult = wrapper(a, NULL);
  if (!pyresult)
    return -1;
  result = SWIG_PyNumber_AsPyHash(pyresult);
  Py_DECREF(pyresult);
  return result;
}

#define SWIGPY_ITERNEXTFUNC_CLOSURE(wrapper)		\
SWIGINTERN PyObject *					\
wrapper##_iternextfunc_closure(PyObject *a) {		\
  return SwigPyBuiltin_iternextfunc_closure(wrapper, a);\
}
SWIGINTERN PyObject *
SwigPyBuiltin_iternextfunc_closure(SwigPyWrapperFunction wrapper, PyObject *a) {
  return wrapper(a, NULL);
}

/* End of callback function macros for use in PyTypeObject */

#ifdef __cplusplus
}
#endif




#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_APIEvent swig_types[0]
#define SWIGTYPE_p_APIProperties swig_types[1]
#define SWIGTYPE_p_ActionDescription swig_types[2]
#define SWIGTYPE_p_AutoCompleteCallback swig_types[3]
#define SWIGTYPE_p_BufferDescription swig_types[4]
#define SWIGTYPE_p_BugReport swig_types[5]
#define SWIGTYPE_p_CaptureFileFormat swig_types[6]
#define SWIGTYPE_p_CaptureModifications swig_types[7]
#define SWIGTYPE_p_CaptureOptions swig_types[8]
#define SWIGTYPE_p_CaptureSettings swig_types[9]
#define SWIGTYPE_p_ContextMenu swig_types[10]
#define SWIGTYPE_p_D3D11Pipe__State swig_types[11]
#define SWIGTYPE_p_D3D12Pipe__State swig_types[12]
#define SWIGTYPE_p_DebugOverlay swig_types[13]
#define SWIGTYPE_p_DescriptorStoreDescription swig_types[14]
#define SWIGTYPE_p_DialogButton swig_types[15]
#define SWIGTYPE_p_DirectoryBrowseCallback swig_types[16]
#define SWIGTYPE_p_DockReference swig_types[17]
#define SWIGTYPE_p_EventBookmark swig_types[18]
#define SWIGTYPE_p_EventFilterCallback swig_types[19]
#define SWIGTYPE_p_ExecuteResult swig_types[20]
#define SWIGTYPE_p_ExtensionCallback swig_types[21]
#define SWIGTYPE_p_ExtensionMetadata swig_types[22]
#define SWIGTYPE_p_FilterParseCallback swig_types[23]
#define SWIGTYPE_p_FollowType swig_types[24]
#define SWIGTYPE_p_FrameDescription swig_types[25]
#define SWIGTYPE_p_GLPipe__State swig_types[26]
#define SWIGTYPE_p_IAPIInspector swig_types[27]
#define SWIGTYPE_p_IBufferViewer swig_types[28]
#define SWIGTYPE_p_ICaptureAccess swig_types[29]
#define SWIGTYPE_p_ICaptureContext swig_types[30]
#define SWIGTYPE_p_ICaptureDialog swig_types[31]
#define SWIGTYPE_p_ICaptureFile swig_types[32]
#define SWIGTYPE_p_ICaptureViewer swig_types[33]
#define SWIGTYPE_p_ICommentView swig_types[34]
#define SWIGTYPE_p_IDebugMessageView swig_types[35]
#define SWIGTYPE_p_IDescriptorViewer swig_types[36]
#define SWIGTYPE_p_IDeviceProtocolController swig_types[37]
#define SWIGTYPE_p_IDiagnosticLogView swig_types[38]
#define SWIGTYPE_p_IEventBrowser swig_types[39]
#define SWIGTYPE_p_IExtensionManager swig_types[40]
#define SWIGTYPE_p_IMainWindow swig_types[41]
#define SWIGTYPE_p_IMiniQtHelper swig_types[42]
#define SWIGTYPE_p_IPerformanceCounterViewer swig_types[43]
#define SWIGTYPE_p_IPipelineStateViewer swig_types[44]
#define SWIGTYPE_p_IPixelHistoryView swig_types[45]
#define SWIGTYPE_p_IPythonShell swig_types[46]
#define SWIGTYPE_p_IRGPInterop swig_types[47]
#define SWIGTYPE_p_IRemoteServer swig_types[48]
#define SWIGTYPE_p_IReplayManager swig_types[49]
#define SWIGTYPE_p_IReplayOutput swig_types[50]
#define SWIGTYPE_p_IResourceInspector swig_types[51]
#define SWIGTYPE_p_IShaderMessageViewer swig_types[52]
#define SWIGTYPE_p_IShaderViewer swig_types[53]
#define SWIGTYPE_p_IStatisticsViewer swig_types[54]
#define SWIGTYPE_p_ITextureViewer swig_types[55]
#define SWIGTYPE_p_ITimelineBar swig_types[56]
#define SWIGTYPE_p_InvokeCallback swig_types[57]
#define SWIGTYPE_p_KnownShaderTool swig_types[58]
#define SWIGTYPE_p_OffsetSizeDisplayMode swig_types[59]
#define SWIGTYPE_p_PanelMenu swig_types[60]
#define SWIGTYPE_p_PersistantConfig swig_types[61]
#define SWIGTYPE_p_PipeState swig_types[62]
#define SWIGTYPE_p_PipelineStage swig_types[63]
#define SWIGTYPE_p_QWidget swig_types[64]
#define SWIGTYPE_p_RemoteHost swig_types[65]
#define SWIGTYPE_p_ReplayOptions swig_types[66]
#define SWIGTYPE_p_ResourceDescription swig_types[67]
#define SWIGTYPE_p_ResourceId swig_types[68]
#define SWIGTYPE_p_ResultDetails swig_types[69]
#define SWIGTYPE_p_RevertCallback swig_types[70]
#define SWIGTYPE_p_SDChunk swig_types[71]
#define SWIGTYPE_p_SDFile swig_types[72]
#define SWIGTYPE_p_SDObject swig_types[73]
#define SWIGTYPE_p_SaveCallback swig_types[74]
#define SWIGTYPE_p_ShaderCompileFlags swig_types[75]
#define SWIGTYPE_p_ShaderDebugTrace swig_types[76]
#define SWIGTYPE_p_ShaderEncoding swig_types[77]
#define SWIGTYPE_p_ShaderProcessingTool swig_types[78]
#define SWIGTYPE_p_ShaderReflection swig_types[79]
#define SWIGTYPE_p_ShaderToolOutput swig_types[80]
#define SWIGTYPE_p_ShortcutCallback swig_types[81]
#define SWIGTYPE_p_Subresource swig_types[82]
#define SWIGTYPE_p_SwigPyObject swig_types[83]
#define SWIGTYPE_p_TextureDescription swig_types[84]
#define SWIGTYPE_p_TextureDisplay swig_types[85]
#define SWIGTYPE_p_TimeUnit swig_types[86]
#define SWIGTYPE_p_VKPipe__State swig_types[87]
#define SWIGTYPE_p_WidgetCallback swig_types[88]
#define SWIGTYPE_p_WindowMenu swig_types[89]
#define SWIGTYPE_p_WindowingData swig_types[90]
#define SWIGTYPE_p_WindowingSystem swig_types[91]
#define SWIGTYPE_p__XDisplay swig_types[92]
#define SWIGTYPE_p__object swig_types[93]
#define SWIGTYPE_p_bytebuf swig_types[94]
#define SWIGTYPE_p_char swig_types[95]
#define SWIGTYPE_p_int swig_types[96]
#define SWIGTYPE_p_long_long swig_types[97]
#define SWIGTYPE_p_p_IRemoteServer swig_types[98]
#define SWIGTYPE_p_rdcarrayT_ActionDescription_t swig_types[99]
#define SWIGTYPE_p_rdcarrayT_BufferDescription_t swig_types[100]
#define SWIGTYPE_p_rdcarrayT_BugReport_t swig_types[101]
#define SWIGTYPE_p_rdcarrayT_DebugMessage_t swig_types[102]
#define SWIGTYPE_p_rdcarrayT_Descriptor_t swig_types[103]
#define SWIGTYPE_p_rdcarrayT_DialogButton_t swig_types[104]
#define SWIGTYPE_p_rdcarrayT_EnvironmentModification_t swig_types[105]
#define SWIGTYPE_p_rdcarrayT_EventBookmark_t swig_types[106]
#define SWIGTYPE_p_rdcarrayT_ExtensionMetadata_t swig_types[107]
#define SWIGTYPE_p_rdcarrayT_ICaptureViewer_p_t swig_types[108]
#define SWIGTYPE_p_rdcarrayT_PixelModification_t swig_types[109]
#define SWIGTYPE_p_rdcarrayT_RemoteHost_t swig_types[110]
#define SWIGTYPE_p_rdcarrayT_ResourceDescription_t swig_types[111]
#define SWIGTYPE_p_rdcarrayT_SamplerDescriptor_t swig_types[112]
#define SWIGTYPE_p_rdcarrayT_ShaderEncoding_t swig_types[113]
#define SWIGTYPE_p_rdcarrayT_ShaderMessage_t swig_types[114]
#define SWIGTYPE_p_rdcarrayT_ShaderProcessingTool_t swig_types[115]
#define SWIGTYPE_p_rdcarrayT_ShaderSourcePrefix_t swig_types[116]
#define SWIGTYPE_p_rdcarrayT_TextureDescription_t swig_types[117]
#define SWIGTYPE_p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t swig_types[118]
#define SWIGTYPE_p_rdcarrayT_rdcstr_t swig_types[119]
#define SWIGTYPE_p_rdcdatetime swig_types[120]
#define SWIGTYPE_p_rdcpairT_rdcstr_rdcstr_t swig_types[121]
#define SWIGTYPE_p_rdcstr swig_types[122]
#define SWIGTYPE_p_short swig_types[123]
#define SWIGTYPE_p_signed_char swig_types[124]
#define SWIGTYPE_p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t swig_types[125]
#define SWIGTYPE_p_std__functionT_bool_fBugReport_const_RF_t swig_types[126]
#define SWIGTYPE_p_std__functionT_bool_fDialogButton_const_RF_t swig_types[127]
#define SWIGTYPE_p_std__functionT_bool_fEventBookmark_const_RF_t swig_types[128]
#define SWIGTYPE_p_std__functionT_bool_fExtensionMetadata_const_RF_t swig_types[129]
#define SWIGTYPE_p_std__functionT_bool_fF_t swig_types[130]
#define SWIGTYPE_p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t swig_types[131]
#define SWIGTYPE_p_std__functionT_bool_fICaptureViewer_pconst_RF_t swig_types[132]
#define SWIGTYPE_p_std__functionT_bool_fRemoteHost_const_RF_t swig_types[133]
#define SWIGTYPE_p_std__functionT_bool_fShaderProcessingTool_const_RF_t swig_types[134]
#define SWIGTYPE_p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t swig_types[135]
#define SWIGTYPE_p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t swig_types[136]
#define SWIGTYPE_p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t swig_types[137]
#define SWIGTYPE_p_std__functionT_void_fF_t swig_types[138]
#define SWIGTYPE_p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t swig_types[139]
#define SWIGTYPE_p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t swig_types[140]
#define SWIGTYPE_p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t swig_types[141]
#define SWIGTYPE_p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t swig_types[142]
#define SWIGTYPE_p_std__functionT_void_fIReplayController_pF_t swig_types[143]
#define SWIGTYPE_p_std__functionT_void_fQWidget_pF_t swig_types[144]
#define SWIGTYPE_p_std__functionT_void_ffloatF_t swig_types[145]
#define SWIGTYPE_p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t swig_types[146]
#define SWIGTYPE_p_unsigned_char swig_types[147]
#define SWIGTYPE_p_unsigned_int swig_types[148]
#define SWIGTYPE_p_unsigned_long swig_types[149]
#define SWIGTYPE_p_unsigned_long_long swig_types[150]
#define SWIGTYPE_p_unsigned_short swig_types[151]
#define SWIGTYPE_p_value_type swig_types[152]
static swig_type_info *swig_types[154];
static swig_module_info swig_module = {swig_types, 153, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#if (PY_VERSION_HEX <= 0x02000000)
# if !defined(SWIG_PYTHON_CLASSIC)
#  error "This python version requires swig to be run with the '-classic' option"
# endif
#endif
#if (PY_VERSION_HEX <= 0x02020000)
# error "This python version requires swig to be run with the '-nomodern' option"
#endif
#if (PY_VERSION_HEX <= 0x02020000)
# error "This python version requires swig to be run with the '-nomodernargs' option"
#endif
#ifndef METH_O
# error "This python version requires swig to be run with the '-nofastunpack' option"
#endif
#ifdef SWIG_TypeQuery
# undef SWIG_TypeQuery
#endif
#define SWIG_TypeQuery SWIG_Python_TypeQuery

/*-----------------------------------------------
              @(target):= qrenderdoc.so
  ------------------------------------------------*/
#if PY_VERSION_HEX >= 0x03000000
#  define SWIG_init    PyInit_qrenderdoc

#else
#  define SWIG_init    initqrenderdoc

#endif
#define SWIG_name    "qrenderdoc"

#define SWIGVERSION 0x030012 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>


namespace swig {
  class SwigPtr_PyObject {
  protected:
    PyObject *_obj;

  public:
    SwigPtr_PyObject() :_obj(0)
    {
    }

    SwigPtr_PyObject(const SwigPtr_PyObject& item) : _obj(item._obj)
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(_obj);      
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    SwigPtr_PyObject(PyObject *obj, bool initial_ref = true) :_obj(obj)
    {
      if (initial_ref) {
        SWIG_PYTHON_THREAD_BEGIN_BLOCK;
        Py_XINCREF(_obj);
        SWIG_PYTHON_THREAD_END_BLOCK;
      }
    }
    
    SwigPtr_PyObject & operator=(const SwigPtr_PyObject& item) 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XINCREF(item._obj);
      Py_XDECREF(_obj);
      _obj = item._obj;
      SWIG_PYTHON_THREAD_END_BLOCK;
      return *this;      
    }
    
    ~SwigPtr_PyObject() 
    {
      SWIG_PYTHON_THREAD_BEGIN_BLOCK;
      Py_XDECREF(_obj);
      SWIG_PYTHON_THREAD_END_BLOCK;
    }
    
    operator PyObject *() const
    {
      return _obj;
    }

    PyObject *operator->() const
    {
      return _obj;
    }
  };
}


namespace swig {
  struct SwigVar_PyObject : SwigPtr_PyObject {
    SwigVar_PyObject(PyObject* obj = 0) : SwigPtr_PyObject(obj, false) { }
    
    SwigVar_PyObject & operator = (PyObject* obj)
    {
      Py_XDECREF(_obj);
      _obj = obj;
      return *this;      
    }
  };
}


#include <stddef.h>


#include "3rdparty/pythoncapi_compat.h"


  #include "datetime.h"


  #include "Code/Interface/QRDInterface.h"


  #include "renderdoc_replay.h"

  static char convert_error[1024] = {};
  
  #include "Code/pyrenderdoc/pyconversion.h"

  // declare the basic building blocks as stringize types
  DECLARE_STRINGISE_TYPE(int8_t);
  DECLARE_STRINGISE_TYPE(uint8_t);
  DECLARE_STRINGISE_TYPE(int16_t);
  DECLARE_STRINGISE_TYPE(uint16_t);
  DECLARE_STRINGISE_TYPE(int32_t);
  DECLARE_STRINGISE_TYPE(uint32_t);
  DECLARE_STRINGISE_TYPE(int64_t);
  DECLARE_STRINGISE_TYPE(uint64_t);
  DECLARE_STRINGISE_TYPE(float);
  DECLARE_STRINGISE_TYPE(double);
  DECLARE_STRINGISE_TYPE(rdcstr);



// hacky macro to check if two variables are the same by looking at their length & second letter.
// Used to identify if we're dealing with 'self' in a typemap or not
#define STR_EQ(a, b) (sizeof(#a) == sizeof(#b) && (#a[1] == #b[1]))


template<typename innerType>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<innerType> *);


template<typename innerType, size_t N>
void  add_your_use_of_rdcfixedarray_to_swig_interface (rdcfixedarray<innerType, N> *);


  class QWidget;

  extern "C" QWidget *QWidgetFromPy(PyObject *widget);
  extern "C" PyObject *QWidgetToPy(QWidget *widget);

  DECLARE_STRINGISE_TYPE(QWidget);


  #ifndef slots
  #define slots
  #endif

  DECLARE_STRINGISE_TYPE(rdcstrpair);


SWIGINTERN int
SWIG_AsVal_double (PyObject *obj, double *val)
{
  int res = SWIG_TypeError;
  if (PyFloat_Check(obj)) {
    if (val) *val = PyFloat_AsDouble(obj);
    return SWIG_OK;
#if PY_VERSION_HEX < 0x03000000
  } else if (PyInt_Check(obj)) {
    if (val) *val = (double) PyInt_AsLong(obj);
    return SWIG_OK;
#endif
  } else if (PyLong_Check(obj)) {
    double v = PyLong_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    double d = PyFloat_AsDouble(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = d;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      long v = PyLong_AsLong(obj);
      if (!PyErr_Occurred()) {
	if (val) *val = v;
	return SWIG_AddCast(SWIG_AddCast(SWIG_OK));
      } else {
	PyErr_Clear();
      }
    }
  }
#endif
  return res;
}


#include <float.h>


#include <math.h>


SWIGINTERNINLINE int
SWIG_CanCastAsInteger(double *d, double min, double max) {
  double x = *d;
  if ((min <= x && x <= max)) {
   double fx = floor(x);
   double cx = ceil(x);
   double rd =  ((x - fx) < 0.5) ? fx : cx; /* simple rint */
   if ((errno == EDOM) || (errno == ERANGE)) {
     errno = 0;
   } else {
     double summ, reps, diff;
     if (rd < x) {
       diff = x - rd;
     } else if (rd > x) {
       diff = rd - x;
     } else {
       return 1;
     }
     summ = rd + x;
     reps = diff/summ;
     if (reps < 8*DBL_EPSILON) {
       *d = rd;
       return 1;
     }
   }
  }
  return 0;
}


SWIGINTERN int
SWIG_AsVal_long (PyObject *obj, long* val)
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    if (val) *val = PyInt_AsLong(obj);
    return SWIG_OK;
  } else
#endif
  if (PyLong_Check(obj)) {
    long v = PyLong_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    long v = PyInt_AsLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, LONG_MIN, LONG_MAX)) {
	if (val) *val = (long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_bool (PyObject *obj, bool *val)
{
  int r;
  if (!PyBool_Check(obj))
    return SWIG_ERROR;
  r = PyObject_IsTrue(obj);
  if (r == -1)
    return SWIG_ERROR;
  if (val) *val = r ? true : false;
  return SWIG_OK;
}


SWIGINTERNINLINE PyObject*
  SWIG_From_bool  (bool value)
{
  return PyBool_FromLong(value ? 1 : 0);
}


#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERN int
SWIG_AsVal_unsigned_SS_long (PyObject *obj, unsigned long *val) 
{
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(obj)) {
    long v = PyInt_AsLong(obj);
    if (v >= 0) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      return SWIG_OverflowError;
    }
  } else
#endif
  if (PyLong_Check(obj)) {
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      return SWIG_OverflowError;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    int dispatch = 0;
    unsigned long v = PyLong_AsUnsignedLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_AddCast(SWIG_OK);
    } else {
      PyErr_Clear();
    }
    if (!dispatch) {
      double d;
      int res = SWIG_AddCast(SWIG_AsVal_double (obj,&d));
      if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, ULONG_MAX)) {
	if (val) *val = (unsigned long)(d);
	return res;
      }
    }
  }
#endif
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int (PyObject * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}


SWIGINTERNINLINE PyObject*
  SWIG_From_unsigned_SS_int  (unsigned int value)
{
  return PyInt_FromSize_t((size_t) value);
}


SWIGINTERNINLINE PyObject*
  SWIG_From_int  (int value)
{
  return PyInt_FromLong((long) value);
}


SWIGINTERN int
SWIG_AsVal_int (PyObject * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long (obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}


  #define SWIG_From_double   PyFloat_FromDouble 


SWIGINTERNINLINE PyObject *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined __cplusplus && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_float (PyObject * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double (obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}

SWIGINTERN void IReplayManager_BlockInvoke(IReplayManager *self,IReplayManager::InvokeCallback m){
    PyObject *global_internal_handle = NULL;

    PyObject *globals = PyEval_GetGlobals();
    if(globals)
      global_internal_handle = PyDict_GetItemString(globals, "_renderdoc_internal");

    SetThreadBlocking(global_internal_handle, true);

    Py_BEGIN_ALLOW_THREADS
    self->BlockInvoke(m);
    Py_END_ALLOW_THREADS

    SetThreadBlocking(global_internal_handle, false);
  }

#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERN int
SWIG_AsVal_unsigned_SS_long_SS_long (PyObject *obj, unsigned long long *val)
{
  int res = SWIG_TypeError;
  if (PyLong_Check(obj)) {
    unsigned long long v = PyLong_AsUnsignedLongLong(obj);
    if (!PyErr_Occurred()) {
      if (val) *val = v;
      return SWIG_OK;
    } else {
      PyErr_Clear();
      res = SWIG_OverflowError;
    }
  } else {
    unsigned long v;
    res = SWIG_AsVal_unsigned_SS_long (obj,&v);
    if (SWIG_IsOK(res)) {
      if (val) *val = v;
      return res;
    }
  }
#ifdef SWIG_PYTHON_CAST_MODE
  {
    const double mant_max = 1LL << DBL_MANT_DIG;
    double d;
    res = SWIG_AsVal_double (obj,&d);
    if (SWIG_IsOK(res) && !SWIG_CanCastAsInteger(&d, 0, mant_max))
      return SWIG_OverflowError;
    if (SWIG_IsOK(res) && SWIG_CanCastAsInteger(&d, 0, mant_max)) {
      if (val) *val = (unsigned long long)(d);
      return SWIG_AddCast(res);
    }
    res = SWIG_TypeError;
  }
#endif
  return res;
}
#endif


  #define SWIG_From_long   PyInt_FromLong 


SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLong(value) : PyInt_FromLong(static_cast< long >(value));
}


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE PyObject* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  return (value > LONG_MAX) ?
    PyLong_FromUnsignedLongLong(value) : PyInt_FromLong(static_cast< long >(value));
}
#endif


SWIGINTERNINLINE PyObject *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}


SWIGINTERNINLINE int
SWIG_AsVal_size_t (PyObject * obj, size_t *val)
{
  int res = SWIG_TypeError;
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    unsigned long v = 0;
    res = SWIG_AsVal_unsigned_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else if (sizeof(size_t) <= sizeof(unsigned long long)) {
    unsigned long long v = 0;
    res = SWIG_AsVal_unsigned_SS_long_SS_long (obj, val ? &v : 0);
    if (SWIG_IsOK(res) && val) *val = static_cast< size_t >(v);
  }
#endif
  return res;
}

SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__append(rdcarray< EventBookmark > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__clear(rdcarray< EventBookmark > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__insert(rdcarray< EventBookmark > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__pop(rdcarray< EventBookmark > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__sort(rdcarray< EventBookmark > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__copy(rdcarray< EventBookmark > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__reverse(rdcarray< EventBookmark > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__index(rdcarray< EventBookmark > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__count(rdcarray< EventBookmark > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__extend(rdcarray< EventBookmark > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_EventBookmark_Sg__remove(rdcarray< EventBookmark > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<EventBookmark> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__append(rdcarray< ShaderProcessingTool > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__clear(rdcarray< ShaderProcessingTool > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__insert(rdcarray< ShaderProcessingTool > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__pop(rdcarray< ShaderProcessingTool > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__sort(rdcarray< ShaderProcessingTool > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__copy(rdcarray< ShaderProcessingTool > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__reverse(rdcarray< ShaderProcessingTool > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__index(rdcarray< ShaderProcessingTool > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__count(rdcarray< ShaderProcessingTool > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__extend(rdcarray< ShaderProcessingTool > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_ShaderProcessingTool_Sg__remove(rdcarray< ShaderProcessingTool > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<ShaderProcessingTool> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__append(rdcarray< rdcstrpair > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__clear(rdcarray< rdcstrpair > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__insert(rdcarray< rdcstrpair > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__pop(rdcarray< rdcstrpair > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__sort(rdcarray< rdcstrpair > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__copy(rdcarray< rdcstrpair > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__reverse(rdcarray< rdcstrpair > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__index(rdcarray< rdcstrpair > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__count(rdcarray< rdcstrpair > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__extend(rdcarray< rdcstrpair > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_rdcstrpair_Sg__remove(rdcarray< rdcstrpair > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<rdcstrpair> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__append(rdcarray< BugReport > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__clear(rdcarray< BugReport > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__insert(rdcarray< BugReport > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__pop(rdcarray< BugReport > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__sort(rdcarray< BugReport > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__copy(rdcarray< BugReport > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__reverse(rdcarray< BugReport > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__index(rdcarray< BugReport > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__count(rdcarray< BugReport > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__extend(rdcarray< BugReport > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_BugReport_Sg__remove(rdcarray< BugReport > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<BugReport> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__append(rdcarray< ExtensionMetadata > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__clear(rdcarray< ExtensionMetadata > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__insert(rdcarray< ExtensionMetadata > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__pop(rdcarray< ExtensionMetadata > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__sort(rdcarray< ExtensionMetadata > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__copy(rdcarray< ExtensionMetadata > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__reverse(rdcarray< ExtensionMetadata > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__index(rdcarray< ExtensionMetadata > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__count(rdcarray< ExtensionMetadata > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__extend(rdcarray< ExtensionMetadata > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_ExtensionMetadata_Sg__remove(rdcarray< ExtensionMetadata > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<ExtensionMetadata> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__append(rdcarray< DialogButton > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__clear(rdcarray< DialogButton > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__insert(rdcarray< DialogButton > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__pop(rdcarray< DialogButton > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__sort(rdcarray< DialogButton > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__copy(rdcarray< DialogButton > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__reverse(rdcarray< DialogButton > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__index(rdcarray< DialogButton > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__count(rdcarray< DialogButton > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__extend(rdcarray< DialogButton > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_DialogButton_Sg__remove(rdcarray< DialogButton > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<DialogButton> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__append(rdcarray< RemoteHost > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__clear(rdcarray< RemoteHost > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__insert(rdcarray< RemoteHost > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__pop(rdcarray< RemoteHost > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__sort(rdcarray< RemoteHost > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__copy(rdcarray< RemoteHost > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__reverse(rdcarray< RemoteHost > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__index(rdcarray< RemoteHost > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__count(rdcarray< RemoteHost > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__extend(rdcarray< RemoteHost > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_RemoteHost_Sg__remove(rdcarray< RemoteHost > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<RemoteHost> *)
{
}


SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__append(rdcarray< ICaptureViewer * > *self,PyObject *value){
      return array_append(self, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__clear(rdcarray< ICaptureViewer * > *self){
      return array_clear(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__insert(rdcarray< ICaptureViewer * > *self,PyObject *index,PyObject *value){
      return array_insert(self, index, value);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__pop(rdcarray< ICaptureViewer * > *self,PyObject *index=NULL){
      return array_pop(self, index);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__sort(rdcarray< ICaptureViewer * > *self,PyObject *key=NULL,bool reverse=false){
      return array_sort(self, key, reverse);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__copy(rdcarray< ICaptureViewer * > *self){
      return array_copy(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__reverse(rdcarray< ICaptureViewer * > *self){
      return array_reverse(self);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__index(rdcarray< ICaptureViewer * > *self,PyObject *item,PyObject *start=NULL,PyObject *end=NULL){
      return array_indexOf(self, item, start, end);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__count(rdcarray< ICaptureViewer * > *self,PyObject *item){
      return array_countOf(self, item);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__extend(rdcarray< ICaptureViewer * > *self,PyObject *items){
      return array_selfconcat(self, items);
    }
SWIGINTERN PyObject *rdcarray_Sl_ICaptureViewer_Sm__Sg__remove(rdcarray< ICaptureViewer * > *self,PyObject *item){
      return array_removeOne(self, item);
    }


template<>
void  add_your_use_of_rdcarray_to_swig_interface (rdcarray<ICaptureViewer *> *)
{
}



  #include <set>
  #include "Code/pyrenderdoc/interface_check.h"

  // check interface, see interface_check.h for more information
  static swig_type_info **interfaceCheckTypes;
  static size_t interfaceCheckNumTypes = 0;

  bool CheckQtInterface(rdcstr &log)
  {
#if defined(RELEASE)
    return false;
#else
    if(interfaceCheckNumTypes == 0)
      return false;

    return check_interface(log, interfaceCheckTypes, interfaceCheckNumTypes);
#endif
  }

#ifdef __cplusplus
extern "C" {
#endif

  struct PythonCaptureViewer : public ICaptureViewer
  {
    PythonCaptureViewer(PyObject *s);

    virtual ~PythonCaptureViewer()
    {
      Py_DECREF(self);
    }
    void OnCaptureLoaded() override { if(m_OnCaptureLoaded) m_OnCaptureLoaded(); }
    void OnCaptureClosed() override { if(m_OnCaptureClosed) m_OnCaptureClosed(); }
    void OnSelectedEventChanged(uint32_t eventId) override { if(m_OnSelectedEventChanged) m_OnSelectedEventChanged(eventId); }
    void OnEventChanged(uint32_t eventId) override { if(m_OnEventChanged) m_OnEventChanged(eventId); }

  private:
    PyObject *self;

    std::function<void()> m_OnCaptureLoaded, m_OnCaptureClosed;
    std::function<void(uint32_t)> m_OnSelectedEventChanged, m_OnEventChanged;
  };

  static int capviewer_init(PyObject *self, PyObject *args) {
    PyObject *resultobj = 0;
    ICaptureViewer *result = 0;

    result = new PythonCaptureViewer(self);
    resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ICaptureViewer, SWIG_BUILTIN_INIT | 0);
    return Py_IsNone(resultobj) ? -1 : 0;
  }

  SWIGINTERN PyObject *capviewer_deinit(PyObject *self, PyObject *args)
  {
    PythonCaptureViewer *viewer = NULL;
    void *ptr = NULL;
    int res = SWIG_ConvertPtr(self, &ptr, SWIGTYPE_p_ICaptureViewer, SWIG_POINTER_DISOWN | 0);

    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method '" "delete_CaptureViewer" "', argument " "1"" of type '" "CaptureViewer *""'");
    }

    viewer = (PythonCaptureViewer *)ptr;
    delete viewer;

    return SWIG_Py_Void();
  fail:
    return NULL;
  }

SWIGPY_DESTRUCTOR_CLOSURE(capviewer_deinit) /* defines capviewer_deinit_destructor_closure */


SWIGINTERN int _wrap_new_CaptureSettings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_CaptureSettings",0,0,0)) SWIG_fail;
  result = (CaptureSettings *)new CaptureSettings();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CaptureSettings, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_options_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  CaptureOptions *arg2 = (CaptureOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_options_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_CaptureOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureSettings_options_set" "', argument " "2"" of type '" "CaptureOptions *""'"); 
  }
  arg2 = reinterpret_cast< CaptureOptions * >(argp2);
  if (arg1) (arg1)->options = *arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_options_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  CaptureOptions *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_options_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_options_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result = (CaptureOptions *)& ((arg1)->options);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CaptureOptions, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_inject_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_inject_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureSettings_inject_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->inject = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_inject_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_inject_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_inject_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result = (bool) ((arg1)->inject);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_autoStart_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_autoStart_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureSettings_autoStart_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->autoStart = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_autoStart_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_autoStart_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_autoStart_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result = (bool) ((arg1)->autoStart);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_executable_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_executable_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureSettings_executable_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->executable = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_executable_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_executable_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_executable_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result =  ((arg1)->executable);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_workingDir_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_workingDir_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureSettings_workingDir_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->workingDir = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_workingDir_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_workingDir_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_workingDir_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result =  ((arg1)->workingDir);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_commandLine_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_commandLine_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureSettings_commandLine_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->commandLine = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_commandLine_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_commandLine_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_commandLine_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result =  ((arg1)->commandLine);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_environment_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  rdcarray< EnvironmentModification > *arg2 = (rdcarray< EnvironmentModification > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_environment_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< EnvironmentModification >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureSettings_environment_set' argument 2 of type 'rdcarray< EnvironmentModification >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureSettings_environment_set' argument 2 of type 'rdcarray< EnvironmentModification >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->environment = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_environment_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< EnvironmentModification > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_environment_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_environment_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result = (rdcarray< EnvironmentModification > *)& ((arg1)->environment);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_EnvironmentModification_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_numQueuedFrames_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_numQueuedFrames_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureSettings_numQueuedFrames_set" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  if (arg1) (arg1)->numQueuedFrames = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_numQueuedFrames_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_numQueuedFrames_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_numQueuedFrames_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result = (uint32_t) ((arg1)->numQueuedFrames);
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_queuedFrameCap_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_queuedFrameCap_set" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureSettings_queuedFrameCap_set" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  if (arg1) (arg1)->queuedFrameCap = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureSettings_queuedFrameCap_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureSettings_queuedFrameCap_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureSettings_queuedFrameCap_get" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  result = (uint32_t) ((arg1)->queuedFrameCap);
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_CaptureSettings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureSettings *arg1 = (CaptureSettings *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_CaptureSettings",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureSettings, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CaptureSettings" "', argument " "1"" of type '" "CaptureSettings *""'"); 
  }
  arg1 = reinterpret_cast< CaptureSettings * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_CaptureSettings) /* defines _wrap_delete_CaptureSettings_destructor_closure */

SWIGINTERN PyObject *_wrap_MainWindow_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMainWindow *arg1 = (IMainWindow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MainWindow_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMainWindow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MainWindow_Widget" "', argument " "1"" of type '" "IMainWindow *""'"); 
  }
  arg1 = reinterpret_cast< IMainWindow * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MainWindow_RegisterShortcut(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMainWindow *arg1 = (IMainWindow *) 0 ;
  rdcstr *arg2 = 0 ;
  QWidget *arg3 = (QWidget *) 0 ;
  SwigValueWrapper< std::function< void (QWidget *) > > arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  StackExceptionHandler exHandle4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MainWindow_RegisterShortcut",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMainWindow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MainWindow_RegisterShortcut" "', argument " "1"" of type '" "IMainWindow *""'"); 
  }
  arg1 = reinterpret_cast< IMainWindow * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MainWindow_RegisterShortcut' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    if(Py_IsNone(swig_obj[1]))
    arg3 = NULL;
    else
    arg3 = QWidgetFromPy(swig_obj[1]);
    if(swig_obj[1] && !Py_IsNone(swig_obj[1]) && !arg3)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MainWindow_RegisterShortcut' QWidget expected for argument 3 of type 'QWidget'");
    }
  }
  {
    PyObject *func = swig_obj[2];
    arg4 = ConvertFunc<IMainWindow::ShortcutCallback>("MainWindow_RegisterShortcut", func, exHandle4);
  }
  (arg1)->RegisterShortcut((rdcstr const &)*arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle4.data().failFlag) {
      PyErr_Restore(exHandle4.data().exObj, exHandle4.data().valueObj, exHandle4.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MainWindow_UnregisterShortcut(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMainWindow *arg1 = (IMainWindow *) 0 ;
  rdcstr *arg2 = 0 ;
  QWidget *arg3 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MainWindow_UnregisterShortcut",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMainWindow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MainWindow_UnregisterShortcut" "', argument " "1"" of type '" "IMainWindow *""'"); 
  }
  arg1 = reinterpret_cast< IMainWindow * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MainWindow_UnregisterShortcut' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    if(Py_IsNone(swig_obj[1]))
    arg3 = NULL;
    else
    arg3 = QWidgetFromPy(swig_obj[1]);
    if(swig_obj[1] && !Py_IsNone(swig_obj[1]) && !arg3)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MainWindow_UnregisterShortcut' QWidget expected for argument 3 of type 'QWidget'");
    }
  }
  (arg1)->UnregisterShortcut((rdcstr const &)*arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MainWindow_BringToFront(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMainWindow *arg1 = (IMainWindow *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MainWindow_BringToFront",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMainWindow, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MainWindow_BringToFront" "', argument " "1"" of type '" "IMainWindow *""'"); 
  }
  arg1 = reinterpret_cast< IMainWindow * >(argp1);
  (arg1)->BringToFront();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"EventBrowser_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_Widget" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_UpdateDurationColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"EventBrowser_UpdateDurationColumn",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_UpdateDurationColumn" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  (arg1)->UpdateDurationColumn();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_GetAPIEventForEID(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  APIEvent result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_GetAPIEventForEID" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_GetAPIEventForEID" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (arg1)->GetAPIEventForEID(arg2);
  resultobj = SWIG_NewPointerObj((new APIEvent(static_cast< const APIEvent& >(result))), SWIGTYPE_p_APIEvent, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_GetActionForEID(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ActionDescription *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_GetActionForEID" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_GetActionForEID" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (ActionDescription *)(arg1)->GetActionForEID(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ActionDescription, 0 |  0 );
  {
    // for ActionDescription pointers don't apply parent tracking, since these are preserved
    // in other ways and the linked-list nature of walking them can produce absurdly long
    // parent chains
    if (SwigPyObject_Check(resultobj))
    {
      SwigPyObject *sobj = (SwigPyObject *)resultobj;
      if(sobj->parent)
      {
        sobj->parent = NULL;
        Py_DECREF(self);
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_GetEventName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_GetEventName" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_GetEventName" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (arg1)->GetEventName(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_IsAPIEventVisible(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_IsAPIEventVisible" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_IsAPIEventVisible" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (bool)(arg1)->IsAPIEventVisible(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_RegisterEventFilterFunction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  IEventBrowser::EventFilterCallback arg4 ;
  IEventBrowser::FilterParseCallback arg5 ;
  SwigValueWrapper< std::function< rdcarray< rdcstr > (ICaptureContext *,rdcstr const &,rdcstr const &) > > arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  StackExceptionHandler exHandle4 ;
  StackExceptionHandler exHandle5 ;
  StackExceptionHandler exHandle6 ;
  PyObject *swig_obj[6] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"EventBrowser_RegisterEventFilterFunction",5,5,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_RegisterEventFilterFunction" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'EventBrowser_RegisterEventFilterFunction' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'EventBrowser_RegisterEventFilterFunction' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    PyObject *func = swig_obj[2];
    arg4 = ConvertFunc<IEventBrowser::EventFilterCallback>("EventBrowser_RegisterEventFilterFunction", func, exHandle4);
  }
  {
    PyObject *func = swig_obj[3];
    arg5 = ConvertFunc<IEventBrowser::FilterParseCallback>("EventBrowser_RegisterEventFilterFunction", func, exHandle5);
  }
  {
    PyObject *func = swig_obj[4];
    arg6 = ConvertFunc<IEventBrowser::AutoCompleteCallback>("EventBrowser_RegisterEventFilterFunction", func, exHandle6);
  }
  result = (bool)(arg1)->RegisterEventFilterFunction((rdcstr const &)*arg2,(rdcstr const &)*arg3,arg4,arg5,arg6);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    if(exHandle4.data().failFlag) {
      PyErr_Restore(exHandle4.data().exObj, exHandle4.data().valueObj, exHandle4.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    if(exHandle5.data().failFlag) {
      PyErr_Restore(exHandle5.data().exObj, exHandle5.data().valueObj, exHandle5.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    if(exHandle6.data().failFlag) {
      PyErr_Restore(exHandle6.data().exObj, exHandle6.data().valueObj, exHandle6.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_UnregisterEventFilterFunction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_UnregisterEventFilterFunction" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'EventBrowser_UnregisterEventFilterFunction' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->UnregisterEventFilterFunction((rdcstr const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_SetCurrentFilterText(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_SetCurrentFilterText" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'EventBrowser_SetCurrentFilterText' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetCurrentFilterText((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_GetCurrentFilterText(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"EventBrowser_GetCurrentFilterText",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_GetCurrentFilterText" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  result = (arg1)->GetCurrentFilterText();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_SetUseCustomActionNames(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_SetUseCustomActionNames" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_SetUseCustomActionNames" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetUseCustomActionNames(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_SetShowParameterNames(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_SetShowParameterNames" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_SetShowParameterNames" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetShowParameterNames(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_SetShowAllParameters(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_SetShowAllParameters" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_SetShowAllParameters" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetShowAllParameters(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBrowser_SetEmptyRegionsVisible(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IEventBrowser *arg1 = (IEventBrowser *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IEventBrowser, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBrowser_SetEmptyRegionsVisible" "', argument " "1"" of type '" "IEventBrowser *""'"); 
  }
  arg1 = reinterpret_cast< IEventBrowser * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBrowser_SetEmptyRegionsVisible" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetEmptyRegionsVisible(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_APIInspector_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IAPIInspector *arg1 = (IAPIInspector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"APIInspector_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IAPIInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "APIInspector_Widget" "', argument " "1"" of type '" "IAPIInspector *""'"); 
  }
  arg1 = reinterpret_cast< IAPIInspector * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_APIInspector_Refresh(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IAPIInspector *arg1 = (IAPIInspector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"APIInspector_Refresh",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IAPIInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "APIInspector_Refresh" "', argument " "1"" of type '" "IAPIInspector *""'"); 
  }
  arg1 = reinterpret_cast< IAPIInspector * >(argp1);
  (arg1)->Refresh();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_APIInspector_RevealParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IAPIInspector *arg1 = (IAPIInspector *) 0 ;
  SDObject *arg2 = (SDObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IAPIInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "APIInspector_RevealParameter" "', argument " "1"" of type '" "IAPIInspector *""'"); 
  }
  arg1 = reinterpret_cast< IAPIInspector * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_SDObject, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "APIInspector_RevealParameter" "', argument " "2"" of type '" "SDObject *""'"); 
  }
  arg2 = reinterpret_cast< SDObject * >(argp2);
  (arg1)->RevealParameter(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_PipelineStage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PipelineStage *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_PipelineStage",0,0,0)) SWIG_fail;
  result = (PipelineStage *)new PipelineStage();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PipelineStage, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_PipelineStage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PipelineStage *arg1 = (PipelineStage *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_PipelineStage",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PipelineStage, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PipelineStage" "', argument " "1"" of type '" "PipelineStage *""'"); 
  }
  arg1 = reinterpret_cast< PipelineStage * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_PipelineStage) /* defines _wrap_delete_PipelineStage_destructor_closure */

SWIGINTERN PyObject *_wrap_PipelineStateViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPipelineStateViewer *arg1 = (IPipelineStateViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PipelineStateViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPipelineStateViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PipelineStateViewer_Widget" "', argument " "1"" of type '" "IPipelineStateViewer *""'"); 
  }
  arg1 = reinterpret_cast< IPipelineStateViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PipelineStateViewer_SaveShaderFile(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPipelineStateViewer *arg1 = (IPipelineStateViewer *) 0 ;
  ShaderReflection *arg2 = (ShaderReflection *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPipelineStateViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PipelineStateViewer_SaveShaderFile" "', argument " "1"" of type '" "IPipelineStateViewer *""'"); 
  }
  arg1 = reinterpret_cast< IPipelineStateViewer * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ShaderReflection, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PipelineStateViewer_SaveShaderFile" "', argument " "2"" of type '" "ShaderReflection const *""'"); 
  }
  arg2 = reinterpret_cast< ShaderReflection * >(argp2);
  result = (bool)(arg1)->SaveShaderFile((ShaderReflection const *)arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PipelineStateViewer_SelectPipelineStage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPipelineStateViewer *arg1 = (IPipelineStateViewer *) 0 ;
  PipelineStage arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPipelineStateViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PipelineStateViewer_SelectPipelineStage" "', argument " "1"" of type '" "IPipelineStateViewer *""'"); 
  }
  arg1 = reinterpret_cast< IPipelineStateViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PipelineStateViewer_SelectPipelineStage" "', argument " "2"" of type '" "PipelineStage""'");
  } 
  arg2 = static_cast< PipelineStage >(val2);
  (arg1)->SelectPipelineStage(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_FollowType(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  FollowType *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_FollowType",0,0,0)) SWIG_fail;
  result = (FollowType *)new FollowType();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FollowType, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_FollowType(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  FollowType *arg1 = (FollowType *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_FollowType",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_FollowType, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_FollowType" "', argument " "1"" of type '" "FollowType *""'"); 
  }
  arg1 = reinterpret_cast< FollowType * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_FollowType) /* defines _wrap_delete_FollowType_destructor_closure */

SWIGINTERN PyObject *_wrap_TextureViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_Widget" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_ViewTexture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  ResourceId arg2 ;
  CompType arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_ViewTexture",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_ViewTexture" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TextureViewer_ViewTexture" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TextureViewer_ViewTexture" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextureViewer_ViewTexture" "', argument " "3"" of type '" "CompType""'");
  } 
  arg3 = static_cast< CompType >(val3);
  ecode4 = SWIG_AsVal_bool(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextureViewer_ViewTexture" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  (arg1)->ViewTexture(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_ViewFollowedResource(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  FollowType arg2 ;
  ShaderStage arg3 ;
  int32_t arg4 ;
  int32_t arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_ViewFollowedResource",4,4,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_ViewFollowedResource" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextureViewer_ViewFollowedResource" "', argument " "2"" of type '" "FollowType""'");
  } 
  arg2 = static_cast< FollowType >(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextureViewer_ViewFollowedResource" "', argument " "3"" of type '" "ShaderStage""'");
  } 
  arg3 = static_cast< ShaderStage >(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextureViewer_ViewFollowedResource" "', argument " "4"" of type '" "int32_t""'");
  } 
  arg4 = static_cast< int32_t >(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "TextureViewer_ViewFollowedResource" "', argument " "5"" of type '" "int32_t""'");
  } 
  arg5 = static_cast< int32_t >(val5);
  (arg1)->ViewFollowedResource(arg2,arg3,arg4,arg5);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetCurrentResource(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ResourceId result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetCurrentResource",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetCurrentResource" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (arg1)->GetCurrentResource();
  resultobj = SWIG_NewPointerObj((new ResourceId(static_cast< const ResourceId& >(result))), SWIGTYPE_p_ResourceId, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetSelectedSubresource(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  Subresource result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetSelectedSubresource",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetSelectedSubresource" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (arg1)->GetSelectedSubresource();
  resultobj = SWIG_NewPointerObj((new Subresource(static_cast< const Subresource& >(result))), SWIGTYPE_p_Subresource, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_SetSelectedSubresource(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  Subresource arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_SetSelectedSubresource" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_Subresource,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TextureViewer_SetSelectedSubresource" "', argument " "2"" of type '" "Subresource""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TextureViewer_SetSelectedSubresource" "', argument " "2"" of type '" "Subresource""'");
    } else {
      Subresource * temp = reinterpret_cast< Subresource * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->SetSelectedSubresource(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GotoLocation(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  uint32_t arg2 ;
  uint32_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GotoLocation",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GotoLocation" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextureViewer_GotoLocation" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextureViewer_GotoLocation" "', argument " "3"" of type '" "uint32_t""'");
  } 
  arg3 = static_cast< uint32_t >(val3);
  (arg1)->GotoLocation(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetPickedLocation(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcpair< int32_t,int32_t > result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetPickedLocation",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetPickedLocation" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (arg1)->GetPickedLocation();
  {
    resultobj = ConvertToPy((rdcpair< int32_t,int32_t >&)result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetTextureOverlay(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  DebugOverlay result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetTextureOverlay",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetTextureOverlay" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (DebugOverlay)(arg1)->GetTextureOverlay();
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_DebugOverlay->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_SetTextureOverlay(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  DebugOverlay arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_SetTextureOverlay" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextureViewer_SetTextureOverlay" "', argument " "2"" of type '" "DebugOverlay""'");
  } 
  arg2 = static_cast< DebugOverlay >(val2);
  (arg1)->SetTextureOverlay(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_IsZoomAutoFit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_IsZoomAutoFit",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_IsZoomAutoFit" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (bool)(arg1)->IsZoomAutoFit();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetZoomLevel(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetZoomLevel",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetZoomLevel" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (float)(arg1)->GetZoomLevel();
  resultobj = SWIG_From_float(static_cast< float >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_SetZoomLevel(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  bool arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_SetZoomLevel",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_SetZoomLevel" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextureViewer_SetZoomLevel" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_float(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextureViewer_SetZoomLevel" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  (arg1)->SetZoomLevel(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetHistogramRange(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcpair< float,float > result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetHistogramRange",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetHistogramRange" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (arg1)->GetHistogramRange();
  {
    resultobj = ConvertToPy((rdcpair< float,float >&)result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_SetHistogramRange(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_SetHistogramRange",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_SetHistogramRange" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextureViewer_SetHistogramRange" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextureViewer_SetHistogramRange" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  (arg1)->SetHistogramRange(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_GetChannelVisibilityBits(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_GetChannelVisibilityBits",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_GetChannelVisibilityBits" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  result = (uint32_t)(arg1)->GetChannelVisibilityBits();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TextureViewer_SetChannelVisibility(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITextureViewer *arg1 = (ITextureViewer *) 0 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TextureViewer_SetChannelVisibility",4,4,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITextureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TextureViewer_SetChannelVisibility" "', argument " "1"" of type '" "ITextureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ITextureViewer * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "TextureViewer_SetChannelVisibility" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "TextureViewer_SetChannelVisibility" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "TextureViewer_SetChannelVisibility" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "TextureViewer_SetChannelVisibility" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  (arg1)->SetChannelVisibility(arg2,arg3,arg4,arg5);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"BufferViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_Widget" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ScrollToRow__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  int32_t arg2 ;
  MeshDataStage arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_ScrollToRow" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_ScrollToRow" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "BufferViewer_ScrollToRow" "', argument " "3"" of type '" "MeshDataStage""'");
  } 
  arg3 = static_cast< MeshDataStage >(val3);
  (arg1)->ScrollToRow(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ScrollToRow__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  int32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_ScrollToRow" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_ScrollToRow" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  (arg1)->ScrollToRow(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ScrollToRow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"BufferViewer_ScrollToRow",0,3,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    return _wrap_BufferViewer_ScrollToRow__SWIG_1(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_BufferViewer_ScrollToRow__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BufferViewer_ScrollToRow'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IBufferViewer::ScrollToRow(int32_t,MeshDataStage)\n"
    "    IBufferViewer::ScrollToRow(int32_t)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ScrollToColumn__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  int32_t arg2 ;
  MeshDataStage arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_ScrollToColumn" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_ScrollToColumn" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "BufferViewer_ScrollToColumn" "', argument " "3"" of type '" "MeshDataStage""'");
  } 
  arg3 = static_cast< MeshDataStage >(val3);
  (arg1)->ScrollToColumn(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ScrollToColumn__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  int32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_ScrollToColumn" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_ScrollToColumn" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  (arg1)->ScrollToColumn(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ScrollToColumn(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"BufferViewer_ScrollToColumn",0,3,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    return _wrap_BufferViewer_ScrollToColumn__SWIG_1(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_BufferViewer_ScrollToColumn__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'BufferViewer_ScrollToColumn'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IBufferViewer::ScrollToColumn(int32_t,MeshDataStage)\n"
    "    IBufferViewer::ScrollToColumn(int32_t)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_BufferViewer_ShowMeshData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  MeshDataStage arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_ShowMeshData" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_ShowMeshData" "', argument " "2"" of type '" "MeshDataStage""'");
  } 
  arg2 = static_cast< MeshDataStage >(val2);
  (arg1)->ShowMeshData(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_SetCurrentInstance(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  int32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_SetCurrentInstance" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_SetCurrentInstance" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  (arg1)->SetCurrentInstance(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_SetCurrentView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  int32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_SetCurrentView" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_SetCurrentView" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  (arg1)->SetCurrentView(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BufferViewer_SetPreviewStage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IBufferViewer *arg1 = (IBufferViewer *) 0 ;
  MeshDataStage arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IBufferViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BufferViewer_SetPreviewStage" "', argument " "1"" of type '" "IBufferViewer *""'"); 
  }
  arg1 = reinterpret_cast< IBufferViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BufferViewer_SetPreviewStage" "', argument " "2"" of type '" "MeshDataStage""'");
  } 
  arg2 = static_cast< MeshDataStage >(val2);
  (arg1)->SetPreviewStage(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ResourceInspector_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IResourceInspector *arg1 = (IResourceInspector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ResourceInspector_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IResourceInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ResourceInspector_Widget" "', argument " "1"" of type '" "IResourceInspector *""'"); 
  }
  arg1 = reinterpret_cast< IResourceInspector * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ResourceInspector_Inspect(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IResourceInspector *arg1 = (IResourceInspector *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IResourceInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ResourceInspector_Inspect" "', argument " "1"" of type '" "IResourceInspector *""'"); 
  }
  arg1 = reinterpret_cast< IResourceInspector * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ResourceInspector_Inspect" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ResourceInspector_Inspect" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->Inspect(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ResourceInspector_CurrentResource(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IResourceInspector *arg1 = (IResourceInspector *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ResourceId result;
  
  if (!SWIG_Python_UnpackTuple(args,"ResourceInspector_CurrentResource",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IResourceInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ResourceInspector_CurrentResource" "', argument " "1"" of type '" "IResourceInspector *""'"); 
  }
  arg1 = reinterpret_cast< IResourceInspector * >(argp1);
  result = (arg1)->CurrentResource();
  resultobj = SWIG_NewPointerObj((new ResourceId(static_cast< const ResourceId& >(result))), SWIGTYPE_p_ResourceId, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ResourceInspector_RevealParameter(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IResourceInspector *arg1 = (IResourceInspector *) 0 ;
  SDObject *arg2 = (SDObject *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IResourceInspector, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ResourceInspector_RevealParameter" "', argument " "1"" of type '" "IResourceInspector *""'"); 
  }
  arg1 = reinterpret_cast< IResourceInspector * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_SDObject, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ResourceInspector_RevealParameter" "', argument " "2"" of type '" "SDObject *""'"); 
  }
  arg2 = reinterpret_cast< SDObject * >(argp2);
  (arg1)->RevealParameter(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureDialog_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_Widget" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_IsInjectMode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureDialog_IsInjectMode",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_IsInjectMode" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  result = (bool)(arg1)->IsInjectMode();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SetInjectMode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SetInjectMode" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureDialog_SetInjectMode" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->SetInjectMode(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SetExecutableFilename(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SetExecutableFilename" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureDialog_SetExecutableFilename' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetExecutableFilename((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SetWorkingDirectory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SetWorkingDirectory" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureDialog_SetWorkingDirectory' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetWorkingDirectory((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SetCommandLine(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SetCommandLine" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureDialog_SetCommandLine' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetCommandLine((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SetEnvironmentModifications(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  rdcarray< EnvironmentModification > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SetEnvironmentModifications" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< EnvironmentModification >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureDialog_SetEnvironmentModifications' argument 2 of type 'rdcarray< EnvironmentModification >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureDialog_SetEnvironmentModifications' argument 2 of type 'rdcarray< EnvironmentModification >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  (arg1)->SetEnvironmentModifications((rdcarray< EnvironmentModification > const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SetSettings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  CaptureSettings arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SetSettings" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_CaptureSettings,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureDialog_SetSettings" "', argument " "2"" of type '" "CaptureSettings""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureDialog_SetSettings" "', argument " "2"" of type '" "CaptureSettings""'");
    } else {
      CaptureSettings * temp = reinterpret_cast< CaptureSettings * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->SetSettings(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_Settings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  CaptureSettings result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureDialog_Settings",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_Settings" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  result = (arg1)->Settings();
  resultobj = SWIG_NewPointerObj((new CaptureSettings(static_cast< const CaptureSettings& >(result))), SWIGTYPE_p_CaptureSettings, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_TriggerCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureDialog_TriggerCapture",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_TriggerCapture" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  (arg1)->TriggerCapture();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_LoadSettings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_LoadSettings" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureDialog_LoadSettings' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->LoadSettings((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_SaveSettings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_SaveSettings" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureDialog_SaveSettings' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SaveSettings((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_UpdateGlobalHook(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureDialog_UpdateGlobalHook",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_UpdateGlobalHook" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  (arg1)->UpdateGlobalHook();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureDialog_UpdateRemoteHost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureDialog *arg1 = (ICaptureDialog *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureDialog_UpdateRemoteHost",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureDialog_UpdateRemoteHost" "', argument " "1"" of type '" "ICaptureDialog *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureDialog * >(argp1);
  (arg1)->UpdateRemoteHost();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DebugMessageView_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IDebugMessageView *arg1 = (IDebugMessageView *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"DebugMessageView_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IDebugMessageView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DebugMessageView_Widget" "', argument " "1"" of type '" "IDebugMessageView *""'"); 
  }
  arg1 = reinterpret_cast< IDebugMessageView * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DiagnosticLogView_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IDiagnosticLogView *arg1 = (IDiagnosticLogView *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"DiagnosticLogView_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IDiagnosticLogView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DiagnosticLogView_Widget" "', argument " "1"" of type '" "IDiagnosticLogView *""'"); 
  }
  arg1 = reinterpret_cast< IDiagnosticLogView * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CommentView_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICommentView *arg1 = (ICommentView *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CommentView_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICommentView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CommentView_Widget" "', argument " "1"" of type '" "ICommentView *""'"); 
  }
  arg1 = reinterpret_cast< ICommentView * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CommentView_SetComments(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICommentView *arg1 = (ICommentView *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICommentView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CommentView_SetComments" "', argument " "1"" of type '" "ICommentView *""'"); 
  }
  arg1 = reinterpret_cast< ICommentView * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CommentView_SetComments' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetComments((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CommentView_GetComments(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICommentView *arg1 = (ICommentView *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"CommentView_GetComments",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICommentView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CommentView_GetComments" "', argument " "1"" of type '" "ICommentView *""'"); 
  }
  arg1 = reinterpret_cast< ICommentView * >(argp1);
  result = (arg1)->GetComments();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_StatisticsViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IStatisticsViewer *arg1 = (IStatisticsViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"StatisticsViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IStatisticsViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "StatisticsViewer_Widget" "', argument " "1"" of type '" "IStatisticsViewer *""'"); 
  }
  arg1 = reinterpret_cast< IStatisticsViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TimelineBar_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITimelineBar *arg1 = (ITimelineBar *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"TimelineBar_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITimelineBar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimelineBar_Widget" "', argument " "1"" of type '" "ITimelineBar *""'"); 
  }
  arg1 = reinterpret_cast< ITimelineBar * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TimelineBar_HighlightResourceUsage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITimelineBar *arg1 = (ITimelineBar *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITimelineBar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimelineBar_HighlightResourceUsage" "', argument " "1"" of type '" "ITimelineBar *""'"); 
  }
  arg1 = reinterpret_cast< ITimelineBar * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TimelineBar_HighlightResourceUsage" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TimelineBar_HighlightResourceUsage" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->HighlightResourceUsage(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_TimelineBar_HighlightHistory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ITimelineBar *arg1 = (ITimelineBar *) 0 ;
  ResourceId arg2 ;
  rdcarray< PixelModification > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"TimelineBar_HighlightHistory",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ITimelineBar, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimelineBar_HighlightHistory" "', argument " "1"" of type '" "ITimelineBar *""'"); 
  }
  arg1 = reinterpret_cast< ITimelineBar * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "TimelineBar_HighlightHistory" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "TimelineBar_HighlightHistory" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< PixelModification >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'TimelineBar_HighlightHistory' argument 3 of type 'rdcarray< PixelModification >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'TimelineBar_HighlightHistory' argument 3 of type 'rdcarray< PixelModification >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  (arg1)->HighlightHistory(arg2,(rdcarray< PixelModification > const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PerformanceCounterViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPerformanceCounterViewer *arg1 = (IPerformanceCounterViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PerformanceCounterViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPerformanceCounterViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerformanceCounterViewer_Widget" "', argument " "1"" of type '" "IPerformanceCounterViewer *""'"); 
  }
  arg1 = reinterpret_cast< IPerformanceCounterViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PerformanceCounterViewer_UpdateDurationColumn(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPerformanceCounterViewer *arg1 = (IPerformanceCounterViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"PerformanceCounterViewer_UpdateDurationColumn",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPerformanceCounterViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PerformanceCounterViewer_UpdateDurationColumn" "', argument " "1"" of type '" "IPerformanceCounterViewer *""'"); 
  }
  arg1 = reinterpret_cast< IPerformanceCounterViewer * >(argp1);
  (arg1)->UpdateDurationColumn();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PythonShell_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPythonShell *arg1 = (IPythonShell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PythonShell_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPythonShell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PythonShell_Widget" "', argument " "1"" of type '" "IPythonShell *""'"); 
  }
  arg1 = reinterpret_cast< IPythonShell * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PythonShell_SetScriptText(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPythonShell *arg1 = (IPythonShell *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPythonShell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PythonShell_SetScriptText" "', argument " "1"" of type '" "IPythonShell *""'"); 
  }
  arg1 = reinterpret_cast< IPythonShell * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PythonShell_SetScriptText' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetScriptText(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PythonShell_LoadScriptFromFilename(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPythonShell *arg1 = (IPythonShell *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPythonShell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PythonShell_LoadScriptFromFilename" "', argument " "1"" of type '" "IPythonShell *""'"); 
  }
  arg1 = reinterpret_cast< IPythonShell * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PythonShell_LoadScriptFromFilename' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->LoadScriptFromFilename(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PythonShell_GetScriptText(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPythonShell *arg1 = (IPythonShell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PythonShell_GetScriptText",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPythonShell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PythonShell_GetScriptText" "', argument " "1"" of type '" "IPythonShell *""'"); 
  }
  arg1 = reinterpret_cast< IPythonShell * >(argp1);
  result = (arg1)->GetScriptText();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PythonShell_RunScript(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPythonShell *arg1 = (IPythonShell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"PythonShell_RunScript",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPythonShell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PythonShell_RunScript" "', argument " "1"" of type '" "IPythonShell *""'"); 
  }
  arg1 = reinterpret_cast< IPythonShell * >(argp1);
  (arg1)->RunScript();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_Widget" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_CurrentStep(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderViewer_CurrentStep",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_CurrentStep" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  result = (uint32_t)(arg1)->CurrentStep();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_SetCurrentStep(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_SetCurrentStep" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ShaderViewer_SetCurrentStep" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  (arg1)->SetCurrentStep(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_ToggleBreakpointOnInstruction__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  int32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_ToggleBreakpointOnInstruction" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ShaderViewer_ToggleBreakpointOnInstruction" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  (arg1)->ToggleBreakpointOnInstruction(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_ToggleBreakpointOnInstruction__SWIG_1(PyObject *self, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_ToggleBreakpointOnInstruction" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  (arg1)->ToggleBreakpointOnInstruction();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_ToggleBreakpointOnInstruction(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[3] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ShaderViewer_ToggleBreakpointOnInstruction",0,2,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    return _wrap_ShaderViewer_ToggleBreakpointOnInstruction__SWIG_1(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_ShaderViewer_ToggleBreakpointOnInstruction__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ShaderViewer_ToggleBreakpointOnInstruction'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IShaderViewer::ToggleBreakpointOnInstruction(int32_t)\n"
    "    IShaderViewer::ToggleBreakpointOnInstruction()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_ToggleBreakpointOnDisassemblyLine(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  int32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_ToggleBreakpointOnDisassemblyLine" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ShaderViewer_ToggleBreakpointOnDisassemblyLine" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  (arg1)->ToggleBreakpointOnDisassemblyLine(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_RunForward(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderViewer_RunForward",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_RunForward" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  (arg1)->RunForward();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_ShowErrors(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_ShowErrors" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderViewer_ShowErrors' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->ShowErrors((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_AddWatch(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_AddWatch" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderViewer_AddWatch' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->AddWatch((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderViewer_GetCurrentFileContents(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderViewer *arg1 = (IShaderViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstrpairs result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderViewer_GetCurrentFileContents",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderViewer_GetCurrentFileContents" "', argument " "1"" of type '" "IShaderViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderViewer * >(argp1);
  result = (arg1)->GetCurrentFileContents();
  resultobj = SWIG_NewPointerObj((new rdcstrpairs(static_cast< const rdcstrpairs& >(result))), SWIGTYPE_p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderMessageViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderMessageViewer *arg1 = (IShaderMessageViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderMessageViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderMessageViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderMessageViewer_Widget" "', argument " "1"" of type '" "IShaderMessageViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderMessageViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderMessageViewer_GetEvent(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderMessageViewer *arg1 = (IShaderMessageViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderMessageViewer_GetEvent",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderMessageViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderMessageViewer_GetEvent" "', argument " "1"" of type '" "IShaderMessageViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderMessageViewer * >(argp1);
  result = (uint32_t)(arg1)->GetEvent();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderMessageViewer_GetShaderMessages(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderMessageViewer *arg1 = (IShaderMessageViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ShaderMessage > result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderMessageViewer_GetShaderMessages",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderMessageViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderMessageViewer_GetShaderMessages" "', argument " "1"" of type '" "IShaderMessageViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderMessageViewer * >(argp1);
  result = (arg1)->GetShaderMessages();
  resultobj = SWIG_NewPointerObj((new rdcarray< ShaderMessage >(static_cast< const rdcarray< ShaderMessage >& >(result))), SWIGTYPE_p_rdcarrayT_ShaderMessage_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderMessageViewer_IsOutOfDate(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IShaderMessageViewer *arg1 = (IShaderMessageViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderMessageViewer_IsOutOfDate",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IShaderMessageViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderMessageViewer_IsOutOfDate" "', argument " "1"" of type '" "IShaderMessageViewer *""'"); 
  }
  arg1 = reinterpret_cast< IShaderMessageViewer * >(argp1);
  result = (bool)(arg1)->IsOutOfDate();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_DescriptorViewer_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IDescriptorViewer *arg1 = (IDescriptorViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"DescriptorViewer_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IDescriptorViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "DescriptorViewer_Widget" "', argument " "1"" of type '" "IDescriptorViewer *""'"); 
  }
  arg1 = reinterpret_cast< IDescriptorViewer * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PixelHistoryView_Widget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPixelHistoryView *arg1 = (IPixelHistoryView *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PixelHistoryView_Widget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPixelHistoryView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PixelHistoryView_Widget" "', argument " "1"" of type '" "IPixelHistoryView *""'"); 
  }
  arg1 = reinterpret_cast< IPixelHistoryView * >(argp1);
  result = (QWidget *)(arg1)->Widget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PixelHistoryView_SetHistory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPixelHistoryView *arg1 = (IPixelHistoryView *) 0 ;
  rdcarray< PixelModification > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPixelHistoryView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PixelHistoryView_SetHistory" "', argument " "1"" of type '" "IPixelHistoryView *""'"); 
  }
  arg1 = reinterpret_cast< IPixelHistoryView * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< PixelModification >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PixelHistoryView_SetHistory' argument 2 of type 'rdcarray< PixelModification >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PixelHistoryView_SetHistory' argument 2 of type 'rdcarray< PixelModification >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  (arg1)->SetHistory((rdcarray< PixelModification > const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PixelHistoryView_SetFailedDebug(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IPixelHistoryView *arg1 = (IPixelHistoryView *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"PixelHistoryView_SetFailedDebug",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IPixelHistoryView, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PixelHistoryView_SetFailedDebug" "', argument " "1"" of type '" "IPixelHistoryView *""'"); 
  }
  arg1 = reinterpret_cast< IPixelHistoryView * >(argp1);
  (arg1)->SetFailedDebug();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureViewer_OnCaptureLoaded(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureViewer *arg1 = (ICaptureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureViewer_OnCaptureLoaded",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureViewer_OnCaptureLoaded" "', argument " "1"" of type '" "ICaptureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureViewer * >(argp1);
  (arg1)->OnCaptureLoaded();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureViewer_OnCaptureClosed(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureViewer *arg1 = (ICaptureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureViewer_OnCaptureClosed",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureViewer_OnCaptureClosed" "', argument " "1"" of type '" "ICaptureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureViewer * >(argp1);
  (arg1)->OnCaptureClosed();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureViewer_OnSelectedEventChanged(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureViewer *arg1 = (ICaptureViewer *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureViewer_OnSelectedEventChanged" "', argument " "1"" of type '" "ICaptureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureViewer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureViewer_OnSelectedEventChanged" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  (arg1)->OnSelectedEventChanged(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureViewer_OnEventChanged(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureViewer *arg1 = (ICaptureViewer *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureViewer_OnEventChanged" "', argument " "1"" of type '" "ICaptureViewer *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureViewer * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureViewer_OnEventChanged" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  (arg1)->OnEventChanged(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_DeleteCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  rdcstr *arg2 = 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_DeleteCapture",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_DeleteCapture" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_DeleteCapture' argument 2 of type 'rdcstr'"); 
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ReplayManager_DeleteCapture" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->DeleteCapture((rdcstr const &)*arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_ConnectToRemoteServer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  RemoteHost arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ResultDetails result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_ConnectToRemoteServer" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ReplayManager_ConnectToRemoteServer" "', argument " "2"" of type '" "RemoteHost""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ReplayManager_ConnectToRemoteServer" "', argument " "2"" of type '" "RemoteHost""'");
    } else {
      RemoteHost * temp = reinterpret_cast< RemoteHost * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (arg1)->ConnectToRemoteServer(arg2);
  resultobj = SWIG_NewPointerObj((new ResultDetails(static_cast< const ResultDetails& >(result))), SWIGTYPE_p_ResultDetails, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_DisconnectFromRemoteServer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_DisconnectFromRemoteServer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_DisconnectFromRemoteServer" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  (arg1)->DisconnectFromRemoteServer();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_ShutdownServer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_ShutdownServer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_ShutdownServer" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  (arg1)->ShutdownServer();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_PingRemote(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_PingRemote",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_PingRemote" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  (arg1)->PingRemote();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_CancelReplayLoop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_CancelReplayLoop",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_CancelReplayLoop" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  (arg1)->CancelReplayLoop();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_CurrentRemote(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  RemoteHost result;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_CurrentRemote",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_CurrentRemote" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  result = (arg1)->CurrentRemote();
  resultobj = SWIG_NewPointerObj((new RemoteHost(static_cast< const RemoteHost& >(result))), SWIGTYPE_p_RemoteHost, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_GetCaptureAccess(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ICaptureAccess *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_GetCaptureAccess",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_GetCaptureAccess" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  result = (ICaptureAccess *)(arg1)->GetCaptureAccess();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ICaptureAccess, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_GetCaptureFile(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ICaptureFile *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_GetCaptureFile",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_GetCaptureFile" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  result = (ICaptureFile *)(arg1)->GetCaptureFile();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ICaptureFile, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_ExecuteAndInject(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  rdcarray< EnvironmentModification > *arg5 = 0 ;
  rdcstr *arg6 = 0 ;
  CaptureOptions arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  rdcstr temp4 ;
  unsigned char tempmem5[32] ;
  bool wasSelf5 = false ;
  rdcstr temp6 ;
  void *argp7 ;
  int res7 = 0 ;
  PyObject *swig_obj[7] ;
  ExecuteResult result;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_ExecuteAndInject",6,6,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_ExecuteAndInject" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_ExecuteAndInject' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_ExecuteAndInject' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_ExecuteAndInject' argument 4 of type 'rdcstr'"); 
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg5)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem5) >= sizeof(array_type), "not enough temp space for rdcarray< EnvironmentModification >");
      
      tempalloc(arg5, tempmem5);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[3], indirect(arg5), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_ExecuteAndInject' argument 5 of type 'rdcarray< EnvironmentModification >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'ReplayManager_ExecuteAndInject' argument 5 of type 'rdcarray< EnvironmentModification >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    tempset(arg6, &temp6);
    
    int res = ConvertFromPy(swig_obj[4], indirect(arg6));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_ExecuteAndInject' argument 6 of type 'rdcstr'"); 
    }
  }
  {
    res7 = SWIG_ConvertPtr(swig_obj[5], &argp7, SWIGTYPE_p_CaptureOptions,  0  | 0);
    if (!SWIG_IsOK(res7)) {
      SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "ReplayManager_ExecuteAndInject" "', argument " "7"" of type '" "CaptureOptions""'"); 
    }  
    if (!argp7) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ReplayManager_ExecuteAndInject" "', argument " "7"" of type '" "CaptureOptions""'");
    } else {
      CaptureOptions * temp = reinterpret_cast< CaptureOptions * >(argp7);
      arg7 = *temp;
      if (SWIG_IsNewObj(res7)) delete temp;
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg5); 
  }
  result = (arg1)->ExecuteAndInject((rdcstr const &)*arg2,(rdcstr const &)*arg3,(rdcstr const &)*arg4,(rdcarray< EnvironmentModification > const &)*arg5,(rdcstr const &)*arg6,arg7);
  resultobj = SWIG_NewPointerObj((new ExecuteResult(static_cast< const ExecuteResult& >(result))), SWIGTYPE_p_ExecuteResult, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_GetRemoteSupport(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< rdcstr > result;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_GetRemoteSupport",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_GetRemoteSupport" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  result = (arg1)->GetRemoteSupport();
  resultobj = SWIG_NewPointerObj((new rdcarray< rdcstr >(static_cast< const rdcarray< rdcstr >& >(result))), SWIGTYPE_p_rdcarrayT_rdcstr_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_GetHomeFolder(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  bool arg2 ;
  SwigValueWrapper< std::function< void (rdcstr const &,rdcarray< PathEntry > const &) > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  StackExceptionHandler exHandle3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_GetHomeFolder",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_GetHomeFolder" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ReplayManager_GetHomeFolder" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    PyObject *func = swig_obj[1];
    arg3 = ConvertFunc<IReplayManager::DirectoryBrowseCallback>("ReplayManager_GetHomeFolder", func, exHandle3);
  }
  (arg1)->GetHomeFolder(arg2,arg3);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle3.data().failFlag) {
      PyErr_Restore(exHandle3.data().exObj, exHandle3.data().valueObj, exHandle3.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_ListFolder(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  rdcstr *arg2 = 0 ;
  bool arg3 ;
  SwigValueWrapper< std::function< void (rdcstr const &,rdcarray< PathEntry > const &) > > arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  bool val3 ;
  int ecode3 = 0 ;
  StackExceptionHandler exHandle4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_ListFolder",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_ListFolder" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_ListFolder' argument 2 of type 'rdcstr'"); 
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "ReplayManager_ListFolder" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    PyObject *func = swig_obj[2];
    arg4 = ConvertFunc<IReplayManager::DirectoryBrowseCallback>("ReplayManager_ListFolder", func, exHandle4);
  }
  (arg1)->ListFolder((rdcstr const &)*arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle4.data().failFlag) {
      PyErr_Restore(exHandle4.data().exObj, exHandle4.data().valueObj, exHandle4.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_CopyCaptureToRemote(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  rdcstr *arg2 = 0 ;
  QWidget *arg3 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[3] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_CopyCaptureToRemote",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_CopyCaptureToRemote" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_CopyCaptureToRemote' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    if(Py_IsNone(swig_obj[1]))
    arg3 = NULL;
    else
    arg3 = QWidgetFromPy(swig_obj[1]);
    if(swig_obj[1] && !Py_IsNone(swig_obj[1]) && !arg3)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'ReplayManager_CopyCaptureToRemote' QWidget expected for argument 3 of type 'QWidget'");
    }
  }
  result = (arg1)->CopyCaptureToRemote((rdcstr const &)*arg2,arg3);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_CopyCaptureFromRemote(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  QWidget *arg4 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_CopyCaptureFromRemote",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_CopyCaptureFromRemote" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_CopyCaptureFromRemote' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_CopyCaptureFromRemote' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    if(Py_IsNone(swig_obj[2]))
    arg4 = NULL;
    else
    arg4 = QWidgetFromPy(swig_obj[2]);
    if(swig_obj[2] && !Py_IsNone(swig_obj[2]) && !arg4)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'ReplayManager_CopyCaptureFromRemote' QWidget expected for argument 4 of type 'QWidget'");
    }
  }
  (arg1)->CopyCaptureFromRemote((rdcstr const &)*arg2,(rdcstr const &)*arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_GetCurrentProcessingTime(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!SWIG_Python_UnpackTuple(args,"ReplayManager_GetCurrentProcessingTime",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_GetCurrentProcessingTime" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  result = (float)(arg1)->GetCurrentProcessingTime();
  resultobj = SWIG_From_float(static_cast< float >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_AsyncInvoke__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  rdcstr *arg2 = 0 ;
  SwigValueWrapper< std::function< void (IReplayController *) > > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  StackExceptionHandler exHandle3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_AsyncInvoke" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ReplayManager_AsyncInvoke' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    PyObject *func = swig_obj[2];
    arg3 = ConvertFunc<IReplayManager::InvokeCallback>("ReplayManager_AsyncInvoke", func, exHandle3);
  }
  (arg1)->AsyncInvoke((rdcstr const &)*arg2,arg3);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle3.data().failFlag) {
      PyErr_Restore(exHandle3.data().exObj, exHandle3.data().valueObj, exHandle3.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_AsyncInvoke__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  SwigValueWrapper< std::function< void (IReplayController *) > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StackExceptionHandler exHandle2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_AsyncInvoke" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    PyObject *func = swig_obj[1];
    arg2 = ConvertFunc<IReplayManager::InvokeCallback>("ReplayManager_AsyncInvoke", func, exHandle2);
  }
  (arg1)->AsyncInvoke(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ReplayManager_AsyncInvoke(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ReplayManager_AsyncInvoke",0,3,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    return _wrap_ReplayManager_AsyncInvoke__SWIG_1(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_ReplayManager_AsyncInvoke__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ReplayManager_AsyncInvoke'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IReplayManager::AsyncInvoke(rdcstr const &,IReplayManager::InvokeCallback)\n"
    "    IReplayManager::AsyncInvoke(IReplayManager::InvokeCallback)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ReplayManager_BlockInvoke(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IReplayManager *arg1 = (IReplayManager *) 0 ;
  SwigValueWrapper< std::function< void (IReplayController *) > > arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IReplayManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ReplayManager_BlockInvoke" "', argument " "1"" of type '" "IReplayManager *""'"); 
  }
  arg1 = reinterpret_cast< IReplayManager * >(argp1);
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<IReplayManager::InvokeCallback>("ReplayManager_BlockInvoke", func, exHandle2);
  }
  IReplayManager_BlockInvoke(arg1,arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_DockReference(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  DockReference *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_DockReference",0,0,0)) SWIG_fail;
  result = (DockReference *)new DockReference();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DockReference, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_DockReference(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  DockReference *arg1 = (DockReference *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_DockReference",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_DockReference, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DockReference" "', argument " "1"" of type '" "DockReference *""'"); 
  }
  arg1 = reinterpret_cast< DockReference * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DockReference) /* defines _wrap_delete_DockReference_destructor_closure */

SWIGINTERN int _wrap_new_CaptureModifications(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureModifications *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_CaptureModifications",0,0,0)) SWIG_fail;
  result = (CaptureModifications *)new CaptureModifications();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_CaptureModifications, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_CaptureModifications(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  CaptureModifications *arg1 = (CaptureModifications *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_CaptureModifications",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_CaptureModifications, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_CaptureModifications" "', argument " "1"" of type '" "CaptureModifications *""'"); 
  }
  arg1 = reinterpret_cast< CaptureModifications * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_CaptureModifications) /* defines _wrap_delete_CaptureModifications_destructor_closure */

SWIGINTERN PyObject *_wrap_EventBookmark_eventId_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark_eventId_set" "', argument " "1"" of type '" "EventBookmark *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "EventBookmark_eventId_set" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  if (arg1) (arg1)->eventId = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBookmark_eventId_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"EventBookmark_eventId_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark_eventId_get" "', argument " "1"" of type '" "EventBookmark *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  result = (uint32_t) ((arg1)->eventId);
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBookmark_text_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark_text_set" "', argument " "1"" of type '" "EventBookmark *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'EventBookmark_text_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->text = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBookmark_text_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"EventBookmark_text_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark_text_get" "', argument " "1"" of type '" "EventBookmark *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  result =  ((arg1)->text);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_EventBookmark__SWIG_0(PyObject *self, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  EventBookmark *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  result = (EventBookmark *)new EventBookmark();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventBookmark, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_EventBookmark__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  uint32_t arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  EventBookmark *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_EventBookmark" "', argument " "1"" of type '" "uint32_t""'");
  } 
  arg1 = static_cast< uint32_t >(val1);
  result = (EventBookmark *)new EventBookmark(arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_EventBookmark, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_EventBookmark(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_EventBookmark",0,1,argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_EventBookmark__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    return _wrap_new_EventBookmark__SWIG_1(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_EventBookmark'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    EventBookmark::EventBookmark()\n"
    "    EventBookmark::EventBookmark(uint32_t)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_EventBookmark___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  EventBookmark *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark___eq__" "', argument " "1"" of type '" "EventBookmark const *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_EventBookmark,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventBookmark___eq__" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventBookmark___eq__" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  arg2 = reinterpret_cast< EventBookmark * >(argp2);
  result = (bool)((EventBookmark const *)arg1)->operator ==((EventBookmark const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBookmark___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  EventBookmark *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark___ne__" "', argument " "1"" of type '" "EventBookmark const *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_EventBookmark,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventBookmark___ne__" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventBookmark___ne__" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  arg2 = reinterpret_cast< EventBookmark * >(argp2);
  result = (bool)((EventBookmark const *)arg1)->operator !=((EventBookmark const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_EventBookmark___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  EventBookmark *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "EventBookmark___lt__" "', argument " "1"" of type '" "EventBookmark const *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_EventBookmark,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "EventBookmark___lt__" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "EventBookmark___lt__" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  arg2 = reinterpret_cast< EventBookmark * >(argp2);
  result = (bool)((EventBookmark const *)arg1)->operator <((EventBookmark const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_EventBookmark(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  EventBookmark *arg1 = (EventBookmark *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_EventBookmark",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_EventBookmark, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_EventBookmark" "', argument " "1"" of type '" "EventBookmark *""'"); 
  }
  arg1 = reinterpret_cast< EventBookmark * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_EventBookmark) /* defines _wrap_delete_EventBookmark_destructor_closure */

SWIGINTERN PyObject *_wrap_RGPInterop_HasRGPEvent(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IRGPInterop *arg1 = (IRGPInterop *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IRGPInterop, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RGPInterop_HasRGPEvent" "', argument " "1"" of type '" "IRGPInterop *""'"); 
  }
  arg1 = reinterpret_cast< IRGPInterop * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RGPInterop_HasRGPEvent" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (bool)(arg1)->HasRGPEvent(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RGPInterop_SelectRGPEvent(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IRGPInterop *arg1 = (IRGPInterop *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IRGPInterop, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RGPInterop_SelectRGPEvent" "', argument " "1"" of type '" "IRGPInterop *""'"); 
  }
  arg1 = reinterpret_cast< IRGPInterop * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "RGPInterop_SelectRGPEvent" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (bool)(arg1)->SelectRGPEvent(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_RGPInterop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IRGPInterop *arg1 = (IRGPInterop *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_RGPInterop",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IRGPInterop, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RGPInterop" "', argument " "1"" of type '" "IRGPInterop *""'"); 
  }
  arg1 = reinterpret_cast< IRGPInterop * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_RGPInterop) /* defines _wrap_delete_RGPInterop_destructor_closure */

SWIGINTERN PyObject *_wrap_CaptureContext_TempCaptureFilename(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_TempCaptureFilename" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_TempCaptureFilename' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->TempCaptureFilename((rdcstr const &)*arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_LoadCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  ReplayOptions *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  bool arg5 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  rdcstr temp4 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_LoadCapture",5,5,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_LoadCapture" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_LoadCapture' argument 2 of type 'rdcstr'"); 
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ReplayOptions,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaptureContext_LoadCapture" "', argument " "3"" of type '" "ReplayOptions const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_LoadCapture" "', argument " "3"" of type '" "ReplayOptions const &""'"); 
  }
  arg3 = reinterpret_cast< ReplayOptions * >(argp3);
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_LoadCapture' argument 4 of type 'rdcstr'"); 
    }
  }
  ecode5 = SWIG_AsVal_bool(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "CaptureContext_LoadCapture" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "CaptureContext_LoadCapture" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  (arg1)->LoadCapture((rdcstr const &)*arg2,(ReplayOptions const &)*arg3,(rdcstr const &)*arg4,arg5,arg6);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SaveCaptureTo(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_SaveCaptureTo" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_SaveCaptureTo' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->SaveCaptureTo((rdcstr const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_RecompressCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_RecompressCapture",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_RecompressCapture" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->RecompressCapture();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CloseCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CloseCapture",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CloseCapture" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->CloseCapture();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ImportCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  CaptureFileFormat *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  rdcstr temp3 ;
  rdcstr temp4 ;
  PyObject *swig_obj[4] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ImportCapture",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ImportCapture" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_CaptureFileFormat,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ImportCapture" "', argument " "2"" of type '" "CaptureFileFormat const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ImportCapture" "', argument " "2"" of type '" "CaptureFileFormat const &""'"); 
  }
  arg2 = reinterpret_cast< CaptureFileFormat * >(argp2);
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ImportCapture' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ImportCapture' argument 4 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->ImportCapture((CaptureFileFormat const &)*arg2,(rdcstr const &)*arg3,(rdcstr const &)*arg4);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ExportCapture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  CaptureFileFormat *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ExportCapture",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ExportCapture" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_CaptureFileFormat,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ExportCapture" "', argument " "2"" of type '" "CaptureFileFormat const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ExportCapture" "', argument " "2"" of type '" "CaptureFileFormat const &""'"); 
  }
  arg2 = reinterpret_cast< CaptureFileFormat * >(argp2);
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ExportCapture' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->ExportCapture((CaptureFileFormat const &)*arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SetEventID__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcarray< ICaptureViewer * > *arg2 = 0 ;
  uint32_t arg3 ;
  uint32_t arg4 ;
  bool arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_SetEventID" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_SetEventID' argument 2 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureContext_SetEventID' argument 2 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_SetEventID" "', argument " "3"" of type '" "uint32_t""'");
  } 
  arg3 = static_cast< uint32_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CaptureContext_SetEventID" "', argument " "4"" of type '" "uint32_t""'");
  } 
  arg4 = static_cast< uint32_t >(val4);
  ecode5 = SWIG_AsVal_bool(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "CaptureContext_SetEventID" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  (arg1)->SetEventID((rdcarray< ICaptureViewer * > const &)*arg2,arg3,arg4,arg5);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SetEventID__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcarray< ICaptureViewer * > *arg2 = 0 ;
  uint32_t arg3 ;
  uint32_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_SetEventID" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_SetEventID' argument 2 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureContext_SetEventID' argument 2 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_SetEventID" "', argument " "3"" of type '" "uint32_t""'");
  } 
  arg3 = static_cast< uint32_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(swig_obj[3], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CaptureContext_SetEventID" "', argument " "4"" of type '" "uint32_t""'");
  } 
  arg4 = static_cast< uint32_t >(val4);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  (arg1)->SetEventID((rdcarray< ICaptureViewer * > const &)*arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SetEventID(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"CaptureContext_SetEventID",0,5,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 4) {
    return _wrap_CaptureContext_SetEventID__SWIG_1(self, argc, argv);
  }
  if (argc == 5) {
    return _wrap_CaptureContext_SetEventID__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'CaptureContext_SetEventID'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ICaptureContext::SetEventID(rdcarray< ICaptureViewer * > const &,uint32_t,uint32_t,bool)\n"
    "    ICaptureContext::SetEventID(rdcarray< ICaptureViewer * > const &,uint32_t,uint32_t)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaptureContext_RefreshStatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_RefreshStatus",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_RefreshStatus" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->RefreshStatus();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_IsResourceReplaced(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_IsResourceReplaced" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_IsResourceReplaced" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_IsResourceReplaced" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (bool)(arg1)->IsResourceReplaced(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetResourceReplacement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ResourceId result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetResourceReplacement" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetResourceReplacement" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetResourceReplacement" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (arg1)->GetResourceReplacement(arg2);
  resultobj = SWIG_NewPointerObj((new ResourceId(static_cast< const ResourceId& >(result))), SWIGTYPE_p_ResourceId, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_RegisterReplacement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  ResourceId arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_RegisterReplacement",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_RegisterReplacement" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_RegisterReplacement" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_RegisterReplacement" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaptureContext_RegisterReplacement" "', argument " "3"" of type '" "ResourceId""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_RegisterReplacement" "', argument " "3"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  (arg1)->RegisterReplacement(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_UnregisterReplacement(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_UnregisterReplacement" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_UnregisterReplacement" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_UnregisterReplacement" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->UnregisterReplacement(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_AddCaptureViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ICaptureViewer *arg2 = (ICaptureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_AddCaptureViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_AddCaptureViewer" "', argument " "2"" of type '" "ICaptureViewer *""'"); 
  }
  arg2 = reinterpret_cast< ICaptureViewer * >(argp2);
  (arg1)->AddCaptureViewer(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_RemoveCaptureViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ICaptureViewer *arg2 = (ICaptureViewer *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_RemoveCaptureViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_RemoveCaptureViewer" "', argument " "2"" of type '" "ICaptureViewer *""'"); 
  }
  arg2 = reinterpret_cast< ICaptureViewer * >(argp2);
  (arg1)->RemoveCaptureViewer(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_Replay(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IReplayManager *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_Replay",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_Replay" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IReplayManager *) &(arg1)->Replay();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IReplayManager, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ConnectToRemoteServer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  RemoteHost arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ConnectToRemoteServer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ConnectToRemoteServer" "', argument " "2"" of type '" "RemoteHost""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ConnectToRemoteServer" "', argument " "2"" of type '" "RemoteHost""'");
    } else {
      RemoteHost * temp = reinterpret_cast< RemoteHost * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->ConnectToRemoteServer(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_IsCaptureLoaded(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_IsCaptureLoaded",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_IsCaptureLoaded" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->IsCaptureLoaded();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_IsCaptureLocal(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_IsCaptureLocal",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_IsCaptureLocal" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->IsCaptureLocal();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_IsCaptureTemporary(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_IsCaptureTemporary",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_IsCaptureTemporary" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->IsCaptureTemporary();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_IsCaptureLoading(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_IsCaptureLoading",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_IsCaptureLoading" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->IsCaptureLoading();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetFatalError(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ResultDetails result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetFatalError",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetFatalError" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (arg1)->GetFatalError();
  resultobj = SWIG_NewPointerObj((new ResultDetails(static_cast< const ResultDetails& >(result))), SWIGTYPE_p_ResultDetails, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetCaptureFilename(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetCaptureFilename",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetCaptureFilename" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (arg1)->GetCaptureFilename();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetCaptureModifications(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  CaptureModifications result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetCaptureModifications",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetCaptureModifications" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (CaptureModifications)(arg1)->GetCaptureModifications();
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_CaptureModifications->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_FrameInfo(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  FrameDescription *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_FrameInfo",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_FrameInfo" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (FrameDescription *) &(arg1)->FrameInfo();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_FrameDescription, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_APIProps(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  APIProperties *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_APIProps",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_APIProps" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (APIProperties *) &(arg1)->APIProps();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_APIProperties, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_TargetShaderEncodings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ShaderEncoding > result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_TargetShaderEncodings",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_TargetShaderEncodings" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (arg1)->TargetShaderEncodings();
  resultobj = SWIG_NewPointerObj((new rdcarray< ShaderEncoding >(static_cast< const rdcarray< ShaderEncoding >& >(result))), SWIGTYPE_p_rdcarrayT_ShaderEncoding_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CustomShaderEncodings(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ShaderEncoding > result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CustomShaderEncodings",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CustomShaderEncodings" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (arg1)->CustomShaderEncodings();
  resultobj = SWIG_NewPointerObj((new rdcarray< ShaderEncoding >(static_cast< const rdcarray< ShaderEncoding >& >(result))), SWIGTYPE_p_rdcarrayT_ShaderEncoding_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CustomShaderSourcePrefixes(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ShaderSourcePrefix > result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CustomShaderSourcePrefixes",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CustomShaderSourcePrefixes" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (arg1)->CustomShaderSourcePrefixes();
  resultobj = SWIG_NewPointerObj((new rdcarray< ShaderSourcePrefix >(static_cast< const rdcarray< ShaderSourcePrefix >& >(result))), SWIGTYPE_p_rdcarrayT_ShaderSourcePrefix_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurSelectedEvent(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurSelectedEvent",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurSelectedEvent" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (uint32_t)(arg1)->CurSelectedEvent();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurEvent(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  uint32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurEvent",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurEvent" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (uint32_t)(arg1)->CurEvent();
  resultobj = SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurSelectedAction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ActionDescription *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurSelectedAction",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurSelectedAction" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ActionDescription *)(arg1)->CurSelectedAction();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ActionDescription, 0 |  0 );
  {
    // for ActionDescription pointers don't apply parent tracking, since these are preserved
    // in other ways and the linked-list nature of walking them can produce absurdly long
    // parent chains
    if (SwigPyObject_Check(resultobj))
    {
      SwigPyObject *sobj = (SwigPyObject *)resultobj;
      if(sobj->parent)
      {
        sobj->parent = NULL;
        Py_DECREF(self);
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurAction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ActionDescription *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurAction",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurAction" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ActionDescription *)(arg1)->CurAction();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ActionDescription, 0 |  0 );
  {
    // for ActionDescription pointers don't apply parent tracking, since these are preserved
    // in other ways and the linked-list nature of walking them can produce absurdly long
    // parent chains
    if (SwigPyObject_Check(resultobj))
    {
      SwigPyObject *sobj = (SwigPyObject *)resultobj;
      if(sobj->parent)
      {
        sobj->parent = NULL;
        Py_DECREF(self);
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetFirstAction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ActionDescription *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetFirstAction",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetFirstAction" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ActionDescription *)(arg1)->GetFirstAction();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ActionDescription, 0 |  0 );
  {
    // for ActionDescription pointers don't apply parent tracking, since these are preserved
    // in other ways and the linked-list nature of walking them can produce absurdly long
    // parent chains
    if (SwigPyObject_Check(resultobj))
    {
      SwigPyObject *sobj = (SwigPyObject *)resultobj;
      if(sobj->parent)
      {
        sobj->parent = NULL;
        Py_DECREF(self);
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetLastAction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ActionDescription *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetLastAction",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetLastAction" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ActionDescription *)(arg1)->GetLastAction();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ActionDescription, 0 |  0 );
  {
    // for ActionDescription pointers don't apply parent tracking, since these are preserved
    // in other ways and the linked-list nature of walking them can produce absurdly long
    // parent chains
    if (SwigPyObject_Check(resultobj))
    {
      SwigPyObject *sobj = (SwigPyObject *)resultobj;
      if(sobj->parent)
      {
        sobj->parent = NULL;
        Py_DECREF(self);
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurRootActions(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ActionDescription > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurRootActions",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurRootActions" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (rdcarray< ActionDescription > *) &(arg1)->CurRootActions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_ActionDescription_t, 0 |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetResource(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ResourceDescription *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetResource" "', argument " "1"" of type '" "ICaptureContext const *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetResource" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetResource" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (ResourceDescription *)((ICaptureContext const *)arg1)->GetResource(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ResourceDescription, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetResources(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ResourceDescription > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetResources",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetResources" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (rdcarray< ResourceDescription > *) &(arg1)->GetResources();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_ResourceDescription_t, 0 |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetResourceName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetResourceName" "', argument " "1"" of type '" "ICaptureContext const *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetResourceName" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetResourceName" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = ((ICaptureContext const *)arg1)->GetResourceName(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetResourceNameUnsuffixed(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetResourceNameUnsuffixed" "', argument " "1"" of type '" "ICaptureContext const *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetResourceNameUnsuffixed" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetResourceNameUnsuffixed" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = ((ICaptureContext const *)arg1)->GetResourceNameUnsuffixed(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_IsAutogeneratedName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_IsAutogeneratedName" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_IsAutogeneratedName" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_IsAutogeneratedName" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (bool)(arg1)->IsAutogeneratedName(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasResourceCustomName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasResourceCustomName" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_HasResourceCustomName" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_HasResourceCustomName" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (bool)(arg1)->HasResourceCustomName(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SetResourceCustomName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_SetResourceCustomName",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_SetResourceCustomName" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_SetResourceCustomName" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_SetResourceCustomName" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_SetResourceCustomName' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetResourceCustomName(arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ResourceNameCacheID(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ResourceNameCacheID",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ResourceNameCacheID" "', argument " "1"" of type '" "ICaptureContext const *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (int32_t)((ICaptureContext const *)arg1)->ResourceNameCacheID();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetTexture(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  TextureDescription *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetTexture" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetTexture" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetTexture" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (TextureDescription *)(arg1)->GetTexture(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TextureDescription, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetTextures(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< TextureDescription > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetTextures",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetTextures" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (rdcarray< TextureDescription > *) &(arg1)->GetTextures();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_TextureDescription_t, 0 |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetBuffer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  BufferDescription *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetBuffer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetBuffer" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetBuffer" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (BufferDescription *)(arg1)->GetBuffer(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BufferDescription, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetBuffers(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< BufferDescription > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetBuffers",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetBuffers" "', argument " "1"" of type '" "ICaptureContext const *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (rdcarray< BufferDescription > *) &((ICaptureContext const *)arg1)->GetBuffers();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_BufferDescription_t, 0 |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetDescriptorStore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  DescriptorStoreDescription *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetDescriptorStore" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_GetDescriptorStore" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_GetDescriptorStore" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (DescriptorStoreDescription *)(arg1)->GetDescriptorStore(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DescriptorStoreDescription, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetAction(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  ActionDescription *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetAction" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_GetAction" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  result = (ActionDescription *)(arg1)->GetAction(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ActionDescription, 0 |  0 );
  {
    // for ActionDescription pointers don't apply parent tracking, since these are preserved
    // in other ways and the linked-list nature of walking them can produce absurdly long
    // parent chains
    if (SwigPyObject_Check(resultobj))
    {
      SwigPyObject *sobj = (SwigPyObject *)resultobj;
      if(sobj->parent)
      {
        sobj->parent = NULL;
        Py_DECREF(self);
      }
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_OpenRGPProfile(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_OpenRGPProfile" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_OpenRGPProfile' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->OpenRGPProfile((rdcstr const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ClearReplayCache(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ClearReplayCache",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ClearReplayCache" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ClearReplayCache();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetRGPInterop(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IRGPInterop *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetRGPInterop",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetRGPInterop" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IRGPInterop *)(arg1)->GetRGPInterop();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IRGPInterop, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetStructuredFile(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  SDFile *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetStructuredFile",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetStructuredFile" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (SDFile *) &(arg1)->GetStructuredFile();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_SDFile, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurWindowingSystem(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  WindowingSystem result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurWindowingSystem",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurWindowingSystem" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (WindowingSystem)(arg1)->CurWindowingSystem();
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_WindowingSystem->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CreateWindowingData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  WindowingData result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CreateWindowingData" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_CreateWindowingData' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (arg1)->CreateWindowingData(arg2);
  resultobj = SWIG_NewPointerObj((new WindowingData(static_cast< const WindowingData& >(result))), SWIGTYPE_p_WindowingData, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_DebugMessages(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< DebugMessage > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_DebugMessages",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_DebugMessages" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (rdcarray< DebugMessage > *) &(arg1)->DebugMessages();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_DebugMessage_t, 0 |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_UnreadMessageCount(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int32_t result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_UnreadMessageCount",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_UnreadMessageCount" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (int32_t)(arg1)->UnreadMessageCount();
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_MarkMessagesRead(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_MarkMessagesRead",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_MarkMessagesRead" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->MarkMessagesRead();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_AddMessages(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcarray< DebugMessage > *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_AddMessages" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< DebugMessage >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_AddMessages' argument 2 of type 'rdcarray< DebugMessage >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureContext_AddMessages' argument 2 of type 'rdcarray< DebugMessage >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  (arg1)->AddMessages((rdcarray< DebugMessage > const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ClearMessages(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ClearMessages",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ClearMessages" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ClearMessages();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetNotes(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetNotes" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_GetNotes' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->GetNotes((rdcstr const &)*arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SetNotes(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_SetNotes",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_SetNotes" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_SetNotes' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_SetNotes' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetNotes((rdcstr const &)*arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetBookmarks(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< EventBookmark > result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetBookmarks",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetBookmarks" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (arg1)->GetBookmarks();
  resultobj = SWIG_NewPointerObj((new rdcarray< EventBookmark >(static_cast< const rdcarray< EventBookmark >& >(result))), SWIGTYPE_p_rdcarrayT_EventBookmark_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_SetBookmark(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  EventBookmark *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_SetBookmark" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_EventBookmark,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_SetBookmark" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_SetBookmark" "', argument " "2"" of type '" "EventBookmark const &""'"); 
  }
  arg2 = reinterpret_cast< EventBookmark * >(argp2);
  (arg1)->SetBookmark((EventBookmark const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_RemoveBookmark(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  uint32_t arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_RemoveBookmark" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_RemoveBookmark" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  (arg1)->RemoveBookmark(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_DelayedCallback(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  uint32_t arg2 ;
  std::function< void () > arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned int val2 ;
  int ecode2 = 0 ;
  StackExceptionHandler exHandle3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_DelayedCallback",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_DelayedCallback" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_DelayedCallback" "', argument " "2"" of type '" "uint32_t""'");
  } 
  arg2 = static_cast< uint32_t >(val2);
  {
    PyObject *func = swig_obj[1];
    arg3 = ConvertFunc<std::function< void () >>("CaptureContext_DelayedCallback", func, exHandle3);
  }
  (arg1)->DelayedCallback(arg2,arg3);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle3.data().failFlag) {
      PyErr_Restore(exHandle3.data().exObj, exHandle3.data().valueObj, exHandle3.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetMainWindow(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMainWindow *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetMainWindow",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetMainWindow" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IMainWindow *)(arg1)->GetMainWindow();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMainWindow, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetEventBrowser(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IEventBrowser *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetEventBrowser",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetEventBrowser" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IEventBrowser *)(arg1)->GetEventBrowser();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IEventBrowser, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetAPIInspector(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IAPIInspector *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetAPIInspector",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetAPIInspector" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IAPIInspector *)(arg1)->GetAPIInspector();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IAPIInspector, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetTextureViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ITextureViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetTextureViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetTextureViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ITextureViewer *)(arg1)->GetTextureViewer();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ITextureViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetMeshPreview(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IBufferViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetMeshPreview",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetMeshPreview" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IBufferViewer *)(arg1)->GetMeshPreview();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IBufferViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetPipelineViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IPipelineStateViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetPipelineViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetPipelineViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IPipelineStateViewer *)(arg1)->GetPipelineViewer();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IPipelineStateViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetCaptureDialog(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ICaptureDialog *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetCaptureDialog",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetCaptureDialog" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ICaptureDialog *)(arg1)->GetCaptureDialog();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ICaptureDialog, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetDebugMessageView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IDebugMessageView *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetDebugMessageView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetDebugMessageView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IDebugMessageView *)(arg1)->GetDebugMessageView();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IDebugMessageView, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetDiagnosticLogView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IDiagnosticLogView *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetDiagnosticLogView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetDiagnosticLogView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IDiagnosticLogView *)(arg1)->GetDiagnosticLogView();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IDiagnosticLogView, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetCommentView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ICommentView *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetCommentView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetCommentView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ICommentView *)(arg1)->GetCommentView();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ICommentView, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetPerformanceCounterViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IPerformanceCounterViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetPerformanceCounterViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetPerformanceCounterViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IPerformanceCounterViewer *)(arg1)->GetPerformanceCounterViewer();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IPerformanceCounterViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetStatisticsViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IStatisticsViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetStatisticsViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetStatisticsViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IStatisticsViewer *)(arg1)->GetStatisticsViewer();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IStatisticsViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetTimelineBar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ITimelineBar *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetTimelineBar",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetTimelineBar" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (ITimelineBar *)(arg1)->GetTimelineBar();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ITimelineBar, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetPythonShell(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IPythonShell *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetPythonShell",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetPythonShell" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IPythonShell *)(arg1)->GetPythonShell();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IPythonShell, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_GetResourceInspector(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IResourceInspector *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_GetResourceInspector",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_GetResourceInspector" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IResourceInspector *)(arg1)->GetResourceInspector();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IResourceInspector, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasEventBrowser(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasEventBrowser",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasEventBrowser" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasEventBrowser();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasAPIInspector(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasAPIInspector",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasAPIInspector" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasAPIInspector();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasTextureViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasTextureViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasTextureViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasTextureViewer();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasPipelineViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasPipelineViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasPipelineViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasPipelineViewer();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasMeshPreview(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasMeshPreview",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasMeshPreview" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasMeshPreview();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasCaptureDialog(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasCaptureDialog",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasCaptureDialog" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasCaptureDialog();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasDebugMessageView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasDebugMessageView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasDebugMessageView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasDebugMessageView();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasDiagnosticLogView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasDiagnosticLogView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasDiagnosticLogView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasDiagnosticLogView();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasCommentView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasCommentView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasCommentView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasCommentView();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasPerformanceCounterViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasPerformanceCounterViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasPerformanceCounterViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasPerformanceCounterViewer();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasStatisticsViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasStatisticsViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasStatisticsViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasStatisticsViewer();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasTimelineBar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasTimelineBar",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasTimelineBar" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasTimelineBar();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasPythonShell(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasPythonShell",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasPythonShell" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasPythonShell();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_HasResourceInspector(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_HasResourceInspector",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_HasResourceInspector" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (bool)(arg1)->HasResourceInspector();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowEventBrowser(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowEventBrowser",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowEventBrowser" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowEventBrowser();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowAPIInspector(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowAPIInspector",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowAPIInspector" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowAPIInspector();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowTextureViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowTextureViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowTextureViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowTextureViewer();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowMeshPreview(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowMeshPreview",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowMeshPreview" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowMeshPreview();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowPipelineViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowPipelineViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowPipelineViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowPipelineViewer();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowCaptureDialog(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowCaptureDialog",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowCaptureDialog" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowCaptureDialog();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowDebugMessageView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowDebugMessageView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowDebugMessageView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowDebugMessageView();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowDiagnosticLogView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowDiagnosticLogView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowDiagnosticLogView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowDiagnosticLogView();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowCommentView(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowCommentView",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowCommentView" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowCommentView();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowPerformanceCounterViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowPerformanceCounterViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowPerformanceCounterViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowPerformanceCounterViewer();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowStatisticsViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowStatisticsViewer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowStatisticsViewer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowStatisticsViewer();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowTimelineBar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowTimelineBar",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowTimelineBar" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowTimelineBar();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowPythonShell(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowPythonShell",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowPythonShell" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowPythonShell();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ShowResourceInspector(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ShowResourceInspector",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ShowResourceInspector" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  (arg1)->ShowResourceInspector();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_EditShader(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  ShaderStage arg3 ;
  rdcstr *arg4 = 0 ;
  rdcstrpairs *arg5 = 0 ;
  KnownShaderTool arg6 ;
  ShaderEncoding arg7 ;
  ShaderCompileFlags arg8 ;
  SwigValueWrapper< std::function< void (ICaptureContext *,IShaderViewer *,ResourceId,ShaderStage,ShaderEncoding,ShaderCompileFlags,rdcstr,bytebuf) > > arg9 ;
  SwigValueWrapper< std::function< void (ICaptureContext *,IShaderViewer *,ResourceId) > > arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  rdcstr temp4 ;
  unsigned char tempmem5[32] ;
  bool wasSelf5 = false ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  void *argp8 ;
  int res8 = 0 ;
  StackExceptionHandler exHandle9 ;
  StackExceptionHandler exHandle10 ;
  PyObject *swig_obj[10] ;
  IShaderViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_EditShader",9,9,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_EditShader" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_EditShader" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_EditShader" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_EditShader" "', argument " "3"" of type '" "ShaderStage""'");
  } 
  arg3 = static_cast< ShaderStage >(val3);
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_EditShader' argument 4 of type 'rdcstr'"); 
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg5)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem5) >= sizeof(array_type), "not enough temp space for rdcstrpairs");
      
      tempalloc(arg5, tempmem5);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[3], indirect(arg5), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_EditShader' argument 5 of type 'rdcstrpairs'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureContext_EditShader' argument 5 of type 'rdcstrpairs', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "CaptureContext_EditShader" "', argument " "6"" of type '" "KnownShaderTool""'");
  } 
  arg6 = static_cast< KnownShaderTool >(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "CaptureContext_EditShader" "', argument " "7"" of type '" "ShaderEncoding""'");
  } 
  arg7 = static_cast< ShaderEncoding >(val7);
  {
    res8 = SWIG_ConvertPtr(swig_obj[6], &argp8, SWIGTYPE_p_ShaderCompileFlags,  0  | 0);
    if (!SWIG_IsOK(res8)) {
      SWIG_exception_fail(SWIG_ArgError(res8), "in method '" "CaptureContext_EditShader" "', argument " "8"" of type '" "ShaderCompileFlags""'"); 
    }  
    if (!argp8) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_EditShader" "', argument " "8"" of type '" "ShaderCompileFlags""'");
    } else {
      ShaderCompileFlags * temp = reinterpret_cast< ShaderCompileFlags * >(argp8);
      arg8 = *temp;
      if (SWIG_IsNewObj(res8)) delete temp;
    }
  }
  {
    PyObject *func = swig_obj[7];
    arg9 = ConvertFunc<IShaderViewer::SaveCallback>("CaptureContext_EditShader", func, exHandle9);
  }
  {
    PyObject *func = swig_obj[8];
    arg10 = ConvertFunc<IShaderViewer::RevertCallback>("CaptureContext_EditShader", func, exHandle10);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg5); 
  }
  result = (IShaderViewer *)(arg1)->EditShader(arg2,arg3,(rdcstr const &)*arg4,(rdcstrpairs const &)*arg5,arg6,arg7,arg8,arg9,arg10);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IShaderViewer, 0 |  0 );
  {
    if(exHandle9.data().failFlag) {
      PyErr_Restore(exHandle9.data().exObj, exHandle9.data().valueObj, exHandle9.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    if(exHandle10.data().failFlag) {
      PyErr_Restore(exHandle10.data().exObj, exHandle10.data().valueObj, exHandle10.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_DebugShader(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ShaderReflection *arg2 = (ShaderReflection *) 0 ;
  ResourceId arg3 ;
  ShaderDebugTrace *arg4 = (ShaderDebugTrace *) 0 ;
  rdcstr *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  rdcstr temp5 ;
  PyObject *swig_obj[5] ;
  IShaderViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_DebugShader",4,4,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_DebugShader" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ShaderReflection, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_DebugShader" "', argument " "2"" of type '" "ShaderReflection const *""'"); 
  }
  arg2 = reinterpret_cast< ShaderReflection * >(argp2);
  {
    res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaptureContext_DebugShader" "', argument " "3"" of type '" "ResourceId""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_DebugShader" "', argument " "3"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  res4 = SWIG_ConvertPtr(swig_obj[2], &argp4,SWIGTYPE_p_ShaderDebugTrace, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CaptureContext_DebugShader" "', argument " "4"" of type '" "ShaderDebugTrace *""'"); 
  }
  arg4 = reinterpret_cast< ShaderDebugTrace * >(argp4);
  {
    tempset(arg5, &temp5);
    
    int res = ConvertFromPy(swig_obj[3], indirect(arg5));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_DebugShader' argument 5 of type 'rdcstr'"); 
    }
  }
  result = (IShaderViewer *)(arg1)->DebugShader((ShaderReflection const *)arg2,arg3,arg4,(rdcstr const &)*arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IShaderViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewShader(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ShaderReflection *arg2 = (ShaderReflection *) 0 ;
  ResourceId arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  IShaderViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ViewShader",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewShader" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ShaderReflection, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ViewShader" "', argument " "2"" of type '" "ShaderReflection const *""'"); 
  }
  arg2 = reinterpret_cast< ShaderReflection * >(argp2);
  {
    res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res3)) {
      SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaptureContext_ViewShader" "', argument " "3"" of type '" "ResourceId""'"); 
    }  
    if (!argp3) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewShader" "', argument " "3"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp3);
      arg3 = *temp;
      if (SWIG_IsNewObj(res3)) delete temp;
    }
  }
  result = (IShaderViewer *)(arg1)->ViewShader((ShaderReflection const *)arg2,arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IShaderViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewShaderMessages(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ShaderStageMask arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  IShaderMessageViewer *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewShaderMessages" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_ViewShaderMessages" "', argument " "2"" of type '" "ShaderStageMask""'");
  } 
  arg2 = static_cast< ShaderStageMask >(val2);
  result = (IShaderMessageViewer *)(arg1)->ViewShaderMessages(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IShaderMessageViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewDescriptorStore(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  IDescriptorViewer *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewDescriptorStore" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ViewDescriptorStore" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewDescriptorStore" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  result = (IDescriptorViewer *)(arg1)->ViewDescriptorStore(arg2);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IDescriptorViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewDescriptors(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcarray< Descriptor > *arg2 = 0 ;
  rdcarray< SamplerDescriptor > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  PyObject *swig_obj[3] ;
  IDescriptorViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ViewDescriptors",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewDescriptors" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< Descriptor >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ViewDescriptors' argument 2 of type 'rdcarray< Descriptor >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureContext_ViewDescriptors' argument 2 of type 'rdcarray< Descriptor >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< SamplerDescriptor >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ViewDescriptors' argument 3 of type 'rdcarray< SamplerDescriptor >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'CaptureContext_ViewDescriptors' argument 3 of type 'rdcarray< SamplerDescriptor >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  result = (IDescriptorViewer *)(arg1)->ViewDescriptors((rdcarray< Descriptor > const &)*arg2,(rdcarray< SamplerDescriptor > const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IDescriptorViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewBuffer__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  uint64_t arg2 ;
  uint64_t arg3 ;
  ResourceId arg4 ;
  rdcstr *arg5 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  rdcstr temp5 ;
  IBufferViewer *result = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewBuffer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_ViewBuffer" "', argument " "2"" of type '" "uint64_t""'");
  } 
  arg2 = static_cast< uint64_t >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_ViewBuffer" "', argument " "3"" of type '" "uint64_t""'");
  } 
  arg3 = static_cast< uint64_t >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CaptureContext_ViewBuffer" "', argument " "4"" of type '" "ResourceId""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewBuffer" "', argument " "4"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  {
    tempset(arg5, &temp5);
    
    int res = ConvertFromPy(swig_obj[4], indirect(arg5));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ViewBuffer' argument 5 of type 'rdcstr'"); 
    }
  }
  result = (IBufferViewer *)(arg1)->ViewBuffer(arg2,arg3,arg4,(rdcstr const &)*arg5);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IBufferViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewBuffer__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  uint64_t arg2 ;
  uint64_t arg3 ;
  ResourceId arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned long long val2 ;
  int ecode2 = 0 ;
  unsigned long long val3 ;
  int ecode3 = 0 ;
  void *argp4 ;
  int res4 = 0 ;
  IBufferViewer *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewBuffer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_unsigned_SS_long_SS_long(swig_obj[1], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_ViewBuffer" "', argument " "2"" of type '" "uint64_t""'");
  } 
  arg2 = static_cast< uint64_t >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_long_SS_long(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_ViewBuffer" "', argument " "3"" of type '" "uint64_t""'");
  } 
  arg3 = static_cast< uint64_t >(val3);
  {
    res4 = SWIG_ConvertPtr(swig_obj[3], &argp4, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res4)) {
      SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "CaptureContext_ViewBuffer" "', argument " "4"" of type '" "ResourceId""'"); 
    }  
    if (!argp4) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewBuffer" "', argument " "4"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp4);
      arg4 = *temp;
      if (SWIG_IsNewObj(res4)) delete temp;
    }
  }
  result = (IBufferViewer *)(arg1)->ViewBuffer(arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IBufferViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewBuffer(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"CaptureContext_ViewBuffer",0,5,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 4) {
    return _wrap_CaptureContext_ViewBuffer__SWIG_1(self, argc, argv);
  }
  if (argc == 5) {
    return _wrap_CaptureContext_ViewBuffer__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'CaptureContext_ViewBuffer'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ICaptureContext::ViewBuffer(uint64_t,uint64_t,ResourceId,rdcstr const &)\n"
    "    ICaptureContext::ViewBuffer(uint64_t,uint64_t,ResourceId)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewTextureAsBuffer__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  Subresource *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  rdcstr temp4 ;
  IBufferViewer *result = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_Subresource,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "3"" of type '" "Subresource const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "3"" of type '" "Subresource const &""'"); 
  }
  arg3 = reinterpret_cast< Subresource * >(argp3);
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[3], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_ViewTextureAsBuffer' argument 4 of type 'rdcstr'"); 
    }
  }
  result = (IBufferViewer *)(arg1)->ViewTextureAsBuffer(arg2,(Subresource const &)*arg3,(rdcstr const &)*arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IBufferViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewTextureAsBuffer__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  Subresource *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  IBufferViewer *result = 0 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[1], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[2], &argp3, SWIGTYPE_p_Subresource,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "3"" of type '" "Subresource const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewTextureAsBuffer" "', argument " "3"" of type '" "Subresource const &""'"); 
  }
  arg3 = reinterpret_cast< Subresource * >(argp3);
  result = (IBufferViewer *)(arg1)->ViewTextureAsBuffer(arg2,(Subresource const &)*arg3);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IBufferViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewTextureAsBuffer(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"CaptureContext_ViewTextureAsBuffer",0,4,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 3) {
    return _wrap_CaptureContext_ViewTextureAsBuffer__SWIG_1(self, argc, argv);
  }
  if (argc == 4) {
    return _wrap_CaptureContext_ViewTextureAsBuffer__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'CaptureContext_ViewTextureAsBuffer'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ICaptureContext::ViewTextureAsBuffer(ResourceId,Subresource const &,rdcstr const &)\n"
    "    ICaptureContext::ViewTextureAsBuffer(ResourceId,Subresource const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewConstantBuffer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ShaderStage arg2 ;
  uint32_t arg3 ;
  uint32_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  IBufferViewer *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ViewConstantBuffer",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewConstantBuffer" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "CaptureContext_ViewConstantBuffer" "', argument " "2"" of type '" "ShaderStage""'");
  } 
  arg2 = static_cast< ShaderStage >(val2);
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_ViewConstantBuffer" "', argument " "3"" of type '" "uint32_t""'");
  } 
  arg3 = static_cast< uint32_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CaptureContext_ViewConstantBuffer" "', argument " "4"" of type '" "uint32_t""'");
  } 
  arg4 = static_cast< uint32_t >(val4);
  result = (IBufferViewer *)(arg1)->ViewConstantBuffer(arg2,arg3,arg4);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IBufferViewer, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_ViewPixelHistory(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  ResourceId arg2 ;
  uint32_t arg3 ;
  uint32_t arg4 ;
  uint32_t arg5 ;
  TextureDisplay *arg6 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  unsigned int val3 ;
  int ecode3 = 0 ;
  unsigned int val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  PyObject *swig_obj[6] ;
  IPixelHistoryView *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_ViewPixelHistory",5,5,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_ViewPixelHistory" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ResourceId,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "CaptureContext_ViewPixelHistory" "', argument " "2"" of type '" "ResourceId""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewPixelHistory" "', argument " "2"" of type '" "ResourceId""'");
    } else {
      ResourceId * temp = reinterpret_cast< ResourceId * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  ecode3 = SWIG_AsVal_unsigned_SS_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_ViewPixelHistory" "', argument " "3"" of type '" "uint32_t""'");
  } 
  arg3 = static_cast< uint32_t >(val3);
  ecode4 = SWIG_AsVal_unsigned_SS_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "CaptureContext_ViewPixelHistory" "', argument " "4"" of type '" "uint32_t""'");
  } 
  arg4 = static_cast< uint32_t >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "CaptureContext_ViewPixelHistory" "', argument " "5"" of type '" "uint32_t""'");
  } 
  arg5 = static_cast< uint32_t >(val5);
  res6 = SWIG_ConvertPtr(swig_obj[4], &argp6, SWIGTYPE_p_TextureDisplay,  0  | 0);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "CaptureContext_ViewPixelHistory" "', argument " "6"" of type '" "TextureDisplay const &""'"); 
  }
  if (!argp6) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "CaptureContext_ViewPixelHistory" "', argument " "6"" of type '" "TextureDisplay const &""'"); 
  }
  arg6 = reinterpret_cast< TextureDisplay * >(argp6);
  result = (IPixelHistoryView *)(arg1)->ViewPixelHistory(arg2,arg3,arg4,arg5,(TextureDisplay const &)*arg6);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IPixelHistoryView, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CreateBuiltinWindow(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CreateBuiltinWindow" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'CaptureContext_CreateBuiltinWindow' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (QWidget *)(arg1)->CreateBuiltinWindow((rdcstr const &)*arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_BuiltinWindowClosed(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_BuiltinWindowClosed" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_BuiltinWindowClosed' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  (arg1)->BuiltinWindowClosed(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_RaiseDockWindow(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_RaiseDockWindow" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_RaiseDockWindow' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  (arg1)->RaiseDockWindow(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_AddDockWindow__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  DockReference arg3 ;
  QWidget *arg4 = (QWidget *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if ((nobjs < 5) || (nobjs > 5)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_AddDockWindow" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    if(Py_IsNone(swig_obj[1]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[1]);
    if(swig_obj[1] && !Py_IsNone(swig_obj[1]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_AddDockWindow' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_AddDockWindow" "', argument " "3"" of type '" "DockReference""'");
  } 
  arg3 = static_cast< DockReference >(val3);
  {
    if(Py_IsNone(swig_obj[3]))
    arg4 = NULL;
    else
    arg4 = QWidgetFromPy(swig_obj[3]);
    if(swig_obj[3] && !Py_IsNone(swig_obj[3]) && !arg4)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_AddDockWindow' QWidget expected for argument 4 of type 'QWidget'");
    }
  }
  ecode5 = SWIG_AsVal_float(swig_obj[4], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "CaptureContext_AddDockWindow" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  (arg1)->AddDockWindow(arg2,arg3,arg4,arg5);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_AddDockWindow__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  DockReference arg3 ;
  QWidget *arg4 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_AddDockWindow" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  {
    if(Py_IsNone(swig_obj[1]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[1]);
    if(swig_obj[1] && !Py_IsNone(swig_obj[1]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_AddDockWindow' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[2], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "CaptureContext_AddDockWindow" "', argument " "3"" of type '" "DockReference""'");
  } 
  arg3 = static_cast< DockReference >(val3);
  {
    if(Py_IsNone(swig_obj[3]))
    arg4 = NULL;
    else
    arg4 = QWidgetFromPy(swig_obj[3]);
    if(swig_obj[3] && !Py_IsNone(swig_obj[3]) && !arg4)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'CaptureContext_AddDockWindow' QWidget expected for argument 4 of type 'QWidget'");
    }
  }
  (arg1)->AddDockWindow(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_AddDockWindow(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[6] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"CaptureContext_AddDockWindow",0,5,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 4) {
    return _wrap_CaptureContext_AddDockWindow__SWIG_1(self, argc, argv);
  }
  if (argc == 5) {
    return _wrap_CaptureContext_AddDockWindow__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'CaptureContext_AddDockWindow'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    ICaptureContext::AddDockWindow(QWidget *,DockReference,QWidget *,float)\n"
    "    ICaptureContext::AddDockWindow(QWidget *,DockReference,QWidget *)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurD3D11PipelineState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  D3D11Pipe::State *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurD3D11PipelineState",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurD3D11PipelineState" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (D3D11Pipe::State *)(arg1)->CurD3D11PipelineState();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_D3D11Pipe__State, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurD3D12PipelineState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  D3D12Pipe::State *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurD3D12PipelineState",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurD3D12PipelineState" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (D3D12Pipe::State *)(arg1)->CurD3D12PipelineState();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_D3D12Pipe__State, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurGLPipelineState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  GLPipe::State *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurGLPipelineState",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurGLPipelineState" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (GLPipe::State *)(arg1)->CurGLPipelineState();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_GLPipe__State, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurVulkanPipelineState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  VKPipe::State *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurVulkanPipelineState",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurVulkanPipelineState" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (VKPipe::State *)(arg1)->CurVulkanPipelineState();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_VKPipe__State, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_CurPipelineState(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PipeState *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_CurPipelineState",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_CurPipelineState" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (PipeState *) &(arg1)->CurPipelineState();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PipeState, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_Config(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  PersistantConfig *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_Config",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_Config" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (PersistantConfig *) &(arg1)->Config();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PersistantConfig, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_CaptureContext_Extensions(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ICaptureContext *arg1 = (ICaptureContext *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IExtensionManager *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"CaptureContext_Extensions",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ICaptureContext, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CaptureContext_Extensions" "', argument " "1"" of type '" "ICaptureContext *""'"); 
  }
  arg1 = reinterpret_cast< ICaptureContext * >(argp1);
  result = (IExtensionManager *) &(arg1)->Extensions();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IExtensionManager, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ConfigFilePath(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcstr *arg1 = 0 ;
  rdcstr temp1 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    tempset(arg1, &temp1);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg1));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ConfigFilePath' argument 1 of type 'rdcstr'"); 
    }
  }
  result = ConfigFilePath((rdcstr const &)*arg1);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderToolOutput_log_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderToolOutput *arg1 = (ShaderToolOutput *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderToolOutput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderToolOutput_log_set" "', argument " "1"" of type '" "ShaderToolOutput *""'"); 
  }
  arg1 = reinterpret_cast< ShaderToolOutput * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderToolOutput_log_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->log = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderToolOutput_log_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderToolOutput *arg1 = (ShaderToolOutput *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderToolOutput_log_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderToolOutput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderToolOutput_log_get" "', argument " "1"" of type '" "ShaderToolOutput *""'"); 
  }
  arg1 = reinterpret_cast< ShaderToolOutput * >(argp1);
  result =  ((arg1)->log);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderToolOutput_result_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderToolOutput *arg1 = (ShaderToolOutput *) 0 ;
  bytebuf *arg2 = (bytebuf *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bytebuf temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderToolOutput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderToolOutput_result_set" "', argument " "1"" of type '" "ShaderToolOutput *""'"); 
  }
  arg1 = reinterpret_cast< ShaderToolOutput * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderToolOutput_result_set' argument 2 of type 'bytebuf'"); 
    }
  }
  if (arg1) (arg1)->result = *arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderToolOutput_result_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderToolOutput *arg1 = (ShaderToolOutput *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bytebuf *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderToolOutput_result_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderToolOutput, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderToolOutput_result_get" "', argument " "1"" of type '" "ShaderToolOutput *""'"); 
  }
  arg1 = reinterpret_cast< ShaderToolOutput * >(argp1);
  result = (bytebuf *)& ((arg1)->result);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_ShaderToolOutput(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderToolOutput *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_ShaderToolOutput",0,0,0)) SWIG_fail;
  result = (ShaderToolOutput *)new ShaderToolOutput();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ShaderToolOutput, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_ShaderToolOutput(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderToolOutput *arg1 = (ShaderToolOutput *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_ShaderToolOutput",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderToolOutput, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ShaderToolOutput" "', argument " "1"" of type '" "ShaderToolOutput *""'"); 
  }
  arg1 = reinterpret_cast< ShaderToolOutput * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ShaderToolOutput) /* defines _wrap_delete_ShaderToolOutput_destructor_closure */

SWIGINTERN int _wrap_new_ShaderProcessingTool(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_ShaderProcessingTool",0,0,0)) SWIG_fail;
  result = (ShaderProcessingTool *)new ShaderProcessingTool();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ShaderProcessingTool, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  ShaderProcessingTool *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool___eq__" "', argument " "1"" of type '" "ShaderProcessingTool const *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ShaderProcessingTool,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ShaderProcessingTool___eq__" "', argument " "2"" of type '" "ShaderProcessingTool const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ShaderProcessingTool___eq__" "', argument " "2"" of type '" "ShaderProcessingTool const &""'"); 
  }
  arg2 = reinterpret_cast< ShaderProcessingTool * >(argp2);
  result = (bool)((ShaderProcessingTool const *)arg1)->operator ==((ShaderProcessingTool const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  ShaderProcessingTool *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool___lt__" "', argument " "1"" of type '" "ShaderProcessingTool const *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ShaderProcessingTool,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ShaderProcessingTool___lt__" "', argument " "2"" of type '" "ShaderProcessingTool const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ShaderProcessingTool___lt__" "', argument " "2"" of type '" "ShaderProcessingTool const &""'"); 
  }
  arg2 = reinterpret_cast< ShaderProcessingTool * >(argp2);
  result = (bool)((ShaderProcessingTool const *)arg1)->operator <((ShaderProcessingTool const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_tool_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  KnownShaderTool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_tool_set" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ShaderProcessingTool_tool_set" "', argument " "2"" of type '" "KnownShaderTool""'");
  } 
  arg2 = static_cast< KnownShaderTool >(val2);
  if (arg1) (arg1)->tool = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_tool_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  KnownShaderTool result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_tool_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_tool_get" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result = (KnownShaderTool) ((arg1)->tool);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_KnownShaderTool->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_name_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_name_set" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_name_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->name = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_name_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_name_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_name_get" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result =  ((arg1)->name);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_executable_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_executable_set" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_executable_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->executable = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_executable_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_executable_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_executable_get" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result =  ((arg1)->executable);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_args_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_args_set" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_args_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->args = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_args_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_args_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_args_get" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result =  ((arg1)->args);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_input_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  ShaderEncoding arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_input_set" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ShaderProcessingTool_input_set" "', argument " "2"" of type '" "ShaderEncoding""'");
  } 
  arg2 = static_cast< ShaderEncoding >(val2);
  if (arg1) (arg1)->input = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_input_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ShaderEncoding result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_input_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_input_get" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result = (ShaderEncoding) ((arg1)->input);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_ShaderEncoding->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_output_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  ShaderEncoding arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_output_set" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ShaderProcessingTool_output_set" "', argument " "2"" of type '" "ShaderEncoding""'");
  } 
  arg2 = static_cast< ShaderEncoding >(val2);
  if (arg1) (arg1)->output = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_output_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ShaderEncoding result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_output_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_output_get" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result = (ShaderEncoding) ((arg1)->output);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_ShaderEncoding->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_DefaultArguments(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_DefaultArguments",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_DefaultArguments" "', argument " "1"" of type '" "ShaderProcessingTool const *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  result = ((ShaderProcessingTool const *)arg1)->DefaultArguments();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_DisassembleShader(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  ShaderReflection *arg3 = (ShaderReflection *) 0 ;
  rdcstr arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  rdcstr temp4 ;
  PyObject *swig_obj[4] ;
  ShaderToolOutput result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_DisassembleShader",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_DisassembleShader" "', argument " "1"" of type '" "ShaderProcessingTool const *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'ShaderProcessingTool_DisassembleShader' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3,SWIGTYPE_p_ShaderReflection, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "ShaderProcessingTool_DisassembleShader" "', argument " "3"" of type '" "ShaderReflection const *""'"); 
  }
  arg3 = reinterpret_cast< ShaderReflection * >(argp3);
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_DisassembleShader' argument 4 of type 'rdcstr'"); 
    }
  }
  result = ((ShaderProcessingTool const *)arg1)->DisassembleShader(arg2,(ShaderReflection const *)arg3,arg4);
  resultobj = SWIG_NewPointerObj((new ShaderToolOutput(static_cast< const ShaderToolOutput& >(result))), SWIGTYPE_p_ShaderToolOutput, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ShaderProcessingTool_CompileShader(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcstr arg3 ;
  rdcstr arg4 ;
  ShaderStage arg5 ;
  rdcstr arg6 ;
  rdcstr arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp3 ;
  rdcstr temp4 ;
  int val5 ;
  int ecode5 = 0 ;
  rdcstr temp6 ;
  rdcstr temp7 ;
  PyObject *swig_obj[7] ;
  ShaderToolOutput result;
  
  if (!SWIG_Python_UnpackTuple(args,"ShaderProcessingTool_CompileShader",6,6,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ShaderProcessingTool_CompileShader" "', argument " "1"" of type '" "ShaderProcessingTool const *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'ShaderProcessingTool_CompileShader' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_CompileShader' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_CompileShader' argument 4 of type 'rdcstr'"); 
    }
  }
  ecode5 = SWIG_AsVal_int(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "ShaderProcessingTool_CompileShader" "', argument " "5"" of type '" "ShaderStage""'");
  } 
  arg5 = static_cast< ShaderStage >(val5);
  {
    tempset(arg6, &temp6);
    
    int res = ConvertFromPy(swig_obj[4], indirect(arg6));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_CompileShader' argument 6 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg7, &temp7);
    
    int res = ConvertFromPy(swig_obj[5], indirect(arg7));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ShaderProcessingTool_CompileShader' argument 7 of type 'rdcstr'"); 
    }
  }
  result = ((ShaderProcessingTool const *)arg1)->CompileShader(arg2,arg3,arg4,arg5,arg6,arg7);
  resultobj = SWIG_NewPointerObj((new ShaderToolOutput(static_cast< const ShaderToolOutput& >(result))), SWIGTYPE_p_ShaderToolOutput, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_ShaderProcessingTool(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ShaderProcessingTool *arg1 = (ShaderProcessingTool *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_ShaderProcessingTool",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ShaderProcessingTool, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ShaderProcessingTool" "', argument " "1"" of type '" "ShaderProcessingTool *""'"); 
  }
  arg1 = reinterpret_cast< ShaderProcessingTool * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ShaderProcessingTool) /* defines _wrap_delete_ShaderProcessingTool_destructor_closure */

SWIGINTERN int _wrap_new_BugReport(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_BugReport",0,0,0)) SWIG_fail;
  result = (BugReport *)new BugReport();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_BugReport, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_BugReport___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  BugReport *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport___eq__" "', argument " "1"" of type '" "BugReport const *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_BugReport,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BugReport___eq__" "', argument " "2"" of type '" "BugReport const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BugReport___eq__" "', argument " "2"" of type '" "BugReport const &""'"); 
  }
  arg2 = reinterpret_cast< BugReport * >(argp2);
  result = (bool)((BugReport const *)arg1)->operator ==((BugReport const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  BugReport *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport___lt__" "', argument " "1"" of type '" "BugReport const *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_BugReport,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "BugReport___lt__" "', argument " "2"" of type '" "BugReport const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "BugReport___lt__" "', argument " "2"" of type '" "BugReport const &""'"); 
  }
  arg2 = reinterpret_cast< BugReport * >(argp2);
  result = (bool)((BugReport const *)arg1)->operator <((BugReport const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_reportId_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_reportId_set" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'BugReport_reportId_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->reportId = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_reportId_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"BugReport_reportId_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_reportId_get" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  result =  ((arg1)->reportId);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_submitDate_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  rdcdatetime arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcdatetime temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_submitDate_set" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'BugReport_submitDate_set' argument 2 of type 'rdcdatetime'"); 
    }
  }
  if (arg1) (arg1)->submitDate = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_submitDate_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcdatetime result;
  
  if (!SWIG_Python_UnpackTuple(args,"BugReport_submitDate_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_submitDate_get" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  result =  ((arg1)->submitDate);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_checkDate_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  rdcdatetime arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcdatetime temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_checkDate_set" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'BugReport_checkDate_set' argument 2 of type 'rdcdatetime'"); 
    }
  }
  if (arg1) (arg1)->checkDate = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_checkDate_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcdatetime result;
  
  if (!SWIG_Python_UnpackTuple(args,"BugReport_checkDate_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_checkDate_get" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  result =  ((arg1)->checkDate);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_unreadUpdates_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_unreadUpdates_set" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "BugReport_unreadUpdates_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->unreadUpdates = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_unreadUpdates_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"BugReport_unreadUpdates_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_unreadUpdates_get" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  result = (bool) ((arg1)->unreadUpdates);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_BugReport_URL(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"BugReport_URL",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "BugReport_URL" "', argument " "1"" of type '" "BugReport const *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  result = ((BugReport const *)arg1)->URL();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_delete_BugReport(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  BugReport *arg1 = (BugReport *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_BugReport",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_BugReport, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_BugReport" "', argument " "1"" of type '" "BugReport *""'"); 
  }
  arg1 = reinterpret_cast< BugReport * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_BugReport) /* defines _wrap_delete_BugReport_destructor_closure */

SWIGINTERN int _wrap_new_OffsetSizeDisplayMode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  OffsetSizeDisplayMode *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_OffsetSizeDisplayMode",0,0,0)) SWIG_fail;
  result = (OffsetSizeDisplayMode *)new OffsetSizeDisplayMode();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_OffsetSizeDisplayMode, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_OffsetSizeDisplayMode(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  OffsetSizeDisplayMode *arg1 = (OffsetSizeDisplayMode *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_OffsetSizeDisplayMode",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_OffsetSizeDisplayMode, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_OffsetSizeDisplayMode" "', argument " "1"" of type '" "OffsetSizeDisplayMode *""'"); 
  }
  arg1 = reinterpret_cast< OffsetSizeDisplayMode * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_OffsetSizeDisplayMode) /* defines _wrap_delete_OffsetSizeDisplayMode_destructor_closure */

SWIGINTERN int _wrap_new_TimeUnit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TimeUnit *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_TimeUnit",0,0,0)) SWIG_fail;
  result = (TimeUnit *)new TimeUnit();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_TimeUnit, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_TimeUnit(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TimeUnit *arg1 = (TimeUnit *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_TimeUnit",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_TimeUnit, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_TimeUnit" "', argument " "1"" of type '" "TimeUnit *""'"); 
  }
  arg1 = reinterpret_cast< TimeUnit * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_TimeUnit) /* defines _wrap_delete_TimeUnit_destructor_closure */

SWIGINTERN PyObject *_wrap_UnitSuffix(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  TimeUnit arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  ecode1 = SWIG_AsVal_int(swig_obj[0], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "UnitSuffix" "', argument " "1"" of type '" "TimeUnit""'");
  } 
  arg1 = static_cast< TimeUnit >(val1);
  result = UnitSuffix(arg1);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_AddRecentFile(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstr > *arg1 = 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args,"AddRecentFile",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_rdcarrayT_rdcstr_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "AddRecentFile" "', argument " "1"" of type '" "rdcarray< rdcstr > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "AddRecentFile" "', argument " "1"" of type '" "rdcarray< rdcstr > &""'"); 
  }
  arg1 = reinterpret_cast< rdcarray< rdcstr > * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'AddRecentFile' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  AddRecentFile(*arg1,(rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoveRecentFile(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstr > *arg1 = 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoveRecentFile",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_rdcarrayT_rdcstr_t,  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoveRecentFile" "', argument " "1"" of type '" "rdcarray< rdcstr > &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RemoveRecentFile" "', argument " "1"" of type '" "rdcarray< rdcstr > &""'"); 
  }
  arg1 = reinterpret_cast< rdcarray< rdcstr > * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'RemoveRecentFile' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  RemoveRecentFile(*arg1,(rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_GetRemoteHosts(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< RemoteHost > result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_GetRemoteHosts",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_GetRemoteHosts" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (arg1)->GetRemoteHosts();
  resultobj = SWIG_NewPointerObj((new rdcarray< RemoteHost >(static_cast< const rdcarray< RemoteHost >& >(result))), SWIGTYPE_p_rdcarrayT_RemoteHost_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_GetRemoteHost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  RemoteHost result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_GetRemoteHost" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_GetRemoteHost' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->GetRemoteHost((rdcstr const &)*arg2);
  resultobj = SWIG_NewPointerObj((new RemoteHost(static_cast< const RemoteHost& >(result))), SWIGTYPE_p_RemoteHost, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AddRemoteHost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  RemoteHost arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AddRemoteHost" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PersistantConfig_AddRemoteHost" "', argument " "2"" of type '" "RemoteHost""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PersistantConfig_AddRemoteHost" "', argument " "2"" of type '" "RemoteHost""'");
    } else {
      RemoteHost * temp = reinterpret_cast< RemoteHost * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->AddRemoteHost(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_RemoveRemoteHost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  RemoteHost arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_RemoveRemoteHost" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
    if (!SWIG_IsOK(res2)) {
      SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PersistantConfig_RemoveRemoteHost" "', argument " "2"" of type '" "RemoteHost""'"); 
    }  
    if (!argp2) {
      SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "PersistantConfig_RemoveRemoteHost" "', argument " "2"" of type '" "RemoteHost""'");
    } else {
      RemoteHost * temp = reinterpret_cast< RemoteHost * >(argp2);
      arg2 = *temp;
      if (SWIG_IsNewObj(res2)) delete temp;
    }
  }
  (arg1)->RemoveRemoteHost(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_UpdateEnumeratedProtocolDevices(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_UpdateEnumeratedProtocolDevices",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_UpdateEnumeratedProtocolDevices" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  (arg1)->UpdateEnumeratedProtocolDevices();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_UIStyle_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_UIStyle_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_UIStyle_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->UIStyle = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_UIStyle_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_UIStyle_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_UIStyle_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->UIStyle);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastCaptureFilePath_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastCaptureFilePath_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_LastCaptureFilePath_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->LastCaptureFilePath = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastCaptureFilePath_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_LastCaptureFilePath_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastCaptureFilePath_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->LastCaptureFilePath);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastFileBrowsePath_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastFileBrowsePath_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_LastFileBrowsePath_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->LastFileBrowsePath = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastFileBrowsePath_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_LastFileBrowsePath_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastFileBrowsePath_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->LastFileBrowsePath);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_RecentCaptureFiles_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< rdcstr > *arg2 = (rdcarray< rdcstr > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_RecentCaptureFiles_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_RecentCaptureFiles_set' argument 2 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_RecentCaptureFiles_set' argument 2 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->RecentCaptureFiles = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_RecentCaptureFiles_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< rdcstr > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_RecentCaptureFiles_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_RecentCaptureFiles_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< rdcstr > *)& ((arg1)->RecentCaptureFiles);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_rdcstr_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastCapturePath_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastCapturePath_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_LastCapturePath_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->LastCapturePath = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastCapturePath_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_LastCapturePath_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastCapturePath_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->LastCapturePath);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastCaptureExe_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastCaptureExe_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_LastCaptureExe_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->LastCaptureExe = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LastCaptureExe_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_LastCaptureExe_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LastCaptureExe_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->LastCaptureExe);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_RecentCaptureSettings_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< rdcstr > *arg2 = (rdcarray< rdcstr > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_RecentCaptureSettings_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_RecentCaptureSettings_set' argument 2 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_RecentCaptureSettings_set' argument 2 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->RecentCaptureSettings = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_RecentCaptureSettings_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< rdcstr > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_RecentCaptureSettings_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_RecentCaptureSettings_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< rdcstr > *)& ((arg1)->RecentCaptureSettings);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_rdcstr_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TemporaryCaptureDirectory_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TemporaryCaptureDirectory_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_TemporaryCaptureDirectory_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->TemporaryCaptureDirectory = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TemporaryCaptureDirectory_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_TemporaryCaptureDirectory_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TemporaryCaptureDirectory_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->TemporaryCaptureDirectory);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_DefaultCaptureSaveDirectory_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_DefaultCaptureSaveDirectory_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_DefaultCaptureSaveDirectory_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->DefaultCaptureSaveDirectory = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_DefaultCaptureSaveDirectory_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_DefaultCaptureSaveDirectory_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_DefaultCaptureSaveDirectory_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->DefaultCaptureSaveDirectory);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_DefaultReplayOptions_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  ReplayOptions *arg2 = (ReplayOptions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_DefaultReplayOptions_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_ReplayOptions, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "PersistantConfig_DefaultReplayOptions_set" "', argument " "2"" of type '" "ReplayOptions *""'"); 
  }
  arg2 = reinterpret_cast< ReplayOptions * >(argp2);
  if (arg1) (arg1)->DefaultReplayOptions = *arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_DefaultReplayOptions_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ReplayOptions *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_DefaultReplayOptions_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_DefaultReplayOptions_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (ReplayOptions *)& ((arg1)->DefaultReplayOptions);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ReplayOptions, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_ResetRange_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_ResetRange_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_TextureViewer_ResetRange_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->TextureViewer_ResetRange = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_ResetRange_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_TextureViewer_ResetRange_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_ResetRange_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->TextureViewer_ResetRange);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_PerTexSettings_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_PerTexSettings_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_TextureViewer_PerTexSettings_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->TextureViewer_PerTexSettings = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_PerTexSettings_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_TextureViewer_PerTexSettings_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_PerTexSettings_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->TextureViewer_PerTexSettings);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_PerTexYFlip_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_PerTexYFlip_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_TextureViewer_PerTexYFlip_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->TextureViewer_PerTexYFlip = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_PerTexYFlip_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_TextureViewer_PerTexYFlip_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_PerTexYFlip_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->TextureViewer_PerTexYFlip);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_ShaderDirs_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< rdcstr > *arg2 = (rdcarray< rdcstr > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_ShaderDirs_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_TextureViewer_ShaderDirs_set' argument 2 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_TextureViewer_ShaderDirs_set' argument 2 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->TextureViewer_ShaderDirs = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_TextureViewer_ShaderDirs_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< rdcstr > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_TextureViewer_ShaderDirs_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_TextureViewer_ShaderDirs_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< rdcstr > *)& ((arg1)->TextureViewer_ShaderDirs);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_rdcstr_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AlwaysReplayLocally_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AlwaysReplayLocally_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_AlwaysReplayLocally_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->AlwaysReplayLocally = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AlwaysReplayLocally_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_AlwaysReplayLocally_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AlwaysReplayLocally_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->AlwaysReplayLocally);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LocalProxyAPI_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LocalProxyAPI_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_LocalProxyAPI_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->LocalProxyAPI = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_LocalProxyAPI_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_LocalProxyAPI_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_LocalProxyAPI_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (int) ((arg1)->LocalProxyAPI);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_BufferFormatter_SavedFormats_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< rdcstr > *arg2 = (rdcarray< rdcstr > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_BufferFormatter_SavedFormats_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_BufferFormatter_SavedFormats_set' argument 2 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_BufferFormatter_SavedFormats_set' argument 2 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->BufferFormatter_SavedFormats = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_BufferFormatter_SavedFormats_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< rdcstr > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_BufferFormatter_SavedFormats_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_BufferFormatter_SavedFormats_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< rdcstr > *)& ((arg1)->BufferFormatter_SavedFormats);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_rdcstr_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_TimeUnit_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  TimeUnit arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_TimeUnit_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_EventBrowser_TimeUnit_set" "', argument " "2"" of type '" "TimeUnit""'");
  } 
  arg2 = static_cast< TimeUnit >(val2);
  if (arg1) (arg1)->EventBrowser_TimeUnit = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_TimeUnit_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  TimeUnit result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_EventBrowser_TimeUnit_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_TimeUnit_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (TimeUnit) ((arg1)->EventBrowser_TimeUnit);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_TimeUnit->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_AddFake_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_AddFake_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_EventBrowser_AddFake_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->EventBrowser_AddFake = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_AddFake_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_EventBrowser_AddFake_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_AddFake_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->EventBrowser_AddFake);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_ApplyColors_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_ApplyColors_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_EventBrowser_ApplyColors_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->EventBrowser_ApplyColors = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_ApplyColors_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_EventBrowser_ApplyColors_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_ApplyColors_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->EventBrowser_ApplyColors);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_ColorEventRow_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_ColorEventRow_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_EventBrowser_ColorEventRow_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->EventBrowser_ColorEventRow = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_EventBrowser_ColorEventRow_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_EventBrowser_ColorEventRow_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_EventBrowser_ColorEventRow_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->EventBrowser_ColorEventRow);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Comments_ShowOnLoad_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Comments_ShowOnLoad_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Comments_ShowOnLoad_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Comments_ShowOnLoad = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Comments_ShowOnLoad_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Comments_ShowOnLoad_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Comments_ShowOnLoad_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->Comments_ShowOnLoad);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_MinFigures_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_MinFigures_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Formatter_MinFigures_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->Formatter_MinFigures = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_MinFigures_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Formatter_MinFigures_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_MinFigures_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (int) ((arg1)->Formatter_MinFigures);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_MaxFigures_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_MaxFigures_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Formatter_MaxFigures_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->Formatter_MaxFigures = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_MaxFigures_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Formatter_MaxFigures_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_MaxFigures_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (int) ((arg1)->Formatter_MaxFigures);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_NegExp_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_NegExp_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Formatter_NegExp_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->Formatter_NegExp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_NegExp_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Formatter_NegExp_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_NegExp_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (int) ((arg1)->Formatter_NegExp);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_PosExp_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_PosExp_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Formatter_PosExp_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->Formatter_PosExp = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_PosExp_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Formatter_PosExp_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_PosExp_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (int) ((arg1)->Formatter_PosExp);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_OffsetSizeDisplayMode_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  OffsetSizeDisplayMode arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_OffsetSizeDisplayMode_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Formatter_OffsetSizeDisplayMode_set" "', argument " "2"" of type '" "OffsetSizeDisplayMode""'");
  } 
  arg2 = static_cast< OffsetSizeDisplayMode >(val2);
  if (arg1) (arg1)->Formatter_OffsetSizeDisplayMode = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Formatter_OffsetSizeDisplayMode_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  OffsetSizeDisplayMode result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Formatter_OffsetSizeDisplayMode_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Formatter_OffsetSizeDisplayMode_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (OffsetSizeDisplayMode) ((arg1)->Formatter_OffsetSizeDisplayMode);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_OffsetSizeDisplayMode->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_GlobalScale_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_GlobalScale_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_float(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Font_GlobalScale_set" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  if (arg1) (arg1)->Font_GlobalScale = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_GlobalScale_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  float result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Font_GlobalScale_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_GlobalScale_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (float) ((arg1)->Font_GlobalScale);
  resultobj = SWIG_From_float(static_cast< float >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_Family_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_Family_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_Font_Family_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->Font_Family = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_Family_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Font_Family_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_Family_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->Font_Family);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_MonoFamily_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_MonoFamily_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_Font_MonoFamily_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->Font_MonoFamily = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_MonoFamily_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Font_MonoFamily_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_MonoFamily_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->Font_MonoFamily);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_PreferMonospaced_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_PreferMonospaced_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Font_PreferMonospaced_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Font_PreferMonospaced = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Font_PreferMonospaced_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Font_PreferMonospaced_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Font_PreferMonospaced_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->Font_PreferMonospaced);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_UnsupportedAndroid_LastUpdate_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcdatetime arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcdatetime temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_UnsupportedAndroid_LastUpdate_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_UnsupportedAndroid_LastUpdate_set' argument 2 of type 'rdcdatetime'"); 
    }
  }
  if (arg1) (arg1)->UnsupportedAndroid_LastUpdate = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_UnsupportedAndroid_LastUpdate_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcdatetime result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_UnsupportedAndroid_LastUpdate_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_UnsupportedAndroid_LastUpdate_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->UnsupportedAndroid_LastUpdate);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_AllowChecks_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_AllowChecks_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_CheckUpdate_AllowChecks_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->CheckUpdate_AllowChecks = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_AllowChecks_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CheckUpdate_AllowChecks_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_AllowChecks_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->CheckUpdate_AllowChecks);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_UpdateAvailable_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_UpdateAvailable_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_CheckUpdate_UpdateAvailable_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->CheckUpdate_UpdateAvailable = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_UpdateAvailable_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CheckUpdate_UpdateAvailable_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_UpdateAvailable_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->CheckUpdate_UpdateAvailable);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_CurrentVersion_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_CurrentVersion_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_CheckUpdate_CurrentVersion_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->CheckUpdate_CurrentVersion = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_CurrentVersion_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CheckUpdate_CurrentVersion_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_CurrentVersion_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->CheckUpdate_CurrentVersion);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_UpdateResponse_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_UpdateResponse_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_CheckUpdate_UpdateResponse_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->CheckUpdate_UpdateResponse = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_UpdateResponse_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CheckUpdate_UpdateResponse_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_UpdateResponse_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->CheckUpdate_UpdateResponse);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_LastUpdate_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcdatetime arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcdatetime temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_LastUpdate_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_CheckUpdate_LastUpdate_set' argument 2 of type 'rdcdatetime'"); 
    }
  }
  if (arg1) (arg1)->CheckUpdate_LastUpdate = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CheckUpdate_LastUpdate_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcdatetime result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CheckUpdate_LastUpdate_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CheckUpdate_LastUpdate_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->CheckUpdate_LastUpdate);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_DegradedCapture_LastUpdate_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcdatetime arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcdatetime temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_DegradedCapture_LastUpdate_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_DegradedCapture_LastUpdate_set' argument 2 of type 'rdcdatetime'"); 
    }
  }
  if (arg1) (arg1)->DegradedCapture_LastUpdate = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_DegradedCapture_LastUpdate_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcdatetime result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_DegradedCapture_LastUpdate_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_DegradedCapture_LastUpdate_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->DegradedCapture_LastUpdate);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_ExternalTool_RadeonGPUProfiler_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_ExternalTool_RadeonGPUProfiler_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_ExternalTool_RadeonGPUProfiler_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->ExternalTool_RadeonGPUProfiler = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_ExternalTool_RadeonGPUProfiler_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_ExternalTool_RadeonGPUProfiler_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_ExternalTool_RadeonGPUProfiler_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->ExternalTool_RadeonGPUProfiler);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Tips_HasSeenFirst_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Tips_HasSeenFirst_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Tips_HasSeenFirst_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Tips_HasSeenFirst = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Tips_HasSeenFirst_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Tips_HasSeenFirst_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Tips_HasSeenFirst_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->Tips_HasSeenFirst);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AllowGlobalHook_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AllowGlobalHook_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_AllowGlobalHook_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->AllowGlobalHook = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AllowGlobalHook_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_AllowGlobalHook_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AllowGlobalHook_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->AllowGlobalHook);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AllowProcessInject_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AllowProcessInject_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_AllowProcessInject_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->AllowProcessInject = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AllowProcessInject_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_AllowProcessInject_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AllowProcessInject_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->AllowProcessInject);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_ShaderProcessors_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< ShaderProcessingTool > *arg2 = (rdcarray< ShaderProcessingTool > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_ShaderProcessors_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_ShaderProcessors_set' argument 2 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_ShaderProcessors_set' argument 2 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->ShaderProcessors = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_ShaderProcessors_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ShaderProcessingTool > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_ShaderProcessors_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_ShaderProcessors_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< ShaderProcessingTool > *)& ((arg1)->ShaderProcessors);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_ShaderProcessingTool_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Analytics_TotalOptOut_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Analytics_TotalOptOut_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Analytics_TotalOptOut_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Analytics_TotalOptOut = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Analytics_TotalOptOut_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Analytics_TotalOptOut_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Analytics_TotalOptOut_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->Analytics_TotalOptOut);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Analytics_ManualCheck_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Analytics_ManualCheck_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_Analytics_ManualCheck_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->Analytics_ManualCheck = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Analytics_ManualCheck_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Analytics_ManualCheck_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Analytics_ManualCheck_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->Analytics_ManualCheck);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_EmailNagged_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_EmailNagged_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_CrashReport_EmailNagged_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->CrashReport_EmailNagged = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_EmailNagged_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CrashReport_EmailNagged_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_EmailNagged_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->CrashReport_EmailNagged);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_ShouldRememberEmail_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_ShouldRememberEmail_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "PersistantConfig_CrashReport_ShouldRememberEmail_set" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  if (arg1) (arg1)->CrashReport_ShouldRememberEmail = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_ShouldRememberEmail_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CrashReport_ShouldRememberEmail_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_ShouldRememberEmail_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool) ((arg1)->CrashReport_ShouldRememberEmail);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_EmailAddress_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_EmailAddress_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_CrashReport_EmailAddress_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->CrashReport_EmailAddress = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_EmailAddress_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CrashReport_EmailAddress_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_EmailAddress_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->CrashReport_EmailAddress);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_LastOpenedCapture_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_LastOpenedCapture_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_CrashReport_LastOpenedCapture_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->CrashReport_LastOpenedCapture = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_LastOpenedCapture_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CrashReport_LastOpenedCapture_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_LastOpenedCapture_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result =  ((arg1)->CrashReport_LastOpenedCapture);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_ReportedBugs_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< BugReport > *arg2 = (rdcarray< BugReport > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_ReportedBugs_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_CrashReport_ReportedBugs_set' argument 2 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_CrashReport_ReportedBugs_set' argument 2 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->CrashReport_ReportedBugs = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_CrashReport_ReportedBugs_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< BugReport > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_CrashReport_ReportedBugs_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_CrashReport_ReportedBugs_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< BugReport > *)& ((arg1)->CrashReport_ReportedBugs);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_BugReport_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AlwaysLoad_Extensions_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcarray< rdcstr > *arg2 = (rdcarray< rdcstr > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AlwaysLoad_Extensions_set" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(swig_obj[0], self);
    wasSelf2 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg2 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_AlwaysLoad_Extensions_set' argument 2 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'PersistantConfig_AlwaysLoad_Extensions_set' argument 2 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  if (arg1) (arg1)->AlwaysLoad_Extensions = *arg2;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf2)
    tempdealloc(arg2);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_AlwaysLoad_Extensions_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< rdcstr > *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_AlwaysLoad_Extensions_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_AlwaysLoad_Extensions_get" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (rdcarray< rdcstr > *)& ((arg1)->AlwaysLoad_Extensions);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_rdcarrayT_rdcstr_t, 0 |  0 );
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_PersistantConfig(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_PersistantConfig",0,0,0)) SWIG_fail;
  result = (PersistantConfig *)new PersistantConfig();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PersistantConfig, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_PersistantConfig(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_PersistantConfig",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PersistantConfig" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Load(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Load" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'PersistantConfig_Load' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->Load((rdcstr const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Save(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Save",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Save" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool)(arg1)->Save();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_Close(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_Close",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_Close" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  (arg1)->Close();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_SetupFormatting(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_SetupFormatting",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_SetupFormatting" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  (arg1)->SetupFormatting();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_PersistantConfig_SetStyle(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PersistantConfig *arg1 = (PersistantConfig *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"PersistantConfig_SetStyle",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PersistantConfig, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PersistantConfig_SetStyle" "', argument " "1"" of type '" "PersistantConfig *""'"); 
  }
  arg1 = reinterpret_cast< PersistantConfig * >(argp1);
  result = (bool)(arg1)->SetStyle();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_PersistantConfig) /* defines _wrap_delete_PersistantConfig_destructor_closure */

SWIGINTERN int _wrap_new_RemoteHost__SWIG_0(PyObject *self, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  RemoteHost *result = 0 ;
  
  if ((nobjs < 0) || (nobjs > 0)) SWIG_fail;
  result = (RemoteHost *)new RemoteHost();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RemoteHost, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_RemoteHost__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  rdcstr *arg1 = 0 ;
  rdcstr temp1 ;
  RemoteHost *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  {
    tempset(arg1, &temp1);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg1));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'new_RemoteHost' argument 1 of type 'rdcstr'"); 
    }
  }
  result = (RemoteHost *)new RemoteHost((rdcstr const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RemoteHost, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_RemoteHost__SWIG_2(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RemoteHost *result = 0 ;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(swig_obj[0], &argp1, SWIGTYPE_p_RemoteHost,  0  | 0);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "new_RemoteHost" "', argument " "1"" of type '" "RemoteHost const &""'"); 
  }
  if (!argp1) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "new_RemoteHost" "', argument " "1"" of type '" "RemoteHost const &""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (RemoteHost *)new RemoteHost((RemoteHost const &)*arg1);
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_RemoteHost, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN int _wrap_new_RemoteHost(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[2] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"new_RemoteHost",0,1,argv))) SWIG_fail;
  --argc;
  if (argc == 0) {
    return _wrap_new_RemoteHost__SWIG_0(self, argc, argv);
  }
  if (argc == 1) {
    int _v = 0;
    {
      int res = SWIG_ConvertPtr(argv[0], 0, SWIGTYPE_p_rdcstr, 0);
      _v = SWIG_CheckState(res);
    }
    if (!_v) goto check_2;
    return _wrap_new_RemoteHost__SWIG_1(self, argc, argv);
  }
check_2:
  
  if (argc == 1) {
    return _wrap_new_RemoteHost__SWIG_2(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'new_RemoteHost'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    RemoteHost::RemoteHost()\n"
    "    RemoteHost::RemoteHost(rdcstr const &)\n"
    "    RemoteHost::RemoteHost(RemoteHost const &)\n");
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_RemoteHost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_RemoteHost",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_RemoteHost" "', argument " "1"" of type '" "RemoteHost *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  RemoteHost *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost___eq__" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoteHost___eq__" "', argument " "2"" of type '" "RemoteHost const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RemoteHost___eq__" "', argument " "2"" of type '" "RemoteHost const &""'"); 
  }
  arg2 = reinterpret_cast< RemoteHost * >(argp2);
  result = (bool)((RemoteHost const *)arg1)->operator ==((RemoteHost const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  RemoteHost *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost___ne__" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoteHost___ne__" "', argument " "2"" of type '" "RemoteHost const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RemoteHost___ne__" "', argument " "2"" of type '" "RemoteHost const &""'"); 
  }
  arg2 = reinterpret_cast< RemoteHost * >(argp2);
  result = (bool)((RemoteHost const *)arg1)->operator !=((RemoteHost const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  RemoteHost *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost___lt__" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_RemoteHost,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoteHost___lt__" "', argument " "2"" of type '" "RemoteHost const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "RemoteHost___lt__" "', argument " "2"" of type '" "RemoteHost const &""'"); 
  }
  arg2 = reinterpret_cast< RemoteHost * >(argp2);
  result = (bool)((RemoteHost const *)arg1)->operator <((RemoteHost const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_CheckStatus(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_CheckStatus",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_CheckStatus" "', argument " "1"" of type '" "RemoteHost *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  (arg1)->CheckStatus();
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_Launch(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  ResultDetails result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_Launch",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_Launch" "', argument " "1"" of type '" "RemoteHost *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (arg1)->Launch();
  resultobj = SWIG_NewPointerObj((new ResultDetails(static_cast< const ResultDetails& >(result))), SWIGTYPE_p_ResultDetails, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_IsServerRunning(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_IsServerRunning",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_IsServerRunning" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (bool)((RemoteHost const *)arg1)->IsServerRunning();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_IsConnected(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_IsConnected",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_IsConnected" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (bool)((RemoteHost const *)arg1)->IsConnected();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_IsBusy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_IsBusy",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_IsBusy" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (bool)((RemoteHost const *)arg1)->IsBusy();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_IsVersionMismatch(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_IsVersionMismatch",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_IsVersionMismatch" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (bool)((RemoteHost const *)arg1)->IsVersionMismatch();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_VersionMismatchError(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_VersionMismatchError",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_VersionMismatchError" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = ((RemoteHost const *)arg1)->VersionMismatchError();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_Hostname(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_Hostname",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_Hostname" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = ((RemoteHost const *)arg1)->Hostname();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_FriendlyName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_FriendlyName",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_FriendlyName" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = ((RemoteHost const *)arg1)->FriendlyName();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_RunCommand(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_RunCommand",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_RunCommand" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = ((RemoteHost const *)arg1)->RunCommand();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_SetRunCommand(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_SetRunCommand" "', argument " "1"" of type '" "RemoteHost *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'RemoteHost_SetRunCommand' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetRunCommand((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_LastCapturePath(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_LastCapturePath",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_LastCapturePath" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = ((RemoteHost const *)arg1)->LastCapturePath();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_SetLastCapturePath(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_SetLastCapturePath" "', argument " "1"" of type '" "RemoteHost *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'RemoteHost_SetLastCapturePath' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetLastCapturePath((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_Connect(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  IRemoteServer **arg2 = (IRemoteServer **) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  ResultDetails result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_Connect" "', argument " "1"" of type '" "RemoteHost *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2,SWIGTYPE_p_p_IRemoteServer, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "RemoteHost_Connect" "', argument " "2"" of type '" "IRemoteServer **""'"); 
  }
  arg2 = reinterpret_cast< IRemoteServer ** >(argp2);
  result = (arg1)->Connect(arg2);
  resultobj = SWIG_NewPointerObj((new ResultDetails(static_cast< const ResultDetails& >(result))), SWIGTYPE_p_ResultDetails, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_Protocol(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IDeviceProtocolController *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_Protocol",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_Protocol" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (IDeviceProtocolController *)((RemoteHost const *)arg1)->Protocol();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IDeviceProtocolController, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_Name(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_Name",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_Name" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = ((RemoteHost const *)arg1)->Name();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_IsLocalhost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_IsLocalhost",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_IsLocalhost" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (bool)((RemoteHost const *)arg1)->IsLocalhost();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_RemoteHost_IsValid(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  RemoteHost *arg1 = (RemoteHost *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  bool result;
  
  if (!SWIG_Python_UnpackTuple(args,"RemoteHost_IsValid",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_RemoteHost, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "RemoteHost_IsValid" "', argument " "1"" of type '" "RemoteHost const *""'"); 
  }
  arg1 = reinterpret_cast< RemoteHost * >(argp1);
  result = (bool)((RemoteHost const *)arg1)->IsValid();
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_RemoteHost) /* defines _wrap_delete_RemoteHost_destructor_closure */

SWIGINTERN int _wrap_new_WindowMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  WindowMenu *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_WindowMenu",0,0,0)) SWIG_fail;
  result = (WindowMenu *)new WindowMenu();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_WindowMenu, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_WindowMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  WindowMenu *arg1 = (WindowMenu *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_WindowMenu",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_WindowMenu, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_WindowMenu" "', argument " "1"" of type '" "WindowMenu *""'"); 
  }
  arg1 = reinterpret_cast< WindowMenu * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_WindowMenu) /* defines _wrap_delete_WindowMenu_destructor_closure */

SWIGINTERN int _wrap_new_PanelMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PanelMenu *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_PanelMenu",0,0,0)) SWIG_fail;
  result = (PanelMenu *)new PanelMenu();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_PanelMenu, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_PanelMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  PanelMenu *arg1 = (PanelMenu *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_PanelMenu",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_PanelMenu, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_PanelMenu" "', argument " "1"" of type '" "PanelMenu *""'"); 
  }
  arg1 = reinterpret_cast< PanelMenu * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_PanelMenu) /* defines _wrap_delete_PanelMenu_destructor_closure */

SWIGINTERN int _wrap_new_ContextMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ContextMenu *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_ContextMenu",0,0,0)) SWIG_fail;
  result = (ContextMenu *)new ContextMenu();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ContextMenu, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_ContextMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ContextMenu *arg1 = (ContextMenu *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_ContextMenu",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ContextMenu, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ContextMenu" "', argument " "1"" of type '" "ContextMenu *""'"); 
  }
  arg1 = reinterpret_cast< ContextMenu * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ContextMenu) /* defines _wrap_delete_ContextMenu_destructor_closure */

SWIGINTERN int _wrap_new_DialogButton(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  DialogButton *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_DialogButton",0,0,0)) SWIG_fail;
  result = (DialogButton *)new DialogButton();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_DialogButton, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_DialogButton(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  DialogButton *arg1 = (DialogButton *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_DialogButton",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_DialogButton, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_DialogButton" "', argument " "1"" of type '" "DialogButton *""'"); 
  }
  arg1 = reinterpret_cast< DialogButton * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_DialogButton) /* defines _wrap_delete_DialogButton_destructor_closure */

SWIGINTERN PyObject *_wrap_ExtensionMetadata___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  ExtensionMetadata *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata___eq__" "', argument " "1"" of type '" "ExtensionMetadata const *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ExtensionMetadata,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtensionMetadata___eq__" "', argument " "2"" of type '" "ExtensionMetadata const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtensionMetadata___eq__" "', argument " "2"" of type '" "ExtensionMetadata const &""'"); 
  }
  arg2 = reinterpret_cast< ExtensionMetadata * >(argp2);
  result = (bool)((ExtensionMetadata const *)arg1)->operator ==((ExtensionMetadata const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  ExtensionMetadata *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata___lt__" "', argument " "1"" of type '" "ExtensionMetadata const *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  res2 = SWIG_ConvertPtr(swig_obj[0], &argp2, SWIGTYPE_p_ExtensionMetadata,  0  | 0);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "ExtensionMetadata___lt__" "', argument " "2"" of type '" "ExtensionMetadata const &""'"); 
  }
  if (!argp2) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "ExtensionMetadata___lt__" "', argument " "2"" of type '" "ExtensionMetadata const &""'"); 
  }
  arg2 = reinterpret_cast< ExtensionMetadata * >(argp2);
  result = (bool)((ExtensionMetadata const *)arg1)->operator <((ExtensionMetadata const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_extensionAPI_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_extensionAPI_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExtensionMetadata_extensionAPI_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  if (arg1) (arg1)->extensionAPI = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_extensionAPI_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  int result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_extensionAPI_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_extensionAPI_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result = (int) ((arg1)->extensionAPI);
  resultobj = SWIG_From_int(static_cast< int >(result));
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_filePath_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_filePath_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_filePath_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->filePath = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_filePath_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_filePath_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_filePath_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->filePath);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_package_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_package_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_package_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->package = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_package_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_package_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_package_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->package);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_name_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_name_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_name_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->name = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_name_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_name_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_name_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->name);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_version_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_version_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_version_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->version = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_version_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_version_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_version_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->version);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_author_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_author_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_author_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->author = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_author_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_author_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_author_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->author);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_extensionURL_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_extensionURL_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_extensionURL_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->extensionURL = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_extensionURL_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_extensionURL_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_extensionURL_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->extensionURL);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_description_set(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_description_set" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionMetadata_description_set' argument 2 of type 'rdcstr'"); 
    }
  }
  if (arg1) (arg1)->description = arg2;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionMetadata_description_get(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcstr result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionMetadata_description_get",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionMetadata_description_get" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  result =  ((arg1)->description);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  if (SwigPyObject_Check(resultobj)) {
    SwigPyObject *sobj = (SwigPyObject *)resultobj;
    sobj->parent = self;
    Py_INCREF(self);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN int _wrap_new_ExtensionMetadata(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"new_ExtensionMetadata",0,0,0)) SWIG_fail;
  result = (ExtensionMetadata *)new ExtensionMetadata();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_ExtensionMetadata, SWIG_BUILTIN_INIT |  0 );
  return resultobj == Py_None ? -1 : 0;
fail:
  return -1;
}


SWIGINTERN PyObject *_wrap_delete_ExtensionMetadata(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  ExtensionMetadata *arg1 = (ExtensionMetadata *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_ExtensionMetadata",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_ExtensionMetadata, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_ExtensionMetadata" "', argument " "1"" of type '" "ExtensionMetadata *""'"); 
  }
  arg1 = reinterpret_cast< ExtensionMetadata * >(argp1);
  delete arg1;
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_ExtensionMetadata) /* defines _wrap_delete_ExtensionMetadata_destructor_closure */

SWIGINTERN PyObject *_wrap_MiniQtHelper_InvokeOntoUIThread(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  IMiniQtHelper::InvokeCallback arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_InvokeOntoUIThread" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<IMiniQtHelper::InvokeCallback>("MiniQtHelper_InvokeOntoUIThread", func, exHandle2);
  }
  (arg1)->InvokeOntoUIThread(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateToplevelWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  rdcstr *arg2 = 0 ;
  IMiniQtHelper::WidgetCallback arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  StackExceptionHandler exHandle3 ;
  PyObject *swig_obj[3] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateToplevelWidget",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateToplevelWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_CreateToplevelWidget' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    PyObject *func = swig_obj[1];
    arg3 = ConvertFunc<IMiniQtHelper::WidgetCallback>("MiniQtHelper_CreateToplevelWidget", func, exHandle3);
  }
  result = (QWidget *)(arg1)->CreateToplevelWidget((rdcstr const &)*arg2,arg3);
  {
    resultobj = QWidgetToPy(result);
  }
  {
    if(exHandle3.data().failFlag) {
      PyErr_Restore(exHandle3.data().exObj, exHandle3.data().valueObj, exHandle3.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CloseToplevelWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CloseToplevelWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_CloseToplevelWidget' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  (arg1)->CloseToplevelWidget(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetName",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetName" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetName' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_SetWidgetName' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetWidgetName(arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetWidgetName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetWidgetName" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetWidgetName' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (arg1)->GetWidgetName(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetWidgetType(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetWidgetType" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetWidgetType' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (arg1)->GetWidgetType(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_FindChildByName(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_FindChildByName",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_FindChildByName" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_FindChildByName' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_FindChildByName' argument 3 of type 'rdcstr'"); 
    }
  }
  result = (QWidget *)(arg1)->FindChildByName(arg2,(rdcstr const &)*arg3);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetParent(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetParent" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetParent' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (QWidget *)(arg1)->GetParent(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetNumChildren(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  int32_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetNumChildren" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetNumChildren' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (int32_t)(arg1)->GetNumChildren(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetChild(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  int32_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_GetChild",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetChild" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetChild' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_GetChild" "', argument " "3"" of type '" "int32_t""'");
  } 
  arg3 = static_cast< int32_t >(val3);
  result = (QWidget *)(arg1)->GetChild(arg2,arg3);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_DestroyWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_DestroyWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_DestroyWidget' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  (arg1)->DestroyWidget(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_ShowWidgetAsDialog(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_ShowWidgetAsDialog" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_ShowWidgetAsDialog' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (bool)(arg1)->ShowWidgetAsDialog(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CloseCurrentDialog(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CloseCurrentDialog" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CloseCurrentDialog" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  (arg1)->CloseCurrentDialog(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateHorizontalContainer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateHorizontalContainer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateHorizontalContainer" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  result = (QWidget *)(arg1)->CreateHorizontalContainer();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateVerticalContainer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateVerticalContainer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateVerticalContainer" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  result = (QWidget *)(arg1)->CreateVerticalContainer();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateGridContainer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateGridContainer",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateGridContainer" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  result = (QWidget *)(arg1)->CreateGridContainer();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateSpacer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateSpacer" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CreateSpacer" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (QWidget *)(arg1)->CreateSpacer(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_ClearContainedWidgets(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_ClearContainedWidgets" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_ClearContainedWidgets' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  (arg1)->ClearContainedWidgets(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_AddGridWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  int32_t arg3 ;
  int32_t arg4 ;
  QWidget *arg5 = (QWidget *) 0 ;
  int32_t arg6 ;
  int32_t arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  PyObject *swig_obj[7] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_AddGridWidget",6,6,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_AddGridWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_AddGridWidget' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_AddGridWidget" "', argument " "3"" of type '" "int32_t""'");
  } 
  arg3 = static_cast< int32_t >(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MiniQtHelper_AddGridWidget" "', argument " "4"" of type '" "int32_t""'");
  } 
  arg4 = static_cast< int32_t >(val4);
  {
    if(Py_IsNone(swig_obj[3]))
    arg5 = NULL;
    else
    arg5 = QWidgetFromPy(swig_obj[3]);
    if(swig_obj[3] && !Py_IsNone(swig_obj[3]) && !arg5)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_AddGridWidget' QWidget expected for argument 5 of type 'QWidget'");
    }
  }
  ecode6 = SWIG_AsVal_int(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "MiniQtHelper_AddGridWidget" "', argument " "6"" of type '" "int32_t""'");
  } 
  arg6 = static_cast< int32_t >(val6);
  ecode7 = SWIG_AsVal_int(swig_obj[5], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "MiniQtHelper_AddGridWidget" "', argument " "7"" of type '" "int32_t""'");
  } 
  arg7 = static_cast< int32_t >(val7);
  (arg1)->AddGridWidget(arg2,arg3,arg4,arg5,arg6,arg7);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_AddWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  QWidget *arg3 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_AddWidget",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_AddWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_AddWidget' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    if(Py_IsNone(swig_obj[1]))
    arg3 = NULL;
    else
    arg3 = QWidgetFromPy(swig_obj[1]);
    if(swig_obj[1] && !Py_IsNone(swig_obj[1]) && !arg3)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_AddWidget' QWidget expected for argument 3 of type 'QWidget'");
    }
  }
  (arg1)->AddWidget(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_InsertWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  int32_t arg3 ;
  QWidget *arg4 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_InsertWidget",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_InsertWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_InsertWidget' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_InsertWidget" "', argument " "3"" of type '" "int32_t""'");
  } 
  arg3 = static_cast< int32_t >(val3);
  {
    if(Py_IsNone(swig_obj[2]))
    arg4 = NULL;
    else
    arg4 = QWidgetFromPy(swig_obj[2]);
    if(swig_obj[2] && !Py_IsNone(swig_obj[2]) && !arg4)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_InsertWidget' QWidget expected for argument 4 of type 'QWidget'");
    }
  }
  (arg1)->InsertWidget(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetText(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetText",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetText" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetText' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_SetWidgetText' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->SetWidgetText(arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetWidgetText(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetWidgetText" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetWidgetText' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (arg1)->GetWidgetText(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetFont(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcstr *arg3 = 0 ;
  int32_t arg4 ;
  bool arg5 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp3 ;
  int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetFont",5,5,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetFont" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetFont' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_SetWidgetFont' argument 3 of type 'rdcstr'"); 
    }
  }
  ecode4 = SWIG_AsVal_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MiniQtHelper_SetWidgetFont" "', argument " "4"" of type '" "int32_t""'");
  } 
  arg4 = static_cast< int32_t >(val4);
  ecode5 = SWIG_AsVal_bool(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "MiniQtHelper_SetWidgetFont" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "MiniQtHelper_SetWidgetFont" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  (arg1)->SetWidgetFont(arg2,(rdcstr const &)*arg3,arg4,arg5,arg6);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetEnabled(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetEnabled",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetEnabled" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetEnabled' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetWidgetEnabled" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->SetWidgetEnabled(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_IsWidgetEnabled(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_IsWidgetEnabled" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_IsWidgetEnabled' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (bool)(arg1)->IsWidgetEnabled(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetVisible(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetVisible",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetVisible" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetVisible' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetWidgetVisible" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->SetWidgetVisible(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_IsWidgetVisible(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_IsWidgetVisible" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_IsWidgetVisible' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (bool)(arg1)->IsWidgetVisible(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateGroupBox(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateGroupBox" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CreateGroupBox" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (QWidget *)(arg1)->CreateGroupBox(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateButton(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  IMiniQtHelper::WidgetCallback arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateButton" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<IMiniQtHelper::WidgetCallback>("MiniQtHelper_CreateButton", func, exHandle2);
  }
  result = (QWidget *)(arg1)->CreateButton(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateLabel(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateLabel",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateLabel" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  result = (QWidget *)(arg1)->CreateLabel();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetLabelImage(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  bytebuf *arg3 = 0 ;
  int32_t arg4 ;
  int32_t arg5 ;
  bool arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bytebuf temp3 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  PyObject *swig_obj[6] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetLabelImage",5,5,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetLabelImage" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetLabelImage' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_SetLabelImage' argument 3 of type 'bytebuf'"); 
    }
  }
  ecode4 = SWIG_AsVal_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MiniQtHelper_SetLabelImage" "', argument " "4"" of type '" "int32_t""'");
  } 
  arg4 = static_cast< int32_t >(val4);
  ecode5 = SWIG_AsVal_int(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "MiniQtHelper_SetLabelImage" "', argument " "5"" of type '" "int32_t""'");
  } 
  arg5 = static_cast< int32_t >(val5);
  ecode6 = SWIG_AsVal_bool(swig_obj[4], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "MiniQtHelper_SetLabelImage" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  (arg1)->SetLabelImage(arg2,(bytebuf const &)*arg3,arg4,arg5,arg6);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateOutputRenderingWidget(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateOutputRenderingWidget",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateOutputRenderingWidget" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  result = (QWidget *)(arg1)->CreateOutputRenderingWidget();
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetWidgetWindowingData(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  WindowingData result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetWidgetWindowingData" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetWidgetWindowingData' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (arg1)->GetWidgetWindowingData(arg2);
  resultobj = SWIG_NewPointerObj((new WindowingData(static_cast< const WindowingData& >(result))), SWIGTYPE_p_WindowingData, SWIG_POINTER_OWN |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetReplayOutput(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  IReplayOutput *arg3 = (IReplayOutput *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetReplayOutput",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetReplayOutput" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetReplayOutput' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3,SWIGTYPE_p_IReplayOutput, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "MiniQtHelper_SetWidgetReplayOutput" "', argument " "3"" of type '" "IReplayOutput *""'"); 
  }
  arg3 = reinterpret_cast< IReplayOutput * >(argp3);
  (arg1)->SetWidgetReplayOutput(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetBackgroundColor(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  PyObject *swig_obj[5] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetBackgroundColor",4,4,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetBackgroundColor" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetBackgroundColor' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_float(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetWidgetBackgroundColor" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MiniQtHelper_SetWidgetBackgroundColor" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  ecode5 = SWIG_AsVal_float(swig_obj[3], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "MiniQtHelper_SetWidgetBackgroundColor" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  (arg1)->SetWidgetBackgroundColor(arg2,arg3,arg4,arg5);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateCheckbox(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  IMiniQtHelper::WidgetCallback arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateCheckbox" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<IMiniQtHelper::WidgetCallback>("MiniQtHelper_CreateCheckbox", func, exHandle2);
  }
  result = (QWidget *)(arg1)->CreateCheckbox(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateRadiobox(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  IMiniQtHelper::WidgetCallback arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateRadiobox" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<IMiniQtHelper::WidgetCallback>("MiniQtHelper_CreateRadiobox", func, exHandle2);
  }
  result = (QWidget *)(arg1)->CreateRadiobox(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetWidgetChecked(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  bool arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetWidgetChecked",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetWidgetChecked" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetWidgetChecked' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_bool(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetWidgetChecked" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  (arg1)->SetWidgetChecked(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_IsWidgetChecked(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_IsWidgetChecked" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_IsWidgetChecked' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (bool)(arg1)->IsWidgetChecked(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateSpinbox(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  int32_t arg2 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateSpinbox",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateSpinbox" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CreateSpinbox" "', argument " "2"" of type '" "int32_t""'");
  } 
  arg2 = static_cast< int32_t >(val2);
  ecode3 = SWIG_AsVal_double(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_CreateSpinbox" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  result = (QWidget *)(arg1)->CreateSpinbox(arg2,arg3);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetSpinboxBounds(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  double arg3 ;
  double arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  double val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetSpinboxBounds",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetSpinboxBounds" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetSpinboxBounds' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetSpinboxBounds" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  ecode4 = SWIG_AsVal_double(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MiniQtHelper_SetSpinboxBounds" "', argument " "4"" of type '" "double""'");
  } 
  arg4 = static_cast< double >(val4);
  (arg1)->SetSpinboxBounds(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetSpinboxValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  double arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  double val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetSpinboxValue",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetSpinboxValue" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetSpinboxValue' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_double(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetSpinboxValue" "', argument " "3"" of type '" "double""'");
  } 
  arg3 = static_cast< double >(val3);
  (arg1)->SetSpinboxValue(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetSpinboxValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  double result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetSpinboxValue" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetSpinboxValue' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (double)(arg1)->GetSpinboxValue(arg2);
  resultobj = SWIG_From_double(static_cast< double >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateTextBox(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  bool arg2 ;
  IMiniQtHelper::WidgetCallback arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  StackExceptionHandler exHandle3 ;
  PyObject *swig_obj[3] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateTextBox",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateTextBox" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CreateTextBox" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    PyObject *func = swig_obj[1];
    arg3 = ConvertFunc<IMiniQtHelper::WidgetCallback>("MiniQtHelper_CreateTextBox", func, exHandle3);
  }
  result = (QWidget *)(arg1)->CreateTextBox(arg2,arg3);
  {
    resultobj = QWidgetToPy(result);
  }
  {
    if(exHandle3.data().failFlag) {
      PyErr_Restore(exHandle3.data().exObj, exHandle3.data().valueObj, exHandle3.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateComboBox(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  bool arg2 ;
  IMiniQtHelper::WidgetCallback arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  StackExceptionHandler exHandle3 ;
  PyObject *swig_obj[3] ;
  QWidget *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_CreateComboBox",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateComboBox" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CreateComboBox" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    PyObject *func = swig_obj[1];
    arg3 = ConvertFunc<IMiniQtHelper::WidgetCallback>("MiniQtHelper_CreateComboBox", func, exHandle3);
  }
  result = (QWidget *)(arg1)->CreateComboBox(arg2,arg3);
  {
    resultobj = QWidgetToPy(result);
  }
  {
    if(exHandle3.data().failFlag) {
      PyErr_Restore(exHandle3.data().exObj, exHandle3.data().valueObj, exHandle3.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetComboOptions(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcarray< rdcstr > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetComboOptions",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetComboOptions" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetComboOptions' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_SetComboOptions' argument 3 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'MiniQtHelper_SetComboOptions' argument 3 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  (arg1)->SetComboOptions(arg2,(rdcarray< rdcstr > const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetComboCount(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  size_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetComboCount" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetComboCount' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (arg1)->GetComboCount(arg2);
  resultobj = SWIG_From_size_t(static_cast< size_t >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SelectComboOption(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SelectComboOption",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SelectComboOption" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SelectComboOption' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'MiniQtHelper_SelectComboOption' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->SelectComboOption(arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_CreateProgressBar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  QWidget *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_CreateProgressBar" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  ecode2 = SWIG_AsVal_bool(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "MiniQtHelper_CreateProgressBar" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  result = (QWidget *)(arg1)->CreateProgressBar(arg2);
  {
    resultobj = QWidgetToPy(result);
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_ResetProgressBar(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_ResetProgressBar" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_ResetProgressBar' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  (arg1)->ResetProgressBar(arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetProgressBarValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  int32_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetProgressBarValue",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetProgressBarValue" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetProgressBarValue' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetProgressBarValue" "', argument " "3"" of type '" "int32_t""'");
  } 
  arg3 = static_cast< int32_t >(val3);
  (arg1)->SetProgressBarValue(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_UpdateProgressBarValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  int32_t arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_UpdateProgressBarValue",2,2,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_UpdateProgressBarValue" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_UpdateProgressBarValue' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_UpdateProgressBarValue" "', argument " "3"" of type '" "int32_t""'");
  } 
  arg3 = static_cast< int32_t >(val3);
  (arg1)->UpdateProgressBarValue(arg2,arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetProgressBarValue(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  int32_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetProgressBarValue" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetProgressBarValue' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (int32_t)(arg1)->GetProgressBarValue(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_SetProgressBarRange(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  int32_t arg3 ;
  int32_t arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"MiniQtHelper_SetProgressBarRange",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_SetProgressBarRange" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_SetProgressBarRange' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  ecode3 = SWIG_AsVal_int(swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "MiniQtHelper_SetProgressBarRange" "', argument " "3"" of type '" "int32_t""'");
  } 
  arg3 = static_cast< int32_t >(val3);
  ecode4 = SWIG_AsVal_int(swig_obj[2], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "MiniQtHelper_SetProgressBarRange" "', argument " "4"" of type '" "int32_t""'");
  } 
  arg4 = static_cast< int32_t >(val4);
  (arg1)->SetProgressBarRange(arg2,arg3,arg4);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetProgressBarMinimum(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  int32_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetProgressBarMinimum" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetProgressBarMinimum' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (int32_t)(arg1)->GetProgressBarMinimum(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_MiniQtHelper_GetProgressBarMaximum(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IMiniQtHelper *arg1 = (IMiniQtHelper *) 0 ;
  QWidget *arg2 = (QWidget *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[2] ;
  int32_t result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MiniQtHelper_GetProgressBarMaximum" "', argument " "1"" of type '" "IMiniQtHelper *""'"); 
  }
  arg1 = reinterpret_cast< IMiniQtHelper * >(argp1);
  {
    if(Py_IsNone(swig_obj[0]))
    arg2 = NULL;
    else
    arg2 = QWidgetFromPy(swig_obj[0]);
    if(swig_obj[0] && !Py_IsNone(swig_obj[0]) && !arg2)
    {
      SWIG_exception_fail(SWIG_TypeError, "in method 'MiniQtHelper_GetProgressBarMaximum' QWidget expected for argument 2 of type 'QWidget'");
    }
  }
  result = (int32_t)(arg1)->GetProgressBarMaximum(arg2);
  resultobj = SWIG_From_int(static_cast< int >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_GetInstalledExtensions(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  rdcarray< ExtensionMetadata > result;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionManager_GetInstalledExtensions",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_GetInstalledExtensions" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  result = (arg1)->GetInstalledExtensions();
  resultobj = SWIG_NewPointerObj((new rdcarray< ExtensionMetadata >(static_cast< const rdcarray< ExtensionMetadata >& >(result))), SWIGTYPE_p_rdcarrayT_ExtensionMetadata_t, SWIG_POINTER_OWN |  0 );
  {
    add_your_use_of_rdcarray_to_swig_interface (&result); 
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_IsExtensionLoaded(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_IsExtensionLoaded" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_IsExtensionLoaded' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (bool)(arg1)->IsExtensionLoaded(arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_LoadExtension(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  PyObject *swig_obj[2] ;
  rdcstr result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_LoadExtension" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[0], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_LoadExtension' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->LoadExtension(arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_RegisterWindowMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  WindowMenu arg2 ;
  rdcarray< rdcstr > *arg3 = 0 ;
  IExtensionManager::ExtensionCallback arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  StackExceptionHandler exHandle4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionManager_RegisterWindowMenu",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_RegisterWindowMenu" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExtensionManager_RegisterWindowMenu" "', argument " "2"" of type '" "WindowMenu""'");
  } 
  arg2 = static_cast< WindowMenu >(val2);
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_RegisterWindowMenu' argument 3 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'ExtensionManager_RegisterWindowMenu' argument 3 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[2];
    arg4 = ConvertFunc<IExtensionManager::ExtensionCallback>("ExtensionManager_RegisterWindowMenu", func, exHandle4);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  (arg1)->RegisterWindowMenu(arg2,(rdcarray< rdcstr > const &)*arg3,arg4);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle4.data().failFlag) {
      PyErr_Restore(exHandle4.data().exObj, exHandle4.data().valueObj, exHandle4.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_RegisterPanelMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  PanelMenu arg2 ;
  rdcarray< rdcstr > *arg3 = 0 ;
  IExtensionManager::ExtensionCallback arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  StackExceptionHandler exHandle4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionManager_RegisterPanelMenu",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_RegisterPanelMenu" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExtensionManager_RegisterPanelMenu" "', argument " "2"" of type '" "PanelMenu""'");
  } 
  arg2 = static_cast< PanelMenu >(val2);
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_RegisterPanelMenu' argument 3 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'ExtensionManager_RegisterPanelMenu' argument 3 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[2];
    arg4 = ConvertFunc<IExtensionManager::ExtensionCallback>("ExtensionManager_RegisterPanelMenu", func, exHandle4);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  (arg1)->RegisterPanelMenu(arg2,(rdcarray< rdcstr > const &)*arg3,arg4);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle4.data().failFlag) {
      PyErr_Restore(exHandle4.data().exObj, exHandle4.data().valueObj, exHandle4.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_RegisterContextMenu(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  ContextMenu arg2 ;
  rdcarray< rdcstr > *arg3 = 0 ;
  IExtensionManager::ExtensionCallback arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  StackExceptionHandler exHandle4 ;
  PyObject *swig_obj[4] ;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionManager_RegisterContextMenu",3,3,swig_obj)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_RegisterContextMenu" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  ecode2 = SWIG_AsVal_int(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "ExtensionManager_RegisterContextMenu" "', argument " "2"" of type '" "ContextMenu""'");
  } 
  arg2 = static_cast< ContextMenu >(val2);
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstr >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[1], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_RegisterContextMenu' argument 3 of type 'rdcarray< rdcstr >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'ExtensionManager_RegisterContextMenu' argument 3 of type 'rdcarray< rdcstr >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[2];
    arg4 = ConvertFunc<IExtensionManager::ExtensionCallback>("ExtensionManager_RegisterContextMenu", func, exHandle4);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  (arg1)->RegisterContextMenu(arg2,(rdcarray< rdcstr > const &)*arg3,arg4);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle4.data().failFlag) {
      PyErr_Restore(exHandle4.data().exObj, exHandle4.data().valueObj, exHandle4.data().tracebackObj);
      SWIG_fail;
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_GetMiniQtHelper(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PyObject *swig_obj[1] ;
  IMiniQtHelper *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"ExtensionManager_GetMiniQtHelper",0,0,0)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_GetMiniQtHelper" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  result = (IMiniQtHelper *) &(arg1)->GetMiniQtHelper();
  resultobj = SWIG_NewPointerObj(SWIG_as_voidptr(result), SWIGTYPE_p_IMiniQtHelper, 0 |  0 );
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_MessageDialog__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_MessageDialog" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_MessageDialog' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_MessageDialog' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->MessageDialog((rdcstr const &)*arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_MessageDialog__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_MessageDialog" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_MessageDialog' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->MessageDialog((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_MessageDialog(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ExtensionManager_MessageDialog",0,3,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    return _wrap_ExtensionManager_MessageDialog__SWIG_1(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_ExtensionManager_MessageDialog__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ExtensionManager_MessageDialog'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IExtensionManager::MessageDialog(rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::MessageDialog(rdcstr const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_ErrorDialog__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_ErrorDialog" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_ErrorDialog' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_ErrorDialog' argument 3 of type 'rdcstr'"); 
    }
  }
  (arg1)->ErrorDialog((rdcstr const &)*arg2,(rdcstr const &)*arg3);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_ErrorDialog__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_ErrorDialog" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_ErrorDialog' argument 2 of type 'rdcstr'"); 
    }
  }
  (arg1)->ErrorDialog((rdcstr const &)*arg2);
  resultobj = SWIG_Py_Void();
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_ErrorDialog(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ExtensionManager_ErrorDialog",0,3,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 2) {
    return _wrap_ExtensionManager_ErrorDialog__SWIG_1(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_ExtensionManager_ErrorDialog__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ExtensionManager_ErrorDialog'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IExtensionManager::ErrorDialog(rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::ErrorDialog(rdcstr const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_QuestionDialog__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcarray< DialogButton > *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  rdcstr temp4 ;
  DialogButton result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_QuestionDialog" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_QuestionDialog' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[2], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_QuestionDialog' argument 3 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'ExtensionManager_QuestionDialog' argument 3 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[3], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_QuestionDialog' argument 4 of type 'rdcstr'"); 
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  result = (DialogButton)(arg1)->QuestionDialog((rdcstr const &)*arg2,(rdcarray< DialogButton > const &)*arg3,(rdcstr const &)*arg4);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_DialogButton->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_QuestionDialog__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcarray< DialogButton > *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  unsigned char tempmem3[32] ;
  bool wasSelf3 = false ;
  DialogButton result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_QuestionDialog" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_QuestionDialog' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg3)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem3) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg3, tempmem3);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[2], indirect(arg3), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_QuestionDialog' argument 3 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'ExtensionManager_QuestionDialog' argument 3 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg3); 
  }
  result = (DialogButton)(arg1)->QuestionDialog((rdcstr const &)*arg2,(rdcarray< DialogButton > const &)*arg3);
  {
    SwigPyClientData *cd = NULL;
    PyObject *enum_constructor = NULL;
    PyObject *numerical = SWIG_From_int(static_cast< int >(result));
    
    cd = (SwigPyClientData*)SWIGTYPE_p_DialogButton->clientdata;
    if (cd->pytype->tp_dict) {
      resultobj = numerical;
    } else {
      enum_constructor = (PyObject *)cd->pytype->tp_base;
      resultobj = PyObject_CallFunctionObjArgs(enum_constructor, numerical, NULL);
      Py_DECREF(numerical);
    }
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_QuestionDialog(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ExtensionManager_QuestionDialog",0,4,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 3) {
    return _wrap_ExtensionManager_QuestionDialog__SWIG_1(self, argc, argv);
  }
  if (argc == 4) {
    return _wrap_ExtensionManager_QuestionDialog__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ExtensionManager_QuestionDialog'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IExtensionManager::QuestionDialog(rdcstr const &,rdcarray< DialogButton > const &,rdcstr const &)\n"
    "    IExtensionManager::QuestionDialog(rdcstr const &,rdcarray< DialogButton > const &)\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenFileName__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  rdcstr temp4 ;
  rdcstr result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenFileName' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenFileName' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[3], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenFileName' argument 4 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->OpenFileName((rdcstr const &)*arg2,(rdcstr const &)*arg3,(rdcstr const &)*arg4);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenFileName__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  rdcstr result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenFileName' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenFileName' argument 3 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->OpenFileName((rdcstr const &)*arg2,(rdcstr const &)*arg3);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenFileName__SWIG_2(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenFileName' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->OpenFileName((rdcstr const &)*arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenFileName__SWIG_3(PyObject *self, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  result = (arg1)->OpenFileName();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenFileName(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ExtensionManager_OpenFileName",0,4,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    return _wrap_ExtensionManager_OpenFileName__SWIG_3(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_ExtensionManager_OpenFileName__SWIG_2(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_ExtensionManager_OpenFileName__SWIG_1(self, argc, argv);
  }
  if (argc == 4) {
    return _wrap_ExtensionManager_OpenFileName__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ExtensionManager_OpenFileName'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IExtensionManager::OpenFileName(rdcstr const &,rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::OpenFileName(rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::OpenFileName(rdcstr const &)\n"
    "    IExtensionManager::OpenFileName()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenDirectoryName__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  rdcstr result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenDirectoryName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenDirectoryName' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenDirectoryName' argument 3 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->OpenDirectoryName((rdcstr const &)*arg2,(rdcstr const &)*arg3);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenDirectoryName__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenDirectoryName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_OpenDirectoryName' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->OpenDirectoryName((rdcstr const &)*arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenDirectoryName__SWIG_2(PyObject *self, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_OpenDirectoryName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  result = (arg1)->OpenDirectoryName();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_OpenDirectoryName(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[4] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ExtensionManager_OpenDirectoryName",0,3,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    return _wrap_ExtensionManager_OpenDirectoryName__SWIG_2(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_ExtensionManager_OpenDirectoryName__SWIG_1(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_ExtensionManager_OpenDirectoryName__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ExtensionManager_OpenDirectoryName'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IExtensionManager::OpenDirectoryName(rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::OpenDirectoryName(rdcstr const &)\n"
    "    IExtensionManager::OpenDirectoryName()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_SaveFileName__SWIG_0(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  rdcstr *arg4 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  rdcstr temp4 ;
  rdcstr result;
  
  if ((nobjs < 4) || (nobjs > 4)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_SaveFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_SaveFileName' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_SaveFileName' argument 3 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg4, &temp4);
    
    int res = ConvertFromPy(swig_obj[3], indirect(arg4));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_SaveFileName' argument 4 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->SaveFileName((rdcstr const &)*arg2,(rdcstr const &)*arg3,(rdcstr const &)*arg4);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_SaveFileName__SWIG_1(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  rdcstr *arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr temp3 ;
  rdcstr result;
  
  if ((nobjs < 3) || (nobjs > 3)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_SaveFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_SaveFileName' argument 2 of type 'rdcstr'"); 
    }
  }
  {
    tempset(arg3, &temp3);
    
    int res = ConvertFromPy(swig_obj[2], indirect(arg3));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_SaveFileName' argument 3 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->SaveFileName((rdcstr const &)*arg2,(rdcstr const &)*arg3);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_SaveFileName__SWIG_2(PyObject *self, int nobjs, PyObject **swig_obj) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  rdcstr *arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr temp2 ;
  rdcstr result;
  
  if ((nobjs < 2) || (nobjs > 2)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_SaveFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  {
    tempset(arg2, &temp2);
    
    int res = ConvertFromPy(swig_obj[1], indirect(arg2));
    if(!SWIG_IsOK(res))
    {
      SWIG_exception_fail(SWIG_ArgError(res), "in method 'ExtensionManager_SaveFileName' argument 2 of type 'rdcstr'"); 
    }
  }
  result = (arg1)->SaveFileName((rdcstr const &)*arg2);
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_SaveFileName__SWIG_3(PyObject *self, int nobjs, PyObject **SWIGUNUSEDPARM(swig_obj)) {
  PyObject *resultobj = 0;
  IExtensionManager *arg1 = (IExtensionManager *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  rdcstr result;
  
  if ((nobjs < 1) || (nobjs > 1)) SWIG_fail;
  res1 = SWIG_ConvertPtr(self, &argp1,SWIGTYPE_p_IExtensionManager, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ExtensionManager_SaveFileName" "', argument " "1"" of type '" "IExtensionManager *""'"); 
  }
  arg1 = reinterpret_cast< IExtensionManager * >(argp1);
  result = (arg1)->SaveFileName();
  {
    resultobj = ConvertToPy(indirect(result));
  }
  return resultobj;
fail:
  return NULL;
}


SWIGINTERN PyObject *_wrap_ExtensionManager_SaveFileName(PyObject *self, PyObject *args) {
  Py_ssize_t argc;
  PyObject *argv[5] = {
    0
  };
  
  if (!(argc = SWIG_Python_UnpackTuple(args,"ExtensionManager_SaveFileName",0,4,argv+1))) SWIG_fail;
  argv[0] = self;
  if (argc == 1) {
    return _wrap_ExtensionManager_SaveFileName__SWIG_3(self, argc, argv);
  }
  if (argc == 2) {
    return _wrap_ExtensionManager_SaveFileName__SWIG_2(self, argc, argv);
  }
  if (argc == 3) {
    return _wrap_ExtensionManager_SaveFileName__SWIG_1(self, argc, argv);
  }
  if (argc == 4) {
    return _wrap_ExtensionManager_SaveFileName__SWIG_0(self, argc, argv);
  }
  
fail:
  SWIG_SetErrorMsg(PyExc_NotImplementedError,"Wrong number or type of arguments for overloaded function 'ExtensionManager_SaveFileName'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    IExtensionManager::SaveFileName(rdcstr const &,rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::SaveFileName(rdcstr const &,rdcstr const &)\n"
    "    IExtensionManager::SaveFileName(rdcstr const &)\n"
    "    IExtensionManager::SaveFileName()\n");
  return 0;
}


SWIGINTERN PyObject *_wrap_delete_rdcarray_of_EventBookmark(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_EventBookmark",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_EventBookmark' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_EventBookmark' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  rdcarray< EventBookmark > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark___eq__' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark___eq__' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark___eq__' argument 2 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark___eq__' argument 2 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< EventBookmark > const *)arg1)->operator ==((rdcarray< EventBookmark > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  rdcarray< EventBookmark > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark___ne__' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark___ne__' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark___ne__' argument 2 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark___ne__' argument 2 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< EventBookmark > const *)arg1)->operator !=((rdcarray< EventBookmark > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  rdcarray< EventBookmark > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark___lt__' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark___lt__' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark___lt__' argument 2 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark___lt__' argument 2 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< EventBookmark > const *)arg1)->operator <((rdcarray< EventBookmark > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_resize_for_index' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_resize_for_index' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_EventBookmark_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  size_t arg2 ;
  EventBookmark *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_EventBookmark_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_fill' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_fill' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_EventBookmark_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_EventBookmark,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_EventBookmark_fill" "', argument " "3"" of type '" "EventBookmark const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rdcarray_of_EventBookmark_fill" "', argument " "3"" of type '" "EventBookmark const &""'"); 
  }
  arg3 = reinterpret_cast< EventBookmark * >(argp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(EventBookmark const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_EventBookmark_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_pop_back' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_pop_back' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  SwigValueWrapper< std::function< bool (EventBookmark const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_removeIf' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_removeIf' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (EventBookmark const &) >>("rdcarray_of_EventBookmark_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  SwigValueWrapper< std::function< bool (EventBookmark const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_removeOneIf' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_removeOneIf' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (EventBookmark const &) >>("rdcarray_of_EventBookmark_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_append' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_append' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_EventBookmark_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_clear' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_clear' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_EventBookmark_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_insert' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_insert' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_EventBookmark_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_pop' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_pop' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_EventBookmark_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_sort' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_sort' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_EventBookmark_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_EventBookmark_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_copy' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_copy' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_EventBookmark_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_reverse' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_reverse' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_EventBookmark_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_index' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_index' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_count' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_count' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_extend' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_extend' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_EventBookmark_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< EventBookmark > *arg1 = (rdcarray< EventBookmark > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< EventBookmark >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_EventBookmark_remove' argument 1 of type 'rdcarray< EventBookmark >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_EventBookmark_remove' argument 1 of type 'rdcarray< EventBookmark >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_EventBookmark_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_EventBookmark) /* defines _wrap_delete_rdcarray_of_EventBookmark_destructor_closure */


PyObject *repr_rdcarray_of_EventBookmark(PyObject *self)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_EventBookmark(PyObject *self, Py_ssize_t idx)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_EventBookmark(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_EventBookmark(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_EventBookmark(PyObject *self, PyObject *idx)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_EventBookmark(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_EventBookmark(PyObject *self, PyObject *vals)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_EventBookmark(PyObject *self, Py_ssize_t count)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_EventBookmark(PyObject *self, PyObject *vals)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_EventBookmark(PyObject *self, Py_ssize_t count)
{
  rdcarray<EventBookmark> *thisptr = array_thisptr<rdcarray<EventBookmark>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_ShaderProcessingTool(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_ShaderProcessingTool",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_ShaderProcessingTool' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_ShaderProcessingTool' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  rdcarray< ShaderProcessingTool > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool___eq__' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool___eq__' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool___eq__' argument 2 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool___eq__' argument 2 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ShaderProcessingTool > const *)arg1)->operator ==((rdcarray< ShaderProcessingTool > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  rdcarray< ShaderProcessingTool > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool___ne__' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool___ne__' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool___ne__' argument 2 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool___ne__' argument 2 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ShaderProcessingTool > const *)arg1)->operator !=((rdcarray< ShaderProcessingTool > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  rdcarray< ShaderProcessingTool > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool___lt__' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool___lt__' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool___lt__' argument 2 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool___lt__' argument 2 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ShaderProcessingTool > const *)arg1)->operator <((rdcarray< ShaderProcessingTool > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_resize_for_index' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_resize_for_index' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_ShaderProcessingTool_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  size_t arg2 ;
  ShaderProcessingTool *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ShaderProcessingTool_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_fill' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_fill' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_ShaderProcessingTool_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ShaderProcessingTool,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_ShaderProcessingTool_fill" "', argument " "3"" of type '" "ShaderProcessingTool const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rdcarray_of_ShaderProcessingTool_fill" "', argument " "3"" of type '" "ShaderProcessingTool const &""'"); 
  }
  arg3 = reinterpret_cast< ShaderProcessingTool * >(argp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(ShaderProcessingTool const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ShaderProcessingTool_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_pop_back' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_pop_back' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  SwigValueWrapper< std::function< bool (ShaderProcessingTool const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_removeIf' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_removeIf' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (ShaderProcessingTool const &) >>("rdcarray_of_ShaderProcessingTool_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  SwigValueWrapper< std::function< bool (ShaderProcessingTool const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_removeOneIf' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_removeOneIf' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (ShaderProcessingTool const &) >>("rdcarray_of_ShaderProcessingTool_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_append' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_append' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ShaderProcessingTool_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_clear' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_clear' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ShaderProcessingTool_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_insert' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_insert' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_ShaderProcessingTool_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_pop' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_pop' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_ShaderProcessingTool_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_sort' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_sort' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_ShaderProcessingTool_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ShaderProcessingTool_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_copy' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_copy' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ShaderProcessingTool_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_reverse' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_reverse' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_ShaderProcessingTool_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_index' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_index' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_count' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_count' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_extend' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_extend' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ShaderProcessingTool_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ShaderProcessingTool > *arg1 = (rdcarray< ShaderProcessingTool > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ShaderProcessingTool >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ShaderProcessingTool_remove' argument 1 of type 'rdcarray< ShaderProcessingTool >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ShaderProcessingTool_remove' argument 1 of type 'rdcarray< ShaderProcessingTool >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ShaderProcessingTool_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_ShaderProcessingTool) /* defines _wrap_delete_rdcarray_of_ShaderProcessingTool_destructor_closure */


PyObject *repr_rdcarray_of_ShaderProcessingTool(PyObject *self)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_ShaderProcessingTool(PyObject *self, Py_ssize_t idx)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_ShaderProcessingTool(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_ShaderProcessingTool(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_ShaderProcessingTool(PyObject *self, PyObject *idx)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_ShaderProcessingTool(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_ShaderProcessingTool(PyObject *self, PyObject *vals)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_ShaderProcessingTool(PyObject *self, Py_ssize_t count)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_ShaderProcessingTool(PyObject *self, PyObject *vals)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_ShaderProcessingTool(PyObject *self, Py_ssize_t count)
{
  rdcarray<ShaderProcessingTool> *thisptr = array_thisptr<rdcarray<ShaderProcessingTool>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_rdcstrpair(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_rdcstrpair",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_rdcstrpair' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_rdcstrpair' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  rdcarray< rdcpair< rdcstr,rdcstr > > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair___eq__' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair___eq__' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcpair< rdcstr,rdcstr > >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair___eq__' argument 2 of type 'rdcarray< rdcpair< rdcstr,rdcstr > >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair___eq__' argument 2 of type 'rdcarray< rdcpair< rdcstr,rdcstr > >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< rdcstrpair > const *)arg1)->operator ==((rdcarray< rdcpair< rdcstr,rdcstr > > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  rdcarray< rdcpair< rdcstr,rdcstr > > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair___ne__' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair___ne__' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcpair< rdcstr,rdcstr > >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair___ne__' argument 2 of type 'rdcarray< rdcpair< rdcstr,rdcstr > >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair___ne__' argument 2 of type 'rdcarray< rdcpair< rdcstr,rdcstr > >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< rdcstrpair > const *)arg1)->operator !=((rdcarray< rdcpair< rdcstr,rdcstr > > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  rdcarray< rdcpair< rdcstr,rdcstr > > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair___lt__' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair___lt__' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< rdcpair< rdcstr,rdcstr > >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair___lt__' argument 2 of type 'rdcarray< rdcpair< rdcstr,rdcstr > >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair___lt__' argument 2 of type 'rdcarray< rdcpair< rdcstr,rdcstr > >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< rdcstrpair > const *)arg1)->operator <((rdcarray< rdcpair< rdcstr,rdcstr > > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_resize_for_index' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_resize_for_index' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_rdcstrpair_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  size_t arg2 ;
  rdcpair< rdcstr,rdcstr > *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_rdcstrpair_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_fill' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_fill' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_rdcstrpair_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_rdcpairT_rdcstr_rdcstr_t,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_rdcstrpair_fill" "', argument " "3"" of type '" "rdcpair< rdcstr,rdcstr > const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rdcarray_of_rdcstrpair_fill" "', argument " "3"" of type '" "rdcpair< rdcstr,rdcstr > const &""'"); 
  }
  arg3 = reinterpret_cast< rdcpair< rdcstr,rdcstr > * >(argp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(rdcpair< rdcstr,rdcstr > const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_rdcstrpair_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_pop_back' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_pop_back' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  std::function< bool (rdcpair< rdcstr,rdcstr > const &) > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_removeIf' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_removeIf' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (rdcpair< rdcstr,rdcstr > const &) >>("rdcarray_of_rdcstrpair_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  std::function< bool (rdcpair< rdcstr,rdcstr > const &) > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_removeOneIf' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_removeOneIf' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (rdcpair< rdcstr,rdcstr > const &) >>("rdcarray_of_rdcstrpair_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_append' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_append' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_rdcstrpair_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_clear' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_clear' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_rdcstrpair_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_insert' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_insert' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_rdcstrpair_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_pop' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_pop' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_rdcstrpair_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_sort' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_sort' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_rdcstrpair_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_rdcstrpair_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_copy' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_copy' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_rdcstrpair_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_reverse' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_reverse' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_rdcstrpair_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_index' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_index' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_count' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_count' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_extend' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_extend' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_rdcstrpair_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< rdcstrpair > *arg1 = (rdcarray< rdcstrpair > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< rdcstrpair >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_rdcstrpair_remove' argument 1 of type 'rdcarray< rdcstrpair >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_rdcstrpair_remove' argument 1 of type 'rdcarray< rdcstrpair >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_rdcstrpair_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_rdcstrpair) /* defines _wrap_delete_rdcarray_of_rdcstrpair_destructor_closure */


PyObject *repr_rdcarray_of_rdcstrpair(PyObject *self)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_rdcstrpair(PyObject *self, Py_ssize_t idx)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_rdcstrpair(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_rdcstrpair(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_rdcstrpair(PyObject *self, PyObject *idx)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_rdcstrpair(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_rdcstrpair(PyObject *self, PyObject *vals)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_rdcstrpair(PyObject *self, Py_ssize_t count)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_rdcstrpair(PyObject *self, PyObject *vals)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_rdcstrpair(PyObject *self, Py_ssize_t count)
{
  rdcarray<rdcstrpair> *thisptr = array_thisptr<rdcarray<rdcstrpair>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_BugReport(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_BugReport",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_BugReport' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_BugReport' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  rdcarray< BugReport > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport___eq__' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport___eq__' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport___eq__' argument 2 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport___eq__' argument 2 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< BugReport > const *)arg1)->operator ==((rdcarray< BugReport > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  rdcarray< BugReport > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport___ne__' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport___ne__' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport___ne__' argument 2 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport___ne__' argument 2 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< BugReport > const *)arg1)->operator !=((rdcarray< BugReport > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  rdcarray< BugReport > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport___lt__' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport___lt__' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport___lt__' argument 2 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport___lt__' argument 2 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< BugReport > const *)arg1)->operator <((rdcarray< BugReport > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_resize_for_index' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_resize_for_index' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_BugReport_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  size_t arg2 ;
  BugReport *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_BugReport_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_fill' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_fill' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_BugReport_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_BugReport,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_BugReport_fill" "', argument " "3"" of type '" "BugReport const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rdcarray_of_BugReport_fill" "', argument " "3"" of type '" "BugReport const &""'"); 
  }
  arg3 = reinterpret_cast< BugReport * >(argp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(BugReport const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_BugReport_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_pop_back' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_pop_back' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  SwigValueWrapper< std::function< bool (BugReport const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_removeIf' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_removeIf' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (BugReport const &) >>("rdcarray_of_BugReport_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  SwigValueWrapper< std::function< bool (BugReport const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_removeOneIf' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_removeOneIf' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (BugReport const &) >>("rdcarray_of_BugReport_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_append' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_append' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_BugReport_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_clear' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_clear' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_BugReport_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_insert' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_insert' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_BugReport_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_pop' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_pop' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_BugReport_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_sort' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_sort' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_BugReport_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_BugReport_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_copy' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_copy' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_BugReport_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_reverse' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_reverse' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_BugReport_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_index' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_index' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_count' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_count' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_extend' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_extend' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_BugReport_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< BugReport > *arg1 = (rdcarray< BugReport > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< BugReport >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_BugReport_remove' argument 1 of type 'rdcarray< BugReport >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_BugReport_remove' argument 1 of type 'rdcarray< BugReport >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_BugReport_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_BugReport) /* defines _wrap_delete_rdcarray_of_BugReport_destructor_closure */


PyObject *repr_rdcarray_of_BugReport(PyObject *self)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_BugReport(PyObject *self, Py_ssize_t idx)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_BugReport(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_BugReport(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_BugReport(PyObject *self, PyObject *idx)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_BugReport(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_BugReport(PyObject *self, PyObject *vals)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_BugReport(PyObject *self, Py_ssize_t count)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_BugReport(PyObject *self, PyObject *vals)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_BugReport(PyObject *self, Py_ssize_t count)
{
  rdcarray<BugReport> *thisptr = array_thisptr<rdcarray<BugReport>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_ExtensionMetadata(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_ExtensionMetadata",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_ExtensionMetadata' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_ExtensionMetadata' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  rdcarray< ExtensionMetadata > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata___eq__' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata___eq__' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata___eq__' argument 2 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata___eq__' argument 2 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ExtensionMetadata > const *)arg1)->operator ==((rdcarray< ExtensionMetadata > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  rdcarray< ExtensionMetadata > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata___ne__' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata___ne__' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata___ne__' argument 2 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata___ne__' argument 2 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ExtensionMetadata > const *)arg1)->operator !=((rdcarray< ExtensionMetadata > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  rdcarray< ExtensionMetadata > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata___lt__' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata___lt__' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata___lt__' argument 2 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata___lt__' argument 2 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ExtensionMetadata > const *)arg1)->operator <((rdcarray< ExtensionMetadata > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_resize_for_index' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_resize_for_index' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_ExtensionMetadata_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  size_t arg2 ;
  ExtensionMetadata *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ExtensionMetadata_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_fill' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_fill' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_ExtensionMetadata_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ExtensionMetadata,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_ExtensionMetadata_fill" "', argument " "3"" of type '" "ExtensionMetadata const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rdcarray_of_ExtensionMetadata_fill" "', argument " "3"" of type '" "ExtensionMetadata const &""'"); 
  }
  arg3 = reinterpret_cast< ExtensionMetadata * >(argp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(ExtensionMetadata const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ExtensionMetadata_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_pop_back' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_pop_back' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  SwigValueWrapper< std::function< bool (ExtensionMetadata const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_removeIf' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_removeIf' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (ExtensionMetadata const &) >>("rdcarray_of_ExtensionMetadata_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  SwigValueWrapper< std::function< bool (ExtensionMetadata const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_removeOneIf' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_removeOneIf' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (ExtensionMetadata const &) >>("rdcarray_of_ExtensionMetadata_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_append' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_append' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ExtensionMetadata_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_clear' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_clear' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ExtensionMetadata_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_insert' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_insert' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_ExtensionMetadata_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_pop' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_pop' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_ExtensionMetadata_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_sort' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_sort' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_ExtensionMetadata_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ExtensionMetadata_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_copy' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_copy' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ExtensionMetadata_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_reverse' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_reverse' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_ExtensionMetadata_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_index' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_index' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_count' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_count' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_extend' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_extend' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ExtensionMetadata_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ExtensionMetadata > *arg1 = (rdcarray< ExtensionMetadata > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ExtensionMetadata >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ExtensionMetadata_remove' argument 1 of type 'rdcarray< ExtensionMetadata >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ExtensionMetadata_remove' argument 1 of type 'rdcarray< ExtensionMetadata >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ExtensionMetadata_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_ExtensionMetadata) /* defines _wrap_delete_rdcarray_of_ExtensionMetadata_destructor_closure */


PyObject *repr_rdcarray_of_ExtensionMetadata(PyObject *self)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_ExtensionMetadata(PyObject *self, Py_ssize_t idx)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_ExtensionMetadata(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_ExtensionMetadata(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_ExtensionMetadata(PyObject *self, PyObject *idx)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_ExtensionMetadata(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_ExtensionMetadata(PyObject *self, PyObject *vals)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_ExtensionMetadata(PyObject *self, Py_ssize_t count)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_ExtensionMetadata(PyObject *self, PyObject *vals)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_ExtensionMetadata(PyObject *self, Py_ssize_t count)
{
  rdcarray<ExtensionMetadata> *thisptr = array_thisptr<rdcarray<ExtensionMetadata>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_DialogButton(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_DialogButton",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_DialogButton' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_DialogButton' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  rdcarray< DialogButton > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton___eq__' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton___eq__' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton___eq__' argument 2 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton___eq__' argument 2 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< DialogButton > const *)arg1)->operator ==((rdcarray< DialogButton > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  rdcarray< DialogButton > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton___ne__' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton___ne__' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton___ne__' argument 2 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton___ne__' argument 2 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< DialogButton > const *)arg1)->operator !=((rdcarray< DialogButton > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  rdcarray< DialogButton > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton___lt__' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton___lt__' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton___lt__' argument 2 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton___lt__' argument 2 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< DialogButton > const *)arg1)->operator <((rdcarray< DialogButton > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_resize_for_index' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_resize_for_index' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_DialogButton_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  size_t arg2 ;
  DialogButton *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  int val3 ;
  int ecode3 ;
  DialogButton temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_DialogButton_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_fill' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_fill' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_DialogButton_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  ecode3 = SWIG_AsVal_int (swig_obj[1], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_DialogButton_fill" "', argument " "3"" of type '" "DialogButton const &""'");
  } else {
    temp3 = static_cast< DialogButton >(val3);
    arg3 = &temp3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(DialogButton const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_DialogButton_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_pop_back' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_pop_back' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  std::function< bool (DialogButton const &) > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_removeIf' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_removeIf' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (DialogButton const &) >>("rdcarray_of_DialogButton_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  std::function< bool (DialogButton const &) > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_removeOneIf' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_removeOneIf' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (DialogButton const &) >>("rdcarray_of_DialogButton_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_append' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_append' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_DialogButton_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_clear' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_clear' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_DialogButton_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_insert' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_insert' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_DialogButton_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_pop' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_pop' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_DialogButton_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_sort' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_sort' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_DialogButton_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_DialogButton_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_copy' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_copy' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_DialogButton_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_reverse' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_reverse' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_DialogButton_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_index' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_index' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_count' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_count' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_extend' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_extend' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_DialogButton_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< DialogButton > *arg1 = (rdcarray< DialogButton > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< DialogButton >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_DialogButton_remove' argument 1 of type 'rdcarray< DialogButton >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_DialogButton_remove' argument 1 of type 'rdcarray< DialogButton >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_DialogButton_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_DialogButton) /* defines _wrap_delete_rdcarray_of_DialogButton_destructor_closure */


PyObject *repr_rdcarray_of_DialogButton(PyObject *self)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_DialogButton(PyObject *self, Py_ssize_t idx)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_DialogButton(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_DialogButton(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_DialogButton(PyObject *self, PyObject *idx)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_DialogButton(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_DialogButton(PyObject *self, PyObject *vals)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_DialogButton(PyObject *self, Py_ssize_t count)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_DialogButton(PyObject *self, PyObject *vals)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_DialogButton(PyObject *self, Py_ssize_t count)
{
  rdcarray<DialogButton> *thisptr = array_thisptr<rdcarray<DialogButton>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_RemoteHost(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_RemoteHost",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_RemoteHost' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_RemoteHost' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  rdcarray< RemoteHost > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost___eq__' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost___eq__' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost___eq__' argument 2 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost___eq__' argument 2 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< RemoteHost > const *)arg1)->operator ==((rdcarray< RemoteHost > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  rdcarray< RemoteHost > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost___ne__' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost___ne__' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost___ne__' argument 2 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost___ne__' argument 2 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< RemoteHost > const *)arg1)->operator !=((rdcarray< RemoteHost > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  rdcarray< RemoteHost > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost___lt__' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost___lt__' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost___lt__' argument 2 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost___lt__' argument 2 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< RemoteHost > const *)arg1)->operator <((rdcarray< RemoteHost > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_resize_for_index' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_resize_for_index' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_RemoteHost_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  size_t arg2 ;
  RemoteHost *arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_RemoteHost_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_fill' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_fill' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_RemoteHost_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_RemoteHost,  0  | 0);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_RemoteHost_fill" "', argument " "3"" of type '" "RemoteHost const &""'"); 
  }
  if (!argp3) {
    SWIG_exception_fail(SWIG_ValueError, "invalid null reference " "in method '" "rdcarray_of_RemoteHost_fill" "', argument " "3"" of type '" "RemoteHost const &""'"); 
  }
  arg3 = reinterpret_cast< RemoteHost * >(argp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(RemoteHost const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_RemoteHost_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_pop_back' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_pop_back' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  SwigValueWrapper< std::function< bool (RemoteHost const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_removeIf' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_removeIf' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (RemoteHost const &) >>("rdcarray_of_RemoteHost_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  SwigValueWrapper< std::function< bool (RemoteHost const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_removeOneIf' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_removeOneIf' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (RemoteHost const &) >>("rdcarray_of_RemoteHost_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_append' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_append' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_RemoteHost_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_clear' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_clear' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_RemoteHost_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_insert' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_insert' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_RemoteHost_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_pop' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_pop' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_RemoteHost_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_sort' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_sort' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_RemoteHost_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_RemoteHost_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_copy' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_copy' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_RemoteHost_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_reverse' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_reverse' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_RemoteHost_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_index' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_index' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_count' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_count' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_extend' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_extend' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_RemoteHost_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< RemoteHost > *arg1 = (rdcarray< RemoteHost > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< RemoteHost >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_RemoteHost_remove' argument 1 of type 'rdcarray< RemoteHost >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_RemoteHost_remove' argument 1 of type 'rdcarray< RemoteHost >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_RemoteHost_Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_RemoteHost) /* defines _wrap_delete_rdcarray_of_RemoteHost_destructor_closure */


PyObject *repr_rdcarray_of_RemoteHost(PyObject *self)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_RemoteHost(PyObject *self, Py_ssize_t idx)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_RemoteHost(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_RemoteHost(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_RemoteHost(PyObject *self, PyObject *idx)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_RemoteHost(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_RemoteHost(PyObject *self, PyObject *vals)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_RemoteHost(PyObject *self, Py_ssize_t count)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_RemoteHost(PyObject *self, PyObject *vals)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_RemoteHost(PyObject *self, Py_ssize_t count)
{
  rdcarray<RemoteHost> *thisptr = array_thisptr<rdcarray<RemoteHost>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

SWIGINTERN PyObject *_wrap_delete_rdcarray_of_ptr_ICaptureViewer(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"delete_rdcarray_of_ptr_ICaptureViewer",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'delete_rdcarray_of_ptr_ICaptureViewer' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'delete_rdcarray_of_ptr_ICaptureViewer' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  delete arg1;
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer___eq__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  rdcarray< ICaptureViewer * > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer___eq__' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer___eq__' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer___eq__' argument 2 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer___eq__' argument 2 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ICaptureViewer * > const *)arg1)->operator ==((rdcarray< ICaptureViewer * > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer___ne__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  rdcarray< ICaptureViewer * > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer___ne__' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer___ne__' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer___ne__' argument 2 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer___ne__' argument 2 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ICaptureViewer * > const *)arg1)->operator !=((rdcarray< ICaptureViewer * > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer___lt__(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  rdcarray< ICaptureViewer * > *arg2 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  unsigned char tempmem2[32] ;
  bool wasSelf2 = false ;
  PyObject *swig_obj[2] ;
  bool result;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer___lt__' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer___lt__' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    using array_type = std::remove_pointer<decltype(arg2)>::type;
    
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem2) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg2, tempmem2);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(swig_obj[0], indirect(arg2), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer___lt__' argument 2 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer___lt__' argument 2 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg2); 
  }
  result = (bool)((rdcarray< ICaptureViewer * > const *)arg1)->operator <((rdcarray< ICaptureViewer * > const &)*arg2);
  resultobj = SWIG_From_bool(static_cast< bool >(result));
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_resize_for_index(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  size_t arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_resize_for_index' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_resize_for_index' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_ptr_ICaptureViewer_resize_for_index" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->resize_for_index(arg2);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_fill(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  size_t arg2 ;
  ICaptureViewer **arg3 = 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  size_t val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  ICaptureViewer *temp3 ;
  PyObject *swig_obj[3] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ptr_ICaptureViewer_fill",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_fill' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_fill' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  ecode2 = SWIG_AsVal_size_t(swig_obj[0], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "rdcarray_of_ptr_ICaptureViewer_fill" "', argument " "2"" of type '" "size_t""'");
  } 
  arg2 = static_cast< size_t >(val2);
  res3 = SWIG_ConvertPtr(swig_obj[1], &argp3, SWIGTYPE_p_ICaptureViewer, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "rdcarray_of_ptr_ICaptureViewer_fill" "', argument " "3"" of type '" "ICaptureViewer *""'"); 
  }
  temp3 = reinterpret_cast< ICaptureViewer * >(argp3);
  arg3 = reinterpret_cast< ICaptureViewer ** >(&temp3);
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->fill(arg2,(ICaptureViewer *const &)*arg3);
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_pop_back(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ptr_ICaptureViewer_pop_back",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_pop_back' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_pop_back' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->pop_back();
  resultobj = SWIG_Py_Void();
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_removeIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  SwigValueWrapper< std::function< bool (ICaptureViewer *const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_removeIf' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_removeIf' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (ICaptureViewer *const &) >>("rdcarray_of_ptr_ICaptureViewer_removeIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_removeOneIf(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  SwigValueWrapper< std::function< bool (ICaptureViewer *const &) > > arg2 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  StackExceptionHandler exHandle2 ;
  PyObject *swig_obj[2] ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_removeOneIf' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_removeOneIf' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    PyObject *func = swig_obj[0];
    arg2 = ConvertFunc<std::function< bool (ICaptureViewer *const &) >>("rdcarray_of_ptr_ICaptureViewer_removeOneIf", func, exHandle2);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  (arg1)->removeOneIf(arg2);
  resultobj = SWIG_Py_Void();
  {
    if(exHandle2.data().failFlag) {
      PyErr_Restore(exHandle2.data().exObj, exHandle2.data().valueObj, exHandle2.data().tracebackObj);
      SWIG_fail;
    }
  }
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_append(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_append' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_append' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__append(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_clear(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ptr_ICaptureViewer_clear",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_clear' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_clear' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__clear(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_insert(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[3] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ptr_ICaptureViewer_insert",2,2,swig_obj)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_insert' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_insert' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  arg3 = swig_obj[1];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__insert(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_pop(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  char *  kwnames[] = {
    (char *) "index", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|O:rdcarray_of_ptr_ICaptureViewer_pop",kwnames,&obj1)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_pop' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_pop' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__pop(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_sort(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) NULL ;
  bool arg3 = (bool) false ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  bool val3 ;
  int ecode3 = 0 ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  char *  kwnames[] = {
    (char *) "key",(char *) "reverse", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"|OO:rdcarray_of_ptr_ICaptureViewer_sort",kwnames,&obj1,&obj2)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_sort' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_sort' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  if (obj1) {
    arg2 = obj1;
  }
  if (obj2) {
    ecode3 = SWIG_AsVal_bool(obj2, &val3);
    if (!SWIG_IsOK(ecode3)) {
      SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "rdcarray_of_ptr_ICaptureViewer_sort" "', argument " "3"" of type '" "bool""'");
    } 
    arg3 = static_cast< bool >(val3);
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__sort(arg1,arg2,arg3);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_copy(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ptr_ICaptureViewer_copy",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_copy' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_copy' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__copy(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_reverse(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[1] ;
  PyObject *result = 0 ;
  
  if (!SWIG_Python_UnpackTuple(args,"rdcarray_of_ptr_ICaptureViewer_reverse",0,0,0)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_reverse' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_reverse' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__reverse(arg1);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_index(PyObject *self, PyObject *args, PyObject *kwargs) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  PyObject *arg3 = (PyObject *) NULL ;
  PyObject *arg4 = (PyObject *) NULL ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject * obj1 = 0 ;
  PyObject * obj2 = 0 ;
  PyObject * obj3 = 0 ;
  char *  kwnames[] = {
    (char *) "item",(char *) "start",(char *) "end", NULL 
  };
  PyObject *result = 0 ;
  
  if (!PyArg_ParseTupleAndKeywords(args,kwargs,(char *)"O|OO:rdcarray_of_ptr_ICaptureViewer_index",kwnames,&obj1,&obj2,&obj3)) SWIG_fail;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_index' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_index' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = obj1;
  if (obj2) {
    arg3 = obj2;
  }
  if (obj3) {
    arg4 = obj3;
  }
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__index(arg1,arg2,arg3,arg4);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_count(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_count' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_count' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__count(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_extend(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_extend' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_extend' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__extend(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGINTERN PyObject *_wrap_rdcarray_of_ptr_ICaptureViewer_remove(PyObject *self, PyObject *args) {
  PyObject *resultobj = 0;
  rdcarray< ICaptureViewer * > *arg1 = (rdcarray< ICaptureViewer * > *) 0 ;
  PyObject *arg2 = (PyObject *) 0 ;
  unsigned char tempmem1[32] ;
  bool wasSelf1 = false ;
  PyObject *swig_obj[2] ;
  PyObject *result = 0 ;
  
  if (!args) SWIG_fail;
  swig_obj[0] = args;
  {
    using array_type = std::remove_pointer<decltype(arg1)>::type;
    
    // don't convert 'self', leave as-is so we can modify by reference. Everything else needs to be
    // converted/copied to allow passing lists (or any sequence) python objects to a function
    // expecting a particular C++ array type
    constexpr bool isSelf = STR_EQ(self, self);
    wasSelf1 = isSelf;
    if(isSelf)
    {
      // we use an indirect dispatch class here (see self_dispatch) to avoid the need to instantiate
      // the conversion template for types we don't care about
      arg1 = self_dispatch<isSelf>::getthis<array_type>(self);
    }
    else
    {
      // convert the sequence by value using ConvertFromPy
      static_assert(sizeof(tempmem1) >= sizeof(array_type), "not enough temp space for rdcarray< ICaptureViewer * >");
      
      tempalloc(arg1, tempmem1);
      
      int failIdx = 0;
      int res = TypeConversion<array_type>::ConvertFromPy(self, indirect(arg1), &failIdx);
      
      if(!SWIG_IsOK(res))
      {
        if(res == SWIG_TypeError)
        {
          SWIG_exception_fail(SWIG_ArgError(res), "in method 'rdcarray_of_ptr_ICaptureViewer_remove' argument 1 of type 'rdcarray< ICaptureViewer * >'"); 
        }
        else
        {
          snprintf(convert_error, sizeof(convert_error)-1, "in method 'rdcarray_of_ptr_ICaptureViewer_remove' argument 1 of type 'rdcarray< ICaptureViewer * >', decoding element %d", failIdx);
          SWIG_exception_fail(SWIG_ArgError(res), convert_error);
        }
      }
    }
  }
  arg2 = swig_obj[0];
  {
    add_your_use_of_rdcarray_to_swig_interface (arg1); 
  }
  result = (PyObject *)rdcarray_Sl_ICaptureViewer_Sm__Sg__remove(arg1,arg2);
  resultobj = result;
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return resultobj;
fail:
  {
    // if we converted the sequence by-value, then destroy it again
    if(!wasSelf1)
    tempdealloc(arg1);
  }
  return NULL;
}


SWIGPY_DESTRUCTOR_CLOSURE(_wrap_delete_rdcarray_of_ptr_ICaptureViewer) /* defines _wrap_delete_rdcarray_of_ptr_ICaptureViewer_destructor_closure */


PyObject *repr_rdcarray_of_ptr_ICaptureViewer(PyObject *self)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  return array_repr(thisptr);
}

PyObject *getitem_rdcarray_of_ptr_ICaptureViewer(PyObject *self, Py_ssize_t idx)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  return array_getitem(thisptr, idx);
}

int setitem_rdcarray_of_ptr_ICaptureViewer(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return -1;

  return array_setitem(thisptr, idx, val);
}

Py_ssize_t length_rdcarray_of_ptr_ICaptureViewer(PyObject *self, Py_ssize_t idx, PyObject *val)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return -1;

  return array_len(thisptr);
}

PyObject *getsubscript_rdcarray_of_ptr_ICaptureViewer(PyObject *self, PyObject *idx)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  return array_getsubscript(thisptr, idx);
}

int setsubscript_rdcarray_of_ptr_ICaptureViewer(PyObject *self, PyObject *idx, PyObject *val)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return -1;

  return array_setsubscript(thisptr, idx, val);
}

PyObject *concat_rdcarray_of_ptr_ICaptureViewer(PyObject *self, PyObject *vals)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  return array_concat(thisptr, vals);
}

PyObject *repeat_rdcarray_of_ptr_ICaptureViewer(PyObject *self, Py_ssize_t count)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  return array_repeat(thisptr, count);
}

PyObject *selfconcat_rdcarray_of_ptr_ICaptureViewer(PyObject *self, PyObject *vals)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfconcat(thisptr, vals);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}

PyObject *selfrepeat_rdcarray_of_ptr_ICaptureViewer(PyObject *self, Py_ssize_t count)
{
  rdcarray<ICaptureViewer *> *thisptr = array_thisptr<rdcarray<ICaptureViewer *>>(self);

  if(!thisptr)
    return NULL;

  PyObject *ret = array_selfrepeat(thisptr, count);

  if(ret)
  {
    Py_DECREF(ret);
    return Py_NewRef(self);
  }

  return NULL;
}



PyObject *WrapBareQWidget(QWidget *widget)
{
  return SWIG_InternalNewPointerObj(SWIG_as_voidptr(widget), SWIGTYPE_p_QWidget, 0);
}

QWidget *UnwrapBareQWidget(PyObject *obj)
{
  QWidget *ret = NULL;
  int res = 0;

  res = SWIG_ConvertPtr(obj, (void **)&ret,SWIGTYPE_p_QWidget, 0);
  if(!SWIG_IsOK(res))
  {
    return NULL;
  }

  return ret;
}

PythonCaptureViewer::PythonCaptureViewer(PyObject *s)
{
  self = s;
  Py_INCREF(self);
  
  StackExceptionHandler ex;

  PyObject *meth = NULL;

  {
    meth = PyObject_GetAttrString(self, "OnCaptureLoaded");
    if(PyCFunction_Check(meth) && PyCFunction_GetFunction(meth) == &_wrap_CaptureViewer_OnCaptureLoaded)
    {
      Py_XDECREF(meth);
      meth = NULL;
    }

    if(meth)
    {
      m_OnCaptureLoaded = ConvertFunc<std::function<void()>>("ICaptureViewer::OnCaptureLoaded", meth, ex);
      Py_XDECREF(meth);
    }
  }

  {
    meth = PyObject_GetAttrString(self, "OnCaptureClosed");
    if(PyCFunction_Check(meth) && PyCFunction_GetFunction(meth) == &_wrap_CaptureViewer_OnCaptureClosed)
    {
      Py_XDECREF(meth);
      meth = NULL;
    }

    if(meth)
    {
      m_OnCaptureClosed = ConvertFunc<std::function<void()>>("ICaptureViewer::OnCaptureClosed", meth, ex);
      Py_XDECREF(meth);
    }
  }

  {
    meth = PyObject_GetAttrString(self, "OnSelectedEventChanged");
    if(PyCFunction_Check(meth) && PyCFunction_GetFunction(meth) == &_wrap_CaptureViewer_OnSelectedEventChanged)
    {
      Py_XDECREF(meth);
      meth = NULL;
    }

    if(meth)
    {
      m_OnSelectedEventChanged = ConvertFunc<std::function<void(uint32_t)>>("ICaptureViewer::OnSelectedEventChanged", meth, ex);
      Py_XDECREF(meth);
    }
  }

  {
    meth = PyObject_GetAttrString(self, "OnEventChanged");
    if(PyCFunction_Check(meth) && PyCFunction_GetFunction(meth) == &_wrap_CaptureViewer_OnEventChanged)
    {
      Py_XDECREF(meth);
      meth = NULL;
    }

    if(meth)
    {
      m_OnEventChanged = ConvertFunc<std::function<void(uint32_t)>>("ICaptureViewer::OnEventChanged", meth, ex);
      Py_XDECREF(meth);
    }
  }
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"SWIG_PyInstanceMethod_New", (PyCFunction)SWIG_PyInstanceMethod_New, METH_O, NULL},
	 { (char *)"ConfigFilePath", (PyCFunction)_wrap_ConfigFilePath, METH_O, (char *)"\n"
		"ConfigFilePath(filename)\n"
		"\n"
		"Retrieve the absolute path where a given file can be stored with other application\n"
		"data.\n"
		"\n"
		":param str filename: The base filename.\n"
		":return: The absolute path.\n"
		":rtype: str\n"
		"\n"
		""},
	 { (char *)"UnitSuffix", (PyCFunction)_wrap_UnitSuffix, METH_O, (char *)"\n"
		"UnitSuffix(unit)\n"
		"\n"
		"Gets the suffix for a time unit.\n"
		"\n"
		":param TimeUnit unit: The unit to get a suffix for.\n"
		":return: The one or two character suffix.\n"
		":rtype: str\n"
		"\n"
		""},
	 { (char *)"AddRecentFile", _wrap_AddRecentFile, METH_VARARGS, (char *)"\n"
		"AddRecentFile(recentList, file)\n"
		"\n"
		"Checks if a given file is in a list. If it is, then it's shuffled to the end. If it's\n"
		"not then it's added to the end\n"
		"\n"
		"As the name suggests, this is used for tracking a 'recent file' list.\n"
		"\n"
		":param List[str] recentList: The list that is mutated by the function.\n"
		":param str file: The file to add to the list.\n"
		"\n"
		""},
	 { (char *)"RemoveRecentFile", _wrap_RemoveRecentFile, METH_VARARGS, (char *)"\n"
		"RemoveRecentFile(recentList, file)\n"
		"\n"
		"Removes a given file from the list, after normalising the path. If the path isn't\n"
		"present then the list is not modified.\n"
		"\n"
		"As the name suggests, this is used for tracking a 'recent file' list.\n"
		"\n"
		":param List[str] recentList: The list that is mutated by the function.\n"
		":param str file: The file to remove from the list.\n"
		"\n"
		""},
	 { NULL, NULL, 0, NULL }
};

static SwigPyGetSet CaptureSettings_numQueuedFrames_getset = { _wrap_CaptureSettings_numQueuedFrames_get, _wrap_CaptureSettings_numQueuedFrames_set };
static SwigPyGetSet CaptureSettings_environment_getset = { _wrap_CaptureSettings_environment_get, _wrap_CaptureSettings_environment_set };
static SwigPyGetSet CaptureSettings___dict___getset = { SwigPyObject_get___dict__, 0 };
static SwigPyGetSet CaptureSettings_executable_getset = { _wrap_CaptureSettings_executable_get, _wrap_CaptureSettings_executable_set };
static SwigPyGetSet CaptureSettings_commandLine_getset = { _wrap_CaptureSettings_commandLine_get, _wrap_CaptureSettings_commandLine_set };
static SwigPyGetSet CaptureSettings_inject_getset = { _wrap_CaptureSettings_inject_get, _wrap_CaptureSettings_inject_set };
static SwigPyGetSet CaptureSettings_queuedFrameCap_getset = { _wrap_CaptureSettings_queuedFrameCap_get, _wrap_CaptureSettings_queuedFrameCap_set };
static SwigPyGetSet CaptureSettings_options_getset = { _wrap_CaptureSettings_options_get, _wrap_CaptureSettings_options_set };
static SwigPyGetSet CaptureSettings_autoStart_getset = { _wrap_CaptureSettings_autoStart_get, _wrap_CaptureSettings_autoStart_set };
static SwigPyGetSet CaptureSettings_workingDir_getset = { _wrap_CaptureSettings_workingDir_get, _wrap_CaptureSettings_workingDir_set };
SWIGINTERN PyGetSetDef SwigPyBuiltin__CaptureSettings_getset[] = {
    { (char *) "numQueuedFrames", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The number of queued frames to capture, or 0 if no frames are queued to be captured.\n"
		"\n"
		":type: int\n"
		"\n"
		"", (void *) &CaptureSettings_numQueuedFrames_getset }
,
    { (char *) "environment", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The environment changes to apply.\n"
		"\n"
		":type: List[renderdoc.EnvironmentModification]\n"
		"\n"
		"", (void *) &CaptureSettings_environment_getset }
,
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"CaptureSettings.__dict__", (void *) &CaptureSettings___dict___getset }
,
    { (char *) "executable", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The path to the executable to run.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &CaptureSettings_executable_getset }
,
    { (char *) "commandLine", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The command line to pass when running :data:`executable`.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &CaptureSettings_commandLine_getset }
,
    { (char *) "inject", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the described capture is an inject-into-process instead of a launched executable.\n"
		"\n"
		":type: bool\n"
		"\n"
		"", (void *) &CaptureSettings_inject_getset }
,
    { (char *) "queuedFrameCap", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The first queued frame to capture. Ignored if :data:`numQueuedFrames` is 0.\n"
		"\n"
		":type: int\n"
		"\n"
		"", (void *) &CaptureSettings_queuedFrameCap_getset }
,
    { (char *) "options", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The settings for the capture.\n"
		"\n"
		":type: renderdoc.CaptureOptions\n"
		"\n"
		"", (void *) &CaptureSettings_options_getset }
,
    { (char *) "autoStart", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if this capture settings object should be immediately executed upon load.\n"
		"\n"
		":type: bool\n"
		"\n"
		"", (void *) &CaptureSettings_autoStart_getset }
,
    { (char *) "workingDir", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The path to the working directory to run in, or blank for the executable's directory.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &CaptureSettings_workingDir_getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__CaptureSettings_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__CaptureSettings_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__CaptureSettings_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.CaptureSettings",             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_CaptureSettings_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__CaptureSettings_type.as_number,               /* tp_as_number */
    &SwigPyBuiltin__CaptureSettings_type.as_sequence,             /* tp_as_sequence */
    &SwigPyBuiltin__CaptureSettings_type.as_mapping,              /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__CaptureSettings_type.as_buffer,               /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "Contains all of the settings that control how to capture an executable.",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__CaptureSettings_richcompare,     /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__CaptureSettings_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__CaptureSettings_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_CaptureSettings,     /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__CaptureSettings_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CaptureSettings_type};

static SwigPyGetSet MainWindow___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IMainWindow_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IMainWindow.__dict__", (void *) &MainWindow___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IMainWindow_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IMainWindow_methods[] = {
  { "Widget", (PyCFunction) _wrap_MainWindow_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`MainWindow` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "RegisterShortcut", (PyCFunction) _wrap_MainWindow_RegisterShortcut, METH_VARARGS, (char *) "\n"
		"RegisterShortcut(shortcut, widget, callback)\n"
		"\n"
		"Register a callback for a particular key shortcut.\n"
		"\n"
		"This creates a managed shortcut. Qt's shortcut system doesn't allow specialisation/duplication, so\n"
		"you can't use ``Ctrl+S`` for a shortcut in a window to update some changes if there's also a global\n"
		"``Ctrl+S`` shortcut on the window. In the end, neither shortcut will be called.\n"
		"\n"
		"Instead this function allows the main window to manage shortcuts internally, and it will pick the\n"
		"closest shortcut to a given action. The search goes from the widget with the focus currently up the\n"
		"chain of parents, with the first match being used. If no matches are found, then a 'global' default\n"
		"will be invoked, if it exists.\n"
		"\n"
		":param str shortcut: The text string representing the shortcut, e.g. 'Ctrl+S'.\n"
		":param QWidget widget: A handle to the widget to use as the context for this shortcut, or ``None``\n"
		"  for a global shortcut. Note that if an existing global shortcut exists the new one will not be\n"
		"  registered.\n"
		":param ShortcutCallback callback: The function to callback when the shortcut is hit.\n"
		"  Callback function signature must match :func:`ShortcutCallback`.\n"
		"\n"
		"" },
  { "UnregisterShortcut", (PyCFunction) _wrap_MainWindow_UnregisterShortcut, METH_VARARGS, (char *) "\n"
		"UnregisterShortcut(shortcut, widget)\n"
		"\n"
		"Unregister a callback for a particular key shortcut, made in a previous call to\n"
		":meth:`RegisterShortcut`.\n"
		"\n"
		"See the documentation for :meth:`RegisterShortcut` for what these shortcuts are for.\n"
		"\n"
		":param str shortcut: The text string representing the shortcut, e.g. 'Ctrl+S'. To unregister all\n"
		"  shortcuts for a particular widget, you can pass an empty string here. In this case,\n"
		"  :paramref:`UnregisterShortcut.widget` must not be ``None``.\n"
		":param QWidget widget: A handle to the widget used as the context for the shortcut, or ``None``\n"
		"  if referring to a global shortcut.\n"
		"\n"
		"" },
  { "BringToFront", (PyCFunction) _wrap_MainWindow_BringToFront, METH_NOARGS, (char *) "\n"
		"BringToFront()\n"
		"\n"
		"Attempts to bring the main window to the front to the user's focus.\n"
		"\n"
		"This may not be possible on all OSs, so the function is not guaranteed to succeed.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IMainWindow_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.MainWindow",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IMainWindow_type.as_number,                   /* tp_as_number */
    &SwigPyBuiltin__IMainWindow_type.as_sequence,                 /* tp_as_sequence */
    &SwigPyBuiltin__IMainWindow_type.as_mapping,                  /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IMainWindow_type.as_buffer,                   /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The main parent window of the application.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetMainWindow`.\n"
		"\n"
		".. function:: ShortcutCallback(QWidget focusWidget)\n"
		"\n"
		"  Not a member function - the signature for any ``ShortcutCallback`` callbacks.\n"
		"\n"
		"  :param QWidget focusWidget: The widget with focus at the time this shortcut was detected. May be\n"
		"     ``None``.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IMainWindow_richcompare,         /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IMainWindow_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IMainWindow_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IMainWindow_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IMainWindow_type};

static SwigPyGetSet EventBrowser___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IEventBrowser_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IEventBrowser.__dict__", (void *) &EventBrowser___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IEventBrowser_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IEventBrowser_methods[] = {
  { "Widget", (PyCFunction) _wrap_EventBrowser_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`EventBrowser` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "UpdateDurationColumn", (PyCFunction) _wrap_EventBrowser_UpdateDurationColumn, METH_NOARGS, (char *) "\n"
		"UpdateDurationColumn()\n"
		"\n"
		"Updates the duration column if the selected time unit changes.\n"
		"" },
  { "GetAPIEventForEID", (PyCFunction) _wrap_EventBrowser_GetAPIEventForEID, METH_O, (char *) "\n"
		"GetAPIEventForEID(eventId)\n"
		"\n"
		"Uses the existing caching in the event browser to return a :class:`~renderdoc.APIEvent`\n"
		"for a specified EID.\n"
		"\n"
		"If no capture is loaded or the EID doesn't correspond to a known event, an empty struct will be\n"
		"returned.\n"
		"\n"
		":param int eventId: The EID to look up.\n"
		":return: The event corresponding to the EID, or an empty struct if no such EID exists.\n"
		":rtype: renderdoc.APIEvent\n"
		"\n"
		"" },
  { "GetActionForEID", (PyCFunction) _wrap_EventBrowser_GetActionForEID, METH_O, (char *) "\n"
		"GetActionForEID(eventId)\n"
		"\n"
		"Uses the existing caching in the event browser to return a\n"
		":class:`~renderdoc.ActionDescription` for a specified EID. This action may not be the exact EID\n"
		"specified, but it will be the action that the EID is associated with. I.e. if you specify the EID for\n"
		"a state setting event the next action will be returned.\n"
		"\n"
		"If no capture is loaded or the EID doesn't correspond to a known event, ``None`` will be returned.\n"
		"\n"
		":param int eventId: The EID to look up.\n"
		":return: The action containing the EID, or ``None`` if no such EID exists.\n"
		":rtype: renderdoc.ActionDescription\n"
		"\n"
		"" },
  { "GetEventName", (PyCFunction) _wrap_EventBrowser_GetEventName, METH_O, (char *) "\n"
		"GetEventName(eventId)\n"
		"\n"
		"Returns the formatted name of an event according to the current settings, whether\n"
		"that be a custom name or an auto-generated name with/without parameter names.\n"
		"\n"
		"If no capture is loaded or the EID doesn't correspond to a known event, an empty string will be\n"
		"returned.\n"
		"\n"
		":param int eventId: The EID to look up.\n"
		":return: The formatted name of the specified event, or ``None`` if no such EID exists.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "IsAPIEventVisible", (PyCFunction) _wrap_EventBrowser_IsAPIEventVisible, METH_O, (char *) "\n"
		"IsAPIEventVisible(eventId)\n"
		"\n"
		"Determines if a given EID is visible with the current filters applied to the event\n"
		"browser.\n"
		"\n"
		"If no capture is loaded or the EID doesn't correspond to a known event, ``False`` will be returned.\n"
		"\n"
		":param int eventId: The EID to look up.\n"
		":return: Whether or not the event is currently visible (passing the filters).\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "RegisterEventFilterFunction", (PyCFunction) _wrap_EventBrowser_RegisterEventFilterFunction, METH_VARARGS, (char *) "\n"
		"RegisterEventFilterFunction(name, description, filter, parser, completer)\n"
		"\n"
		"Registers a new event browser filter function.\n"
		"\n"
		"Filter functions are available as $name() so long as they don't shadow an existing function. The\n"
		"filter callback will be called for each event to filter.\n"
		"\n"
		"The parser callback will be called once when a filter is first specified or the parameters change.\n"
		"Note that a filter can be used multiple times in a filter expression! For this reason the parser\n"
		"may be called multiple times and the filter callback takes the parameters string. If any expensive\n"
		"work is done then the parameters can be used as a cache key to cache any data once per filter\n"
		"expression.\n"
		"\n"
		":param str name: The name of the filter function.\n"
		":param str description: The description of the filter function. This should explain the available\n"
		"  parameters (if applicable) and what the filter does. It will be used for documenting to users\n"
		"  what each filter means.\n"
		":param EventFilterCallback filter: The callback to call for each candidate event to perform\n"
		"  filtering.\n"
		"  Callback function signature must match :func:`EventFilterCallback`.\n"
		":param FilterParseCallback parser: The callback to call when the parsing the parameters and checking\n"
		"  for any errors. This can be ``None`` if no pre-parsing is required.\n"
		"  Callback function signature must match :func:`FilterParseCallback`.\n"
		":param AutoCompleteCallback completer: The callback to call when trying to provide autocomplete\n"
		"  suggestions. This can be ``None`` if no completion is desired/applicable.\n"
		"  Callback function signature must match :func:`AutoCompleteCallback`.\n"
		":return: Whether or not the registration was successful.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "UnregisterEventFilterFunction", (PyCFunction) _wrap_EventBrowser_UnregisterEventFilterFunction, METH_O, (char *) "\n"
		"UnregisterEventFilterFunction(name)\n"
		"\n"
		"Unregisters an event browser filter function that was previously registered.\n"
		"\n"
		":param str name: The name of the filter function.\n"
		"\n"
		":return: Whether or not the unregistration was successful.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "SetCurrentFilterText", (PyCFunction) _wrap_EventBrowser_SetCurrentFilterText, METH_O, (char *) "\n"
		"SetCurrentFilterText(text)\n"
		"\n"
		"Sets the current filter text. This will not modify any saved filter but will modify\n"
		"the scratch filter. The filter is applied immediately.\n"
		"\n"
		":param str text: The filter text.\n"
		"\n"
		"" },
  { "GetCurrentFilterText", (PyCFunction) _wrap_EventBrowser_GetCurrentFilterText, METH_NOARGS, (char *) "\n"
		"GetCurrentFilterText()\n"
		"\n"
		"Returns the current filter text, whether temporary or a saved filter.\n"
		"\n"
		":return: The current filter text.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "SetUseCustomActionNames", (PyCFunction) _wrap_EventBrowser_SetUseCustomActionNames, METH_O, (char *) "\n"
		"SetUseCustomActionNames(use)\n"
		"\n"
		"Sets whether or not custom action names are used. Certain actions such as indirect\n"
		"actions it is useful to show a custom action name which contains the actual indirect parameters\n"
		"instead of the 'raw' parameters.\n"
		"\n"
		":param bool use: Whether or not custom action names will be used.\n"
		"\n"
		"" },
  { "SetShowParameterNames", (PyCFunction) _wrap_EventBrowser_SetShowParameterNames, METH_O, (char *) "\n"
		"SetShowParameterNames(show)\n"
		"\n"
		"Sets whether or not parameter names are shown in the events. If disabled, only the\n"
		"value is shown and the parameter is implicit.\n"
		"\n"
		".. note::\n"
		"  If custom action names are used this will not have an effect for any such actions. See\n"
		"  :meth:`SetUseCustomActionNames`.\n"
		"\n"
		":param bool show: Whether or not parameter names will be shown.\n"
		"\n"
		"" },
  { "SetShowAllParameters", (PyCFunction) _wrap_EventBrowser_SetShowAllParameters, METH_O, (char *) "\n"
		"SetShowAllParameters(show)\n"
		"\n"
		"Sets whether or not all parameters are shown in the events. By default only\n"
		"the most significant parameters are shown.\n"
		"\n"
		".. note::\n"
		"  If custom action names are used this will not have an effect for any such actions. See\n"
		"  :meth:`SetUseCustomActionNames`.\n"
		"\n"
		":param bool show: Whether or not parameter names will be shown.\n"
		"\n"
		"" },
  { "SetEmptyRegionsVisible", (PyCFunction) _wrap_EventBrowser_SetEmptyRegionsVisible, METH_O, (char *) "\n"
		"SetEmptyRegionsVisible(show)\n"
		"\n"
		"Sets whether or not marker regions which have no visible actions.\n"
		"\n"
		":param bool show: Whether or not empty regions after filtering will be shown.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IEventBrowser_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.EventBrowser",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IEventBrowser_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__IEventBrowser_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__IEventBrowser_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IEventBrowser_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The event browser window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetEventBrowser`.\n"
		"\n"
		".. function:: EventFilterCallback(context, filter, params, eventId, chunk, action, name)\n"
		"\n"
		"  Not a member function - the signature for any ``EventFilterCallback`` callbacks.\n"
		"\n"
		"  Called for each event in a capture when performing filtering in the Event Browser. The associated\n"
		"  :func:`FilterParseCallback` will be called first to parse the parameters, and is available for caching\n"
		"  or syntax checking. The same filter name and params string will be passed to this function.\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param str filter: The name of the filter function.\n"
		"  :param str params: The parameters to the filter function.\n"
		"  :param int eventId: The event's :data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"  :param renderdoc.SDChunk chunk: The structured data chunk for this event.\n"
		"  :param renderdoc.ActionDescription action: The action that contains this event. If the event is\n"
		"    the action itself then the event ID will be equal.\n"
		"  :param str name: The name of the event as shown in the event browser, for string-based filtering.\n"
		"  :return: Whether or not this event matches the filter\n"
		"  :rtype: bool\n"
		"\n"
		".. function:: FilterParseCallback(context, filter, params)\n"
		"\n"
		"  Not a member function - the signature for any ``FilterParseCallback`` callbacks.\n"
		"\n"
		"  Called once when the filter changes, to allow parsing any any data caching, as well as reporting\n"
		"  of errors in the filter usage.\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param str filter: The name of the filter function.\n"
		"  :param str params: The parameters to the filter function.\n"
		"  :return: An empty string if the parse succeeded, otherwise any error messages to be displayed to\n"
		"    the user, such as syntax or other errors.\n"
		"  :rtype: str\n"
		"\n"
		".. function:: AutoCompleteCallback(context, filter, params)\n"
		"\n"
		"  Not a member function - the signature for any ``AutoCompleteCallback`` callbacks.\n"
		"\n"
		"  Called when autocompletion is triggered inside a filter. The params passed are any previous\n"
		"  text inside the filter's parameter list up to where the cursor is. The callback should return a\n"
		"  list of identifiers used for auto-completion.\n"
		"\n"
		"  The list does not have to be pre-filtered for matches to the :paramref:`params`, that is provided\n"
		"  to allow different autocompletion at different stages (e.g. if there are no parameters, you can\n"
		"  autocomplete a property, if a property is already present you can autocomplete valid values for\n"
		"  it)\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param str filter: The name of the filter function.\n"
		"  :param str params: The previous parameter text to the filter function.\n"
		"  :return: A list of strings giving identifiers to autocomplete, or an empty list of there are no\n"
		"    such identifiers to prompt.\n"
		"  :rtype: List[str]\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IEventBrowser_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IEventBrowser_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IEventBrowser_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IEventBrowser_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IEventBrowser_type};

static SwigPyGetSet APIInspector___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IAPIInspector_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IAPIInspector.__dict__", (void *) &APIInspector___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IAPIInspector_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IAPIInspector_methods[] = {
  { "Widget", (PyCFunction) _wrap_APIInspector_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`APIInspector` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "Refresh", (PyCFunction) _wrap_APIInspector_Refresh, METH_NOARGS, (char *) "\n"
		"Refresh()\n"
		"\n"
		"Refresh the current API view - useful if callstacks are now available.\n"
		"" },
  { "RevealParameter", (PyCFunction) _wrap_APIInspector_RevealParameter, METH_O, (char *) "\n"
		"RevealParameter(param)\n"
		"\n"
		"Expand the API view to reveal a given parameter and select it.\n"
		"\n"
		":param renderdoc.SDObject param: The parameter to reveal and select.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IAPIInspector_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.APIInspector",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IAPIInspector_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__IAPIInspector_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__IAPIInspector_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IAPIInspector_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The API inspector window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetAPIInspector`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IAPIInspector_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IAPIInspector_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IAPIInspector_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IAPIInspector_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IAPIInspector_type};

static SwigPyGetSet PipelineStage___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__PipelineStage_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"PipelineStage.__dict__", (void *) &PipelineStage___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__PipelineStage_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__PipelineStage_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__PipelineStage_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "PipelineStage",                          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_PipelineStage_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__PipelineStage_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__PipelineStage_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__PipelineStage_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__PipelineStage_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Specifies a pipeline stage for the :class:`PipelineStateViewer`.\n"
		"\n"
		".. data:: VertexInput\n"
		"\n"
		"  The fixed function vertex input stage.\n"
		"\n"
		".. data:: VertexShader\n"
		"\n"
		"  The vertex shader.\n"
		"\n"
		".. data:: HullShader\n"
		"\n"
		"  The vertex shader.\n"
		"\n"
		".. data:: TessControlShader\n"
		"\n"
		"  The tessellation control shader.\n"
		"\n"
		".. data:: DomainShader\n"
		"\n"
		"  The domain shader.\n"
		"\n"
		".. data:: TessEvalShader\n"
		"\n"
		"  The tessellation evaluation shader.\n"
		"\n"
		".. data:: GeometryShader\n"
		"\n"
		"  The geometry shader, including stream-out/transform feedback.\n"
		"\n"
		".. data:: Rasterizer\n"
		"\n"
		"  The fixed function rasterizer stage.\n"
		"\n"
		".. data:: ViewportsScissors\n"
		"\n"
		"  The viewports and scissors. Helper alias for :data:`Rasterizer`.\n"
		"\n"
		".. data:: PixelShader\n"
		"\n"
		"  The pixel shader.\n"
		"\n"
		".. data:: FragmentShader\n"
		"\n"
		"  The fragment shader.\n"
		"\n"
		".. data:: ColorDepthOutput\n"
		"\n"
		"  The fixed function color and depth output stage, including color blending and depth/stencil\n"
		"  testing state.\n"
		"\n"
		".. data:: Blending\n"
		"\n"
		"  The color blending state. Helper alias for :data:`ColorDepthOutput`.\n"
		"\n"
		".. data:: DepthTest\n"
		"\n"
		"  The depth test state. Helper alias for :data:`ColorDepthOutput`.\n"
		"\n"
		".. data:: StencilTest\n"
		"\n"
		"  The stencil test state. Helper alias for :data:`ColorDepthOutput`.\n"
		"\n"
		".. data:: ComputeShader\n"
		"\n"
		"  The compute shader.\n"
		"\n"
		".. data:: SampleMask\n"
		"\n"
		"  The sample mask.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__PipelineStage_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__PipelineStage_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__PipelineStage_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_PipelineStage,       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__PipelineStage_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__PipelineStage_type};

static SwigPyGetSet PipelineStateViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IPipelineStateViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IPipelineStateViewer.__dict__", (void *) &PipelineStateViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IPipelineStateViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IPipelineStateViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_PipelineStateViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`PipelineStateViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SaveShaderFile", (PyCFunction) _wrap_PipelineStateViewer_SaveShaderFile, METH_O, (char *) "\n"
		"SaveShaderFile(shader)\n"
		"\n"
		"Prompt the user to save the binary form of the given shader to disk.\n"
		"\n"
		":param renderdoc.ShaderReflection shader: The shader reflection data to save.\n"
		":return: ``True`` if the shader was saved successfully, ``False`` if an error occurred.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "SelectPipelineStage", (PyCFunction) _wrap_PipelineStateViewer_SelectPipelineStage, METH_O, (char *) "\n"
		"SelectPipelineStage(stage)\n"
		"\n"
		"Select a given pipeline stage in the viewer.\n"
		"\n"
		":param PipelineStage stage: The stage to select.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IPipelineStateViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.PipelineStateViewer",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IPipelineStateViewer_type.as_number,          /* tp_as_number */
    &SwigPyBuiltin__IPipelineStateViewer_type.as_sequence,        /* tp_as_sequence */
    &SwigPyBuiltin__IPipelineStateViewer_type.as_mapping,         /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IPipelineStateViewer_type.as_buffer,          /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The pipeline state viewer window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetPipelineViewer`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IPipelineStateViewer_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IPipelineStateViewer_methods,                  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IPipelineStateViewer_getset,                   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IPipelineStateViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IPipelineStateViewer_type};

static SwigPyGetSet FollowType___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__FollowType_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"FollowType.__dict__", (void *) &FollowType___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__FollowType_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__FollowType_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__FollowType_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "FollowType",                             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_FollowType_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__FollowType_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__FollowType_type.as_sequence,                  /* tp_as_sequence */
    &SwigPyBuiltin__FollowType_type.as_mapping,                   /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__FollowType_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Specifies a type of followed resource for the :class:`TextureViewer`.\n"
		"\n"
		".. data:: OutputColor\n"
		"\n"
		"  The index specifies which output color target to select. Shader stage and array index are ignored.\n"
		"\n"
		".. data:: OutputDepth\n"
		"\n"
		"  The resource followed is the depth/stencil output target. All other parameters are ignored.\n"
		"\n"
		".. data:: ReadWrite\n"
		"\n"
		"  The index specifies a resource within the given shader's\n"
		"  :data:`read-write resources <~renderdoc.ShaderReflection.readWriteResources>`. The array element\n"
		"  then specifies the index within that resource's array, if applicable.\n"
		"\n"
		".. data:: ReadOnly\n"
		"\n"
		"  The index specifies a resource within the given shader's\n"
		"  :data:`read-only resources <~renderdoc.ShaderReflection.readOnlyResources>`. The array element\n"
		"  then specifies the index within that resource's array, if applicable.\n"
		"\n"
		".. data:: OutputDepthResolve\n"
		"\n"
		"  The resource followed is the depth/stencil resolve output target. All other parameters are ignored.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__FollowType_richcompare,          /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__FollowType_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__FollowType_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_FollowType,          /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__FollowType_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__FollowType_type};

static SwigPyGetSet TextureViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ITextureViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ITextureViewer.__dict__", (void *) &TextureViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ITextureViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ITextureViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_TextureViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`TextureViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "ViewTexture", (PyCFunction) _wrap_TextureViewer_ViewTexture, METH_VARARGS, (char *) "\n"
		"ViewTexture(resourceId, typeCast, focus)\n"
		"\n"
		"Open a texture view, optionally raising this window to the foreground.\n"
		"\n"
		":param renderdoc.ResourceId resourceId: The ID of the texture to view.\n"
		":param renderdoc.CompType typeCast: If possible interpret the texture with this type instead of its\n"
		"  normal type. If set to :data:`~renderdoc.CompType.Typeless` then no cast is applied, otherwise\n"
		"  where allowed the texture data will be reinterpreted - e.g. from unsigned integers to floats, or\n"
		"  to unsigned normalised values.\n"
		":param bool focus: ``True`` if the :class:`TextureViewer` should be raised.\n"
		"\n"
		"" },
  { "ViewFollowedResource", (PyCFunction) _wrap_TextureViewer_ViewFollowedResource, METH_VARARGS, (char *) "\n"
		"ViewFollowedResource(followType, stage, index, arrayElement)\n"
		"\n"
		"Select the 'following' view and choose which resource slot to follow.\n"
		"\n"
		":param FollowType followType: The type of followed resource.\n"
		":param renderdoc.ShaderStage stage: The shader stage of the shader reflection data to look up.\n"
		":param int index: The index within the given resource list (if applicable) to follow.\n"
		":param int arrayElement: The index within the given resource array (if applicable) to follow.\n"
		"\n"
		"" },
  { "GetCurrentResource", (PyCFunction) _wrap_TextureViewer_GetCurrentResource, METH_NOARGS, (char *) "\n"
		"GetCurrentResource()\n"
		"\n"
		"Return which resource is currently being displayed in the active tab.\n"
		"\n"
		":return: The ID of the resource being displayed.\n"
		":rtype: renderdoc.ResourceId\n"
		"\n"
		"" },
  { "GetSelectedSubresource", (PyCFunction) _wrap_TextureViewer_GetSelectedSubresource, METH_NOARGS, (char *) "\n"
		"GetSelectedSubresource()\n"
		"\n"
		"Return which subresource is currently selected for viewing.\n"
		"\n"
		":return: The subresource currently selected.\n"
		":rtype: renderdoc.Subresource\n"
		"\n"
		"" },
  { "SetSelectedSubresource", (PyCFunction) _wrap_TextureViewer_SetSelectedSubresource, METH_O, (char *) "\n"
		"SetSelectedSubresource(sub)\n"
		"\n"
		"Select a particular subresource within the currently selected texture. Any out of\n"
		"bounds parameters will be clamped to the available subresources.\n"
		"\n"
		":param renderdoc.Subresource sub: The subresource to select.\n"
		"\n"
		"" },
  { "GotoLocation", (PyCFunction) _wrap_TextureViewer_GotoLocation, METH_VARARGS, (char *) "\n"
		"GotoLocation(x, y)\n"
		"\n"
		"Highlights the given pixel location in the current texture.\n"
		"\n"
		":param int x: The X co-ordinate.\n"
		":param int y: The Y co-ordinate.\n"
		"\n"
		"" },
  { "GetPickedLocation", (PyCFunction) _wrap_TextureViewer_GetPickedLocation, METH_NOARGS, (char *) "\n"
		"GetPickedLocation()\n"
		"\n"
		"Returns the currently selected texel location in the current texture.\n"
		"\n"
		"If no location is currently selected or there is no current texture, this will return ``(-1, -1)``.\n"
		"\n"
		":return: The currently picked pixel location.\n"
		":rtype: Tuple[int,int]\n"
		"\n"
		"" },
  { "GetTextureOverlay", (PyCFunction) _wrap_TextureViewer_GetTextureOverlay, METH_NOARGS, (char *) "\n"
		"GetTextureOverlay()\n"
		"\n"
		"Return the currently selected texture overlay.\n"
		"\n"
		":return: The currently selected texture overlay.\n"
		":rtype: renderdoc.DebugOverlay\n"
		"\n"
		"" },
  { "SetTextureOverlay", (PyCFunction) _wrap_TextureViewer_SetTextureOverlay, METH_O, (char *) "\n"
		"SetTextureOverlay(overlay)\n"
		"\n"
		"Changes the currently selected overlay the given pixel location in the current texture.\n"
		"\n"
		":param renderdoc.DebugOverlay overlay: The overlay to enable.\n"
		"\n"
		"" },
  { "IsZoomAutoFit", (PyCFunction) _wrap_TextureViewer_IsZoomAutoFit, METH_NOARGS, (char *) "\n"
		"IsZoomAutoFit()\n"
		"\n"
		"Return whether or not the texture viewer is currently auto-fitting the zoom level.\n"
		"\n"
		":return: ``True`` if the zoom level is currently auto-fitting.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "GetZoomLevel", (PyCFunction) _wrap_TextureViewer_GetZoomLevel, METH_NOARGS, (char *) "\n"
		"GetZoomLevel()\n"
		"\n"
		"Return the current zoom level, whether manually set or auto-calculated.\n"
		"\n"
		":return: The current zoom level, with 100% being represented as 1.0.\n"
		":rtype: float\n"
		"\n"
		"" },
  { "SetZoomLevel", (PyCFunction) _wrap_TextureViewer_SetZoomLevel, METH_VARARGS, (char *) "\n"
		"SetZoomLevel(autofit, zoom)\n"
		"\n"
		"Set the zoom level for displaying textures.\n"
		"\n"
		":param bool autofit: ``True`` if the zoom level should be auto-calculated continuously to\n"
		"  automatically fit the texture completely in view.\n"
		":param float zoom: The zoom level as a percentage, with 100% being 1.0. Ignored if\n"
		"  :paramref:`autofit` is ``True``.\n"
		"\n"
		"" },
  { "GetHistogramRange", (PyCFunction) _wrap_TextureViewer_GetHistogramRange, METH_NOARGS, (char *) "\n"
		"GetHistogramRange()\n"
		"\n"
		"Return the current histogram blackpoint to whitepoint range.\n"
		"\n"
		":return: The current histogram range.\n"
		":rtype: Tuple[float,float]\n"
		"\n"
		"" },
  { "SetHistogramRange", (PyCFunction) _wrap_TextureViewer_SetHistogramRange, METH_VARARGS, (char *) "\n"
		"SetHistogramRange(blackpoint, whitepoint)\n"
		"\n"
		"Set the current histogram blackpoint to whitepoint range.\n"
		"\n"
		":param float blackpoint: The value that should be mapped to black, component-wise.\n"
		":param float whitepoint: The value that should be mapped to white, component-wise.\n"
		"\n"
		"" },
  { "GetChannelVisibilityBits", (PyCFunction) _wrap_TextureViewer_GetChannelVisibilityBits, METH_NOARGS, (char *) "\n"
		"GetChannelVisibilityBits()\n"
		"\n"
		"Return which channels are currently displayed, as a bitmask.\n"
		"\n"
		"If red is visible ``0x1`` will be set in the returned value, if blue is visible ``0x2`` will be set,\n"
		"etc.\n"
		"\n"
		":return: The current bitmask showing channel visibility.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "SetChannelVisibility", (PyCFunction) _wrap_TextureViewer_SetChannelVisibility, METH_VARARGS, (char *) "\n"
		"SetChannelVisibility(red, green, blue, alpha)\n"
		"\n"
		"Set the visibility of each channel.\n"
		"\n"
		":param bool red: Whether the red channel should be visible.\n"
		":param bool green: Whether the green channel should be visible.\n"
		":param bool blue: Whether the blue channel should be visible.\n"
		":param bool alpha: Whether the alpha channel should be visible.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ITextureViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.TextureViewer",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ITextureViewer_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ITextureViewer_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ITextureViewer_type.as_mapping,               /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ITextureViewer_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The texture viewer window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetTextureViewer`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ITextureViewer_richcompare,      /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ITextureViewer_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ITextureViewer_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ITextureViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ITextureViewer_type};

static SwigPyGetSet BufferViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IBufferViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IBufferViewer.__dict__", (void *) &BufferViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IBufferViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IBufferViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_BufferViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`BufferViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "ScrollToRow", (PyCFunction) _wrap_BufferViewer_ScrollToRow, METH_VARARGS, (char *) "\n"
		"ScrollToRow(row, stage)\n"
		"ScrollToRow(row)\n"
		"\n"
		"Scroll to the given row in the given stage's data.\n"
		"\n"
		":param int row: the row to scroll to.\n"
		":param renderdoc.MeshDataStage stage: The stage of the geometry pipeline to scroll within.\n"
		"\n"
		"" },
  { "ScrollToColumn", (PyCFunction) _wrap_BufferViewer_ScrollToColumn, METH_VARARGS, (char *) "\n"
		"ScrollToColumn(column, stage)\n"
		"ScrollToColumn(column)\n"
		"\n"
		"Scroll to the given column in the given stage's data.\n"
		"\n"
		":param int column: the column to scroll to.\n"
		":param renderdoc.MeshDataStage stage: The stage of the geometry pipeline to scroll within.\n"
		"\n"
		"" },
  { "ShowMeshData", (PyCFunction) _wrap_BufferViewer_ShowMeshData, METH_O, (char *) "\n"
		"ShowMeshData(stage)\n"
		"\n"
		"Ensure the given stage's data is visible and raised, if it wasn't before.\n"
		"\n"
		":param renderdoc.MeshDataStage stage: The stage of the geometry pipeline to show data for.\n"
		"\n"
		"" },
  { "SetCurrentInstance", (PyCFunction) _wrap_BufferViewer_SetCurrentInstance, METH_O, (char *) "\n"
		"SetCurrentInstance(instance)\n"
		"\n"
		"For a mesh view, set the current instance. This is ignored when called on a raw buffer\n"
		"view.\n"
		"\n"
		":param int instance: The instance to select, will be clamped to the range [0, numInstances-1]\n"
		"\n"
		"" },
  { "SetCurrentView", (PyCFunction) _wrap_BufferViewer_SetCurrentView, METH_O, (char *) "\n"
		"SetCurrentView(view)\n"
		"\n"
		"For a mesh view, set the current multiview view. This is ignored when called on a raw\n"
		"buffer view.\n"
		"\n"
		":param int view: The view to select, will be clamped to the range [0, numViews-1]\n"
		"\n"
		"" },
  { "SetPreviewStage", (PyCFunction) _wrap_BufferViewer_SetPreviewStage, METH_O, (char *) "\n"
		"SetPreviewStage(stage)\n"
		"\n"
		"For a mesh view, set the current preview stage. This is ignored when called on a raw\n"
		"buffer view.\n"
		"\n"
		":param renderdoc.MeshDataStage stage: The stage to show\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IBufferViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.BufferViewer",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IBufferViewer_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__IBufferViewer_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__IBufferViewer_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IBufferViewer_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The buffer viewer window, either a raw buffer or the geometry pipeline.\n"
		"\n"
		"This mesh viewer is retrieved by calling :meth:`CaptureContext.GetMeshPreview`.\n"
		"\n"
		"A raw buffer viewer can be opened by calling :meth:`CaptureContext.ViewBuffer`,\n"
		":meth:`CaptureContext.ViewTextureAsBuffer`, or :meth:`CaptureContext.ViewConstantBuffer`.\n"
		"\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IBufferViewer_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IBufferViewer_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IBufferViewer_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IBufferViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IBufferViewer_type};

static SwigPyGetSet ResourceInspector___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IResourceInspector_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IResourceInspector.__dict__", (void *) &ResourceInspector___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IResourceInspector_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IResourceInspector_methods[] = {
  { "Widget", (PyCFunction) _wrap_ResourceInspector_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`ResourceInspector` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "Inspect", (PyCFunction) _wrap_ResourceInspector_Inspect, METH_O, (char *) "\n"
		"Inspect(id)\n"
		"\n"
		"Change the current resource being inspected.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to inspect.\n"
		"\n"
		"" },
  { "CurrentResource", (PyCFunction) _wrap_ResourceInspector_CurrentResource, METH_NOARGS, (char *) "\n"
		"CurrentResource()\n"
		"\n"
		"Return which resource is currently being inspected.\n"
		"\n"
		":return: The ID of the resource being inspected.\n"
		":rtype: renderdoc.ResourceId\n"
		"\n"
		"" },
  { "RevealParameter", (PyCFunction) _wrap_ResourceInspector_RevealParameter, METH_O, (char *) "\n"
		"RevealParameter(param)\n"
		"\n"
		"Expand the resource initialisation chunks to reveal and select a given parameter.\n"
		"\n"
		":param renderdoc.SDObject param: The parameter to reveal and select.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IResourceInspector_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ResourceInspector",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IResourceInspector_type.as_number,            /* tp_as_number */
    &SwigPyBuiltin__IResourceInspector_type.as_sequence,          /* tp_as_sequence */
    &SwigPyBuiltin__IResourceInspector_type.as_mapping,           /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IResourceInspector_type.as_buffer,            /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The Resource inspector window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetResourceInspector`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IResourceInspector_richcompare,  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IResourceInspector_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IResourceInspector_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IResourceInspector_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IResourceInspector_type};

static SwigPyGetSet CaptureDialog___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ICaptureDialog_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ICaptureDialog.__dict__", (void *) &CaptureDialog___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ICaptureDialog_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ICaptureDialog_methods[] = {
  { "Widget", (PyCFunction) _wrap_CaptureDialog_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`CaptureDialog` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "IsInjectMode", (PyCFunction) _wrap_CaptureDialog_IsInjectMode, METH_NOARGS, (char *) "\n"
		"IsInjectMode()\n"
		"\n"
		"Determines if the window is in inject or launch mode.\n"
		"\n"
		":return: ``True`` if the window is set up for injecting.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "SetInjectMode", (PyCFunction) _wrap_CaptureDialog_SetInjectMode, METH_O, (char *) "\n"
		"SetInjectMode(inject)\n"
		"\n"
		"Switches the window to or from inject mode.\n"
		"\n"
		":param bool inject: ``True`` if the window should configure for injecting into processes.\n"
		"\n"
		"" },
  { "SetExecutableFilename", (PyCFunction) _wrap_CaptureDialog_SetExecutableFilename, METH_O, (char *) "\n"
		"SetExecutableFilename(filename)\n"
		"\n"
		"Sets the executable filename to capture.\n"
		"\n"
		":param str filename: The filename to execute.\n"
		"\n"
		"" },
  { "SetWorkingDirectory", (PyCFunction) _wrap_CaptureDialog_SetWorkingDirectory, METH_O, (char *) "\n"
		"SetWorkingDirectory(dir)\n"
		"\n"
		"Sets the working directory for capture.\n"
		"\n"
		":param str dir: The directory to use.\n"
		"\n"
		"" },
  { "SetCommandLine", (PyCFunction) _wrap_CaptureDialog_SetCommandLine, METH_O, (char *) "\n"
		"SetCommandLine(cmd)\n"
		"\n"
		"Sets the command line string to use when launching an executable.\n"
		"\n"
		":param str cmd: The command line to use.\n"
		"\n"
		"" },
  { "SetEnvironmentModifications", (PyCFunction) _wrap_CaptureDialog_SetEnvironmentModifications, METH_O, (char *) "\n"
		"SetEnvironmentModifications(modifications)\n"
		"\n"
		"Sets the list of environment modifications to apply when launching.\n"
		"\n"
		":param List[renderdoc.EnvironmentModification] modifications: The list of modifications to apply.\n"
		"\n"
		"" },
  { "SetSettings", (PyCFunction) _wrap_CaptureDialog_SetSettings, METH_O, (char *) "\n"
		"SetSettings(settings)\n"
		"\n"
		"Configures the window based on a bulk structure of settings.\n"
		"\n"
		":param CaptureSettings settings: The settings to apply.\n"
		"\n"
		"" },
  { "Settings", (PyCFunction) _wrap_CaptureDialog_Settings, METH_NOARGS, (char *) "\n"
		"Settings()\n"
		"\n"
		"Retrieves the current state of the window as a structure of settings.\n"
		"\n"
		":return: The settings describing the current window state.\n"
		":rtype: CaptureSettings\n"
		"\n"
		"" },
  { "TriggerCapture", (PyCFunction) _wrap_CaptureDialog_TriggerCapture, METH_NOARGS, (char *) "\n"
		"TriggerCapture()\n"
		"\n"
		"Launches a capture of the current executable.\n"
		"" },
  { "LoadSettings", (PyCFunction) _wrap_CaptureDialog_LoadSettings, METH_O, (char *) "\n"
		"LoadSettings(filename)\n"
		"\n"
		"Loads settings from a file and applies them. See :meth:`SetSettings`.\n"
		"\n"
		":param str filename: The filename to load the settings from.\n"
		"\n"
		"" },
  { "SaveSettings", (PyCFunction) _wrap_CaptureDialog_SaveSettings, METH_O, (char *) "\n"
		"SaveSettings(filename)\n"
		"\n"
		"Saves the current settings to a file. See :meth:`Settings`.\n"
		"\n"
		":param str filename: The filename to save the settings to.\n"
		"\n"
		"" },
  { "UpdateGlobalHook", (PyCFunction) _wrap_CaptureDialog_UpdateGlobalHook, METH_NOARGS, (char *) "\n"
		"UpdateGlobalHook()\n"
		"\n"
		"Update the current state of the global hook, e.g. if it has been enabled.\n"
		"" },
  { "UpdateRemoteHost", (PyCFunction) _wrap_CaptureDialog_UpdateRemoteHost, METH_NOARGS, (char *) "\n"
		"UpdateRemoteHost()\n"
		"\n"
		"Update the current state based on the current remote host, when that changes.\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ICaptureDialog_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.CaptureDialog",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ICaptureDialog_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ICaptureDialog_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ICaptureDialog_type.as_mapping,               /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ICaptureDialog_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The executable capture window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetCaptureDialog`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ICaptureDialog_richcompare,      /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ICaptureDialog_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ICaptureDialog_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ICaptureDialog_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ICaptureDialog_type};

static SwigPyGetSet DebugMessageView___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IDebugMessageView_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IDebugMessageView.__dict__", (void *) &DebugMessageView___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IDebugMessageView_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IDebugMessageView_methods[] = {
  { "Widget", (PyCFunction) _wrap_DebugMessageView_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`DebugMessageView` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IDebugMessageView_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.DebugMessageView",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IDebugMessageView_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__IDebugMessageView_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__IDebugMessageView_type.as_mapping,            /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IDebugMessageView_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The debug warnings and errors window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetDebugMessageView`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IDebugMessageView_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IDebugMessageView_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IDebugMessageView_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IDebugMessageView_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IDebugMessageView_type};

static SwigPyGetSet DiagnosticLogView___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IDiagnosticLogView_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IDiagnosticLogView.__dict__", (void *) &DiagnosticLogView___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IDiagnosticLogView_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IDiagnosticLogView_methods[] = {
  { "Widget", (PyCFunction) _wrap_DiagnosticLogView_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`DiagnosticLogView` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IDiagnosticLogView_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.DiagnosticLogView",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IDiagnosticLogView_type.as_number,            /* tp_as_number */
    &SwigPyBuiltin__IDiagnosticLogView_type.as_sequence,          /* tp_as_sequence */
    &SwigPyBuiltin__IDiagnosticLogView_type.as_mapping,           /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IDiagnosticLogView_type.as_buffer,            /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The diagnostic log viewing window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetDiagnosticLogView`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IDiagnosticLogView_richcompare,  /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IDiagnosticLogView_methods,/* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IDiagnosticLogView_getset, /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IDiagnosticLogView_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IDiagnosticLogView_type};

static SwigPyGetSet CommentView___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ICommentView_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ICommentView.__dict__", (void *) &CommentView___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ICommentView_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ICommentView_methods[] = {
  { "Widget", (PyCFunction) _wrap_CommentView_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`CommentView` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetComments", (PyCFunction) _wrap_CommentView_SetComments, METH_O, (char *) "\n"
		"SetComments(text)\n"
		"\n"
		"Sets the current comments text.\n"
		"\n"
		":param str text: The new comments text.\n"
		"\n"
		"" },
  { "GetComments", (PyCFunction) _wrap_CommentView_GetComments, METH_NOARGS, (char *) "\n"
		"GetComments()\n"
		"\n"
		"Gets the current comments text.\n"
		"\n"
		":return: The current comments text.\n"
		":rtype: str\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ICommentView_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.CommentView",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ICommentView_type.as_number,                  /* tp_as_number */
    &SwigPyBuiltin__ICommentView_type.as_sequence,                /* tp_as_sequence */
    &SwigPyBuiltin__ICommentView_type.as_mapping,                 /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ICommentView_type.as_buffer,                  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The capture comments window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetCommentView`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ICommentView_richcompare,        /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ICommentView_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ICommentView_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ICommentView_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ICommentView_type};

static SwigPyGetSet StatisticsViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IStatisticsViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IStatisticsViewer.__dict__", (void *) &StatisticsViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IStatisticsViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IStatisticsViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_StatisticsViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`StatisticsViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IStatisticsViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.StatisticsViewer",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IStatisticsViewer_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__IStatisticsViewer_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__IStatisticsViewer_type.as_mapping,            /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IStatisticsViewer_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The statistics window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetStatisticsViewer`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IStatisticsViewer_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IStatisticsViewer_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IStatisticsViewer_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IStatisticsViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IStatisticsViewer_type};

static SwigPyGetSet TimelineBar___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ITimelineBar_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ITimelineBar.__dict__", (void *) &TimelineBar___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ITimelineBar_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ITimelineBar_methods[] = {
  { "Widget", (PyCFunction) _wrap_TimelineBar_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`TimelineBar` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "HighlightResourceUsage", (PyCFunction) _wrap_TimelineBar_HighlightResourceUsage, METH_O, (char *) "\n"
		"HighlightResourceUsage(id)\n"
		"\n"
		"Highlights the frame usage of the specified resource.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to highlight.\n"
		"\n"
		"" },
  { "HighlightHistory", (PyCFunction) _wrap_TimelineBar_HighlightHistory, METH_VARARGS, (char *) "\n"
		"HighlightHistory(id, history)\n"
		"\n"
		"Highlights the modifications in a frame of a given resource.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource that is being modified.\n"
		":param List[renderdoc.PixelModification] history: A list of pixel events to display.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ITimelineBar_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.TimelineBar",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ITimelineBar_type.as_number,                  /* tp_as_number */
    &SwigPyBuiltin__ITimelineBar_type.as_sequence,                /* tp_as_sequence */
    &SwigPyBuiltin__ITimelineBar_type.as_mapping,                 /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ITimelineBar_type.as_buffer,                  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The timeline bar.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetTimelineBar`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ITimelineBar_richcompare,        /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ITimelineBar_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ITimelineBar_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ITimelineBar_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ITimelineBar_type};

static SwigPyGetSet PerformanceCounterViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IPerformanceCounterViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IPerformanceCounterViewer.__dict__", (void *) &PerformanceCounterViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IPerformanceCounterViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IPerformanceCounterViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_PerformanceCounterViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`PerformanceCounterViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "UpdateDurationColumn", (PyCFunction) _wrap_PerformanceCounterViewer_UpdateDurationColumn, METH_NOARGS, (char *) "\n"
		"UpdateDurationColumn()\n"
		"\n"
		"Updates duration columns if the selected time unit changes.\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IPerformanceCounterViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.PerformanceCounterViewer",    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IPerformanceCounterViewer_type.as_number,     /* tp_as_number */
    &SwigPyBuiltin__IPerformanceCounterViewer_type.as_sequence,   /* tp_as_sequence */
    &SwigPyBuiltin__IPerformanceCounterViewer_type.as_mapping,    /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IPerformanceCounterViewer_type.as_buffer,     /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The performance counter view window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetPerformanceCounterViewer`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IPerformanceCounterViewer_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IPerformanceCounterViewer_methods,             /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IPerformanceCounterViewer_getset,              /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IPerformanceCounterViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IPerformanceCounterViewer_type};

static SwigPyGetSet PythonShell___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IPythonShell_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IPythonShell.__dict__", (void *) &PythonShell___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IPythonShell_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IPythonShell_methods[] = {
  { "Widget", (PyCFunction) _wrap_PythonShell_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`PythonShell` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetScriptText", (PyCFunction) _wrap_PythonShell_SetScriptText, METH_O, (char *) "\n"
		"SetScriptText(script)\n"
		"\n"
		"Sets the current script in the python shell to the given string.\n"
		"\n"
		":param str script: The text of the script to set.\n"
		"\n"
		"" },
  { "LoadScriptFromFilename", (PyCFunction) _wrap_PythonShell_LoadScriptFromFilename, METH_O, (char *) "\n"
		"LoadScriptFromFilename(filename)\n"
		"\n"
		"Sets the current script in the python shell to the contents of the given file.\n"
		"\n"
		":param str filename: The filename of the script to load.\n"
		":return: Whether or not the script was successfully loaded.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "GetScriptText", (PyCFunction) _wrap_PythonShell_GetScriptText, METH_NOARGS, (char *) "\n"
		"GetScriptText()\n"
		"\n"
		"Returns the current script text.\n"
		"\n"
		":return: The current script text.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "RunScript", (PyCFunction) _wrap_PythonShell_RunScript, METH_NOARGS, (char *) "\n"
		"RunScript()\n"
		"\n"
		"Runs the current script in the python shell.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IPythonShell_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.PythonShell",                 /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IPythonShell_type.as_number,                  /* tp_as_number */
    &SwigPyBuiltin__IPythonShell_type.as_sequence,                /* tp_as_sequence */
    &SwigPyBuiltin__IPythonShell_type.as_mapping,                 /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IPythonShell_type.as_buffer,                  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The interactive python shell.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.GetPythonShell`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IPythonShell_richcompare,        /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IPythonShell_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IPythonShell_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IPythonShell_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IPythonShell_type};

static SwigPyGetSet ShaderViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IShaderViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IShaderViewer.__dict__", (void *) &ShaderViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IShaderViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IShaderViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_ShaderViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`ShaderViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CurrentStep", (PyCFunction) _wrap_ShaderViewer_CurrentStep, METH_NOARGS, (char *) "\n"
		"CurrentStep()\n"
		"\n"
		"Retrieves the current step in the debugging.\n"
		"\n"
		":return: The current step.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "SetCurrentStep", (PyCFunction) _wrap_ShaderViewer_SetCurrentStep, METH_O, (char *) "\n"
		"SetCurrentStep(step)\n"
		"\n"
		"Sets the current step in the debugging.\n"
		"\n"
		":param int step: The current step to jump to.\n"
		"\n"
		"" },
  { "ToggleBreakpointOnInstruction", (PyCFunction) _wrap_ShaderViewer_ToggleBreakpointOnInstruction, METH_VARARGS, (char *) "\n"
		"ToggleBreakpointOnInstruction(instruction=-1)\n"
		"ToggleBreakpointOnInstruction()\n"
		"\n"
		"Toggles a breakpoint at a given instruction.\n"
		"\n"
		":param int instruction: The instruction to toggle breakpoint at. If this is ``-1`` the nearest\n"
		"  instruction after the current caret position is used.\n"
		"\n"
		"" },
  { "ToggleBreakpointOnDisassemblyLine", (PyCFunction) _wrap_ShaderViewer_ToggleBreakpointOnDisassemblyLine, METH_O, (char *) "\n"
		"ToggleBreakpointOnDisassemblyLine(disassemblyLine)\n"
		"\n"
		"Toggles a breakpoint at a given disassembly line (starting from 1).\n"
		"\n"
		":param int disassemblyLine: The line of the disassembly to toggle a breakpoint on.\n"
		"\n"
		"" },
  { "RunForward", (PyCFunction) _wrap_ShaderViewer_RunForward, METH_NOARGS, (char *) "\n"
		"RunForward()\n"
		"\n"
		"Runs execution forward to the next breakpoint, or the end of the trace.\n"
		"\n"
		"" },
  { "ShowErrors", (PyCFunction) _wrap_ShaderViewer_ShowErrors, METH_O, (char *) "\n"
		"ShowErrors(errors)\n"
		"\n"
		"Show a list of shader compilation errors or warnings.\n"
		"\n"
		":param str errors: The string of errors or warnings to display.\n"
		"\n"
		"" },
  { "AddWatch", (PyCFunction) _wrap_ShaderViewer_AddWatch, METH_O, (char *) "\n"
		"AddWatch(expression)\n"
		"\n"
		"Add an expression to the watch panel.\n"
		"\n"
		":param str expression: The name of the expression to watch.\n"
		"\n"
		"" },
  { "GetCurrentFileContents", (PyCFunction) _wrap_ShaderViewer_GetCurrentFileContents, METH_NOARGS, (char *) "\n"
		"GetCurrentFileContents()\n"
		"\n"
		"Return the current text of source files within the viewer. Primarily useful for\n"
		"returning any edits applied when editing a shader.\n"
		"\n"
		":return: The current file contents as a list of (filename, contents) pairs.\n"
		":rtype: List[Tuple[str,str]]\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IShaderViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ShaderViewer",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IShaderViewer_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__IShaderViewer_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__IShaderViewer_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IShaderViewer_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A shader window used for viewing, editing, or debugging.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.ViewShader`,\n"
		":meth:`CaptureContext.EditShader`, or :meth:`CaptureContext.DebugShader`.\n"
		"\n"
		".. function:: SaveCallback(context, viewer, encoding, flags, entry, compiled)\n"
		"\n"
		"  Not a member function - the signature for any ``SaveCallback`` callbacks.\n"
		"\n"
		"  Called whenever a shader viewer that was open for editing triggers a save/update.\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param ShaderViewer viewer: The open shader viewer.\n"
		"  :param renderdoc.ResourceId id: The id of the shader being replaced.\n"
		"  :param renderdoc.ShaderStage stage: The shader stage of the shader being replaced.\n"
		"  :param renderdoc.ShaderEncoding encoding: The encoding of the files being passed.\n"
		"  :param renderdoc.ShaderCompileFlags flags: The flags to use during compilation.\n"
		"  :param str entryFunc: The name of the entry point.\n"
		"  :param bytes source: The byte buffer containing the source - may just be text depending on the\n"
		"    encoding.\n"
		"\n"
		".. function:: RevertCallback(context)\n"
		"\n"
		"  Not a member function - the signature for any ``RevertCallback`` callbacks.\n"
		"\n"
		"  Called whenever a shader viewer that was open for editing is closed.\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param ShaderViewer viewer: The open shader viewer.\n"
		"  :param renderdoc.ResourceId id: The id of the shader being replaced.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IShaderViewer_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IShaderViewer_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IShaderViewer_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IShaderViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IShaderViewer_type};

static SwigPyGetSet ShaderMessageViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IShaderMessageViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IShaderMessageViewer.__dict__", (void *) &ShaderMessageViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IShaderMessageViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IShaderMessageViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_ShaderMessageViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`ShaderMessageViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "GetEvent", (PyCFunction) _wrap_ShaderMessageViewer_GetEvent, METH_NOARGS, (char *) "\n"
		"GetEvent()\n"
		"\n"
		"Return the EID that this viewer is displaying messages from.\n"
		"\n"
		":return: The EID.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "GetShaderMessages", (PyCFunction) _wrap_ShaderMessageViewer_GetShaderMessages, METH_NOARGS, (char *) "\n"
		"GetShaderMessages()\n"
		"\n"
		"Return the shader messages displayed in this viewer.\n"
		"\n"
		":return: The shader messages.\n"
		":rtype: List[renderdoc.ShaderMessage]\n"
		"\n"
		"" },
  { "IsOutOfDate", (PyCFunction) _wrap_ShaderMessageViewer_IsOutOfDate, METH_NOARGS, (char *) "\n"
		"IsOutOfDate()\n"
		"\n"
		"Returns whether or not this viewer is out of date - if the shaders have been edited\n"
		"since the messages were fetched.\n"
		"\n"
		":return: ``True`` if the viewer is out of date.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IShaderMessageViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ShaderMessageViewer",         /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IShaderMessageViewer_type.as_number,          /* tp_as_number */
    &SwigPyBuiltin__IShaderMessageViewer_type.as_sequence,        /* tp_as_sequence */
    &SwigPyBuiltin__IShaderMessageViewer_type.as_mapping,         /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IShaderMessageViewer_type.as_buffer,          /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A shader message list window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.ViewShaderMessages`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IShaderMessageViewer_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IShaderMessageViewer_methods,                  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IShaderMessageViewer_getset,                   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IShaderMessageViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IShaderMessageViewer_type};

static SwigPyGetSet DescriptorViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IDescriptorViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IDescriptorViewer.__dict__", (void *) &DescriptorViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IDescriptorViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IDescriptorViewer_methods[] = {
  { "Widget", (PyCFunction) _wrap_DescriptorViewer_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`DescriptorViewer` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IDescriptorViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.DescriptorViewer",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IDescriptorViewer_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__IDescriptorViewer_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__IDescriptorViewer_type.as_mapping,            /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IDescriptorViewer_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A descriptor viewer window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.ViewDescriptorStore` or :meth:`CaptureContext.ViewDescriptors`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IDescriptorViewer_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IDescriptorViewer_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IDescriptorViewer_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IDescriptorViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IDescriptorViewer_type};

static SwigPyGetSet PixelHistoryView___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IPixelHistoryView_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IPixelHistoryView.__dict__", (void *) &PixelHistoryView___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IPixelHistoryView_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IPixelHistoryView_methods[] = {
  { "Widget", (PyCFunction) _wrap_PixelHistoryView_Widget, METH_NOARGS, (char *) "\n"
		"Widget()\n"
		"\n"
		"Retrieves the PySide2 QWidget for this :class:`PixelHistoryView` if PySide2 is available, or otherwise\n"
		"returns a unique opaque pointer that can be passed back to any RenderDoc functions expecting a\n"
		"QWidget.\n"
		"\n"
		":return: Return the widget handle, either a PySide2 handle or an opaque handle.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetHistory", (PyCFunction) _wrap_PixelHistoryView_SetHistory, METH_O, (char *) "\n"
		"SetHistory(history)\n"
		"\n"
		"Set the history displayed in this window.\n"
		"\n"
		":param List[renderdoc.PixelModification] history: A list of pixel events to display.\n"
		"\n"
		"" },
  { "SetFailedDebug", (PyCFunction) _wrap_PixelHistoryView_SetFailedDebug, METH_NOARGS, (char *) "\n"
		"SetFailedDebug()\n"
		"\n"
		"Indicates that the pixel history was launched as a result of failing to debug a shader,\n"
		"so a message will be displayed to explain.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IPixelHistoryView_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.PixelHistoryView",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IPixelHistoryView_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__IPixelHistoryView_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__IPixelHistoryView_type.as_mapping,            /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IPixelHistoryView_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A pixel history window.\n"
		"\n"
		"This window is retrieved by calling :meth:`CaptureContext.ViewPixelHistory`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IPixelHistoryView_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IPixelHistoryView_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IPixelHistoryView_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IPixelHistoryView_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IPixelHistoryView_type};

static SwigPyGetSet CaptureViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ICaptureViewer_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ICaptureViewer.__dict__", (void *) &CaptureViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ICaptureViewer_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ICaptureViewer_methods[] = {
  { "OnCaptureLoaded", (PyCFunction) _wrap_CaptureViewer_OnCaptureLoaded, METH_NOARGS, (char *) "\n"
		"OnCaptureLoaded()\n"
		"\n"
		"Called whenever a capture is opened.\n"
		"" },
  { "OnCaptureClosed", (PyCFunction) _wrap_CaptureViewer_OnCaptureClosed, METH_NOARGS, (char *) "\n"
		"OnCaptureClosed()\n"
		"\n"
		"Called whenever a capture is closed.\n"
		"" },
  { "OnSelectedEventChanged", (PyCFunction) _wrap_CaptureViewer_OnSelectedEventChanged, METH_O, (char *) "\n"
		"OnSelectedEventChanged(eventId)\n"
		"\n"
		"Called whenever the current selected event changes. This is distinct from the actual\n"
		"effective current event, since for example selecting a marker region will change the current event\n"
		"to be the last event inside that region, to be consistent with selecting an item reflecting the\n"
		"current state after that item.\n"
		"\n"
		"The selected event shows the :data:`eventId <renderdoc.APIEvent.eventId>` that was actually selected,\n"
		"which will usually but not always be the same as the current effective\n"
		":data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"\n"
		"The distinction for this callback is not normally desired, instead use :meth:`OnEventChanged` to\n"
		"be notified whenever the current event changes. The API inspector uses this to display API events up\n"
		"to a marker region.\n"
		"\n"
		":param int eventId: The new :data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"\n"
		"" },
  { "OnEventChanged", (PyCFunction) _wrap_CaptureViewer_OnEventChanged, METH_O, (char *) "\n"
		"OnEventChanged(eventId)\n"
		"\n"
		"Called whenever the effective current event changes.\n"
		"\n"
		":param int eventId: The new :data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ICaptureViewer_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.CaptureViewer",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) &capviewer_deinit_destructor_closure,            /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ICaptureViewer_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__ICaptureViewer_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__ICaptureViewer_type.as_mapping,               /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ICaptureViewer_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "An interface implemented by any object wanting to be notified of capture events.",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ICaptureViewer_richcompare,      /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ICaptureViewer_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ICaptureViewer_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) &capviewer_init,               /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ICaptureViewer_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ICaptureViewer_type};

static SwigPyGetSet ReplayManager___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IReplayManager_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IReplayManager.__dict__", (void *) &ReplayManager___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IReplayManager_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IReplayManager_methods[] = {
  { "DeleteCapture", (PyCFunction) _wrap_ReplayManager_DeleteCapture, METH_VARARGS, (char *) "\n"
		"DeleteCapture(capturefile, local)\n"
		"\n"
		"Delete a capture file, whether local or remote.\n"
		"\n"
		":param str capturefile: The path to the file.\n"
		":param bool local: ``True`` if the file is on the local machine.\n"
		"\n"
		"" },
  { "ConnectToRemoteServer", (PyCFunction) _wrap_ReplayManager_ConnectToRemoteServer, METH_O, (char *) "\n"
		"ConnectToRemoteServer(host)\n"
		"\n"
		"Connect to a remote server.\n"
		"\n"
		":param RemoteHost host: The host to connect to.\n"
		":return: Whether or not the connection was successful.\n"
		":rtype: renderdoc.ResultDetails\n"
		"\n"
		"" },
  { "DisconnectFromRemoteServer", (PyCFunction) _wrap_ReplayManager_DisconnectFromRemoteServer, METH_NOARGS, (char *) "\n"
		"DisconnectFromRemoteServer()\n"
		"\n"
		"Disconnect from the server the manager is currently connected to.\n"
		"" },
  { "ShutdownServer", (PyCFunction) _wrap_ReplayManager_ShutdownServer, METH_NOARGS, (char *) "\n"
		"ShutdownServer()\n"
		"\n"
		"Shutdown the server the manager is currently connected to.\n"
		"" },
  { "PingRemote", (PyCFunction) _wrap_ReplayManager_PingRemote, METH_NOARGS, (char *) "\n"
		"PingRemote()\n"
		"\n"
		"Ping the remote server to ensure the connection is still alive.\n"
		"" },
  { "CancelReplayLoop", (PyCFunction) _wrap_ReplayManager_CancelReplayLoop, METH_NOARGS, (char *) "\n"
		"CancelReplayLoop()\n"
		"\n"
		"Cancels the active replay loop. See :meth:`~renderdoc.ReplayController.ReplayLoop`.\n"
		"" },
  { "CurrentRemote", (PyCFunction) _wrap_ReplayManager_CurrentRemote, METH_NOARGS, (char *) "\n"
		"CurrentRemote()\n"
		"\n"
		"Retrieves the host that the manager is currently connected to.\n"
		"\n"
		":return: The host connected to, or an invalid RemoteHost if no connection is active.\n"
		":rtype: RemoteHost\n"
		"\n"
		"" },
  { "GetCaptureAccess", (PyCFunction) _wrap_ReplayManager_GetCaptureAccess, METH_NOARGS, (char *) "\n"
		"GetCaptureAccess()\n"
		"\n"
		"Retrieves the capture access handle for the currently open file.\n"
		"\n"
		":return: The file handle active, or ``None`` if no capture is open.\n"
		":rtype: renderdoc.CaptureAccess\n"
		"\n"
		"" },
  { "GetCaptureFile", (PyCFunction) _wrap_ReplayManager_GetCaptureFile, METH_NOARGS, (char *) "\n"
		"GetCaptureFile()\n"
		"\n"
		"Retrieves the capture file handle for the currently open file, if it is available.\n"
		"\n"
		"If the capture is not open locally this will not be available, and only :meth:`GetCaptureAccess`\n"
		"will be usable.\n"
		"\n"
		":return: The file handle active, or ``None`` if no capture is open or the capture is only available\n"
		"  remotely.\n"
		":rtype: renderdoc.CaptureFile\n"
		"\n"
		"" },
  { "ExecuteAndInject", (PyCFunction) _wrap_ReplayManager_ExecuteAndInject, METH_VARARGS, (char *) "\n"
		"ExecuteAndInject(exe, workingDir, cmdLine, env, capturefile, opts)\n"
		"\n"
		"Launch an application and inject into it to allow capturing.\n"
		"\n"
		"This happens either locally, or on the remote server, depending on whether a connection is active.\n"
		"\n"
		":param str exe: The path to the executable to run.\n"
		":param str workingDir: The working directory to use when running the application. If blank, the\n"
		"  directory containing the executable is used.\n"
		":param str cmdLine: The command line to use when running the executable, it will be processed in a\n"
		"  platform specific way to generate arguments.\n"
		":param List[renderdoc.EnvironmentModification] env: Any environment changes that should be made when\n"
		"  running the program.\n"
		":param str capturefile: The location to save any captures, if running locally.\n"
		":param renderdoc.CaptureOptions opts: The capture options to use when injecting into the program.\n"
		":return: The :class:`~renderdoc.ExecuteResult` indicating both the status of the operation (success\n"
		"  or failure) and any reason for failure, or else the ident where the new application is listening\n"
		"  for target control if everything succeeded.\n"
		":rtype: renderdoc.ExecuteResult\n"
		"\n"
		"" },
  { "GetRemoteSupport", (PyCFunction) _wrap_ReplayManager_GetRemoteSupport, METH_NOARGS, (char *) "\n"
		"GetRemoteSupport()\n"
		"\n"
		"Retrieve a list of drivers that the current remote server supports.\n"
		"\n"
		":return: The list of supported replay drivers.\n"
		":rtype: List[str]\n"
		"\n"
		"" },
  { "GetHomeFolder", (PyCFunction) _wrap_ReplayManager_GetHomeFolder, METH_VARARGS, (char *) "\n"
		"GetHomeFolder(synchronous, callback)\n"
		"\n"
		"Query the remote host for its home directory.\n"
		"\n"
		"If a capture is open, the callback will happen on the replay thread, otherwise it will happen in a\n"
		"blocking fashion on the current thread.\n"
		"\n"
		":param bool synchronous: If a capture is open, then ``True`` will use :meth:`BlockInvoke` to call\n"
		"  the callback. Otherwise if ``False`` then :meth:`AsyncInvoke` will be used.\n"
		":param DirectoryBrowseCallback callback: The function to callback on the replay thread.\n"
		"  Callback function signature must match :func:`DirectoryBrowseCallback`.\n"
		"\n"
		"" },
  { "ListFolder", (PyCFunction) _wrap_ReplayManager_ListFolder, METH_VARARGS, (char *) "\n"
		"ListFolder(path, synchronous, callback)\n"
		"\n"
		"Query the remote host for the contents of a path.\n"
		"\n"
		"If a capture is open, the callback will happen on the replay thread, otherwise it will happen in a\n"
		"blocking fashion on the current thread.\n"
		"\n"
		":param str path: The path to query the contents of.\n"
		":param bool synchronous: If a capture is open, then ``True`` will use :meth:`BlockInvoke` to call\n"
		"  the callback. Otherwise if ``False`` then :meth:`AsyncInvoke` will be used.\n"
		":param DirectoryBrowseCallback callback: The function to callback on the replay thread.\n"
		"  Callback function signature must match :func:`DirectoryBrowseCallback`.\n"
		"\n"
		"" },
  { "CopyCaptureToRemote", (PyCFunction) _wrap_ReplayManager_CopyCaptureToRemote, METH_VARARGS, (char *) "\n"
		"CopyCaptureToRemote(localpath, window)\n"
		"\n"
		"Copy a capture from the local machine to the remote host.\n"
		"\n"
		":param str localpath: The path on the local machine to copy from.\n"
		":param QWidget window: A handle to the window to use when showing a progress bar.\n"
		":return: The path on the local machine where the file was saved, or empty if something went wrong.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "CopyCaptureFromRemote", (PyCFunction) _wrap_ReplayManager_CopyCaptureFromRemote, METH_VARARGS, (char *) "\n"
		"CopyCaptureFromRemote(remotepath, localpath, window)\n"
		"\n"
		"Copy a capture from the remote host to the local machine.\n"
		"\n"
		":param str remotepath: The path on the remote server to copy from.\n"
		":param str localpath: The path on the local machine to copy to.\n"
		":param QWidget window: A handle to the window to use when showing a progress bar.\n"
		"\n"
		"" },
  { "GetCurrentProcessingTime", (PyCFunction) _wrap_ReplayManager_GetCurrentProcessingTime, METH_NOARGS, (char *) "\n"
		"GetCurrentProcessingTime()\n"
		"\n"
		"Return the amount of time that the currently active command on the replay thread has\n"
		"been executing for.\n"
		"\n"
		"This can be used to identify if a command is long-running to display a progress bar or notification.\n"
		"\n"
		":return: The time in seconds that the current command has been executing for, or 0.0 if no command\n"
		"  is executing.\n"
		":rtype: float\n"
		"\n"
		"" },
  { "AsyncInvoke", (PyCFunction) _wrap_ReplayManager_AsyncInvoke, METH_VARARGS, (char *) "\n"
		"AsyncInvoke(tag, method)\n"
		"AsyncInvoke(method)\n"
		"\n"
		"Make a tagged non-blocking invoke call onto the replay thread.\n"
		"\n"
		"This tagged function is for cases when we might send a request - e.g. to pick a vertex or pixel -\n"
		"and want to pre-empt it with a new request before the first has returned. Either because some\n"
		"other work is taking a while or because we're sending requests faster than they can be\n"
		"processed.\n"
		"\n"
		"The manager processes only the request on the top of the queue, so when a new tagged invoke\n"
		"comes in, we remove any other requests in the queue before it that have the same tag.\n"
		"\n"
		":param str tag: The tag to identify this callback.\n"
		":param InvokeCallback method: The function to callback on the replay thread.\n"
		"  Callback function signature must match :func:`InvokeCallback`.\n"
		"\n"
		"" },
  { "BlockInvoke", (PyCFunction) _wrap_ReplayManager_BlockInvoke, METH_O, (char *) "\n"
		"BlockInvoke(m)\n"
		"\n"
		"Make a blocking invoke call onto the replay thread.\n"
		"\n"
		":param InvokeCallback method: The function to callback on the replay thread.\n"
		"  Callback function signature must match :func:`InvokeCallback`.\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IReplayManager_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ReplayManager",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IReplayManager_type.as_number,                /* tp_as_number */
    &SwigPyBuiltin__IReplayManager_type.as_sequence,              /* tp_as_sequence */
    &SwigPyBuiltin__IReplayManager_type.as_mapping,               /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IReplayManager_type.as_buffer,                /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A manager for accessing the underlying replay information that isn't already abstracted\n"
		"in UI side structures. This manager controls and serialises access to the underlying\n"
		":class:`~renderdoc.ReplayController`, as well as handling remote server connections.\n"
		"\n"
		"This manager is retrieved by calling :meth:`CaptureContext.Replay`.\n"
		"\n"
		".. function:: InvokeCallback(controller)\n"
		"\n"
		"  Not a member function - the signature for any ``InvokeCallback`` callbacks.\n"
		"\n"
		"  :param renderdoc.ReplayController controller: The controller to access. Must not be cached or\n"
		"    used after the callback returns.\n"
		"\n"
		".. function:: DirectoryBrowseCallback(path, entries)\n"
		"\n"
		"  Not a member function - the signature for any ``DirectoryBrowseCallback`` callbacks.\n"
		"\n"
		"  :param str path: The path that was queried for.\n"
		"  :param List[renderdoc.PathEntry] entries: The entries underneath the path, as relevant.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IReplayManager_richcompare,      /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IReplayManager_methods,    /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IReplayManager_getset,     /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IReplayManager_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IReplayManager_type};

static SwigPyGetSet DockReference___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__DockReference_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"DockReference.__dict__", (void *) &DockReference___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__DockReference_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__DockReference_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__DockReference_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "DockReference",                          /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_DockReference_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__DockReference_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__DockReference_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__DockReference_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__DockReference_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Specifies the relationship between the existing dock window and the new one when adding\n"
		"a new dock window or moving an existing dock window.\n"
		"\n"
		".. data:: LastUsedArea\n"
		"\n"
		"  The existing dock window is not used, the new dock window is placed wherever the last dock window\n"
		"  was placed.\n"
		"\n"
		".. data:: NewFloatingArea\n"
		"\n"
		"  The existing dock window is not used, the new dock window is placed in a new floating area.\n"
		"\n"
		".. data:: EmptySpace\n"
		"\n"
		"  The existing dock window is not used, the new dock window is placed in empty area in the dockarea.\n"
		"\n"
		".. data:: NoArea\n"
		"\n"
		"  The existing dock window is not used, the new window is hidden.\n"
		"\n"
		".. data:: AddTo\n"
		"\n"
		"  The new dock window is placed in a tab set with the existing dock window.\n"
		"\n"
		".. data:: LeftOf\n"
		"\n"
		"  The new dock window is placed to the left of the existing dock window, at a specified proportion.\n"
		"\n"
		".. data:: RightOf\n"
		"\n"
		"  The new dock window is placed to the right of the existing dock window, at a specified proportion.\n"
		"\n"
		".. data:: TopOf\n"
		"\n"
		"  The new dock window is placed above the existing dock window, at a specified proportion.\n"
		"\n"
		".. data:: BottomOf\n"
		"\n"
		"  The new dock window is placed below the existing dock window, at a specified proportion.\n"
		"\n"
		".. data:: LeftWindowSide\n"
		"\n"
		"  The new dock window is placed left of *all* docks in the window, at a specified proportion.\n"
		"\n"
		".. data:: RightWindowSide\n"
		"\n"
		"  The new dock window is placed right of *all* docks in the window, at a specified proportion.\n"
		"\n"
		".. data:: TopWindowSide\n"
		"\n"
		"  The new dock window is placed above *all* docks in the window, at a specified proportion.\n"
		"\n"
		".. data:: BottomWindowSide\n"
		"\n"
		"  The new dock window is placed below *all* docks in the window, at a specified proportion.\n"
		"\n"
		".. data:: MainToolArea\n"
		"\n"
		"  The new dock window is placed in the 'main' tool area as defined by finding an existing known\n"
		"  window and using that as the main area. In the default layout this is where most windows are\n"
		"  placed.\n"
		"\n"
		".. data:: LeftToolArea\n"
		"\n"
		"  The new dock window is placed in the 'left' tool area as defined by finding an existing known\n"
		"  window and using that as the main area, then adding to the left of that. In the default layout\n"
		"  this is where the event browser is placed.\n"
		"\n"
		".. data:: TransientPopupArea\n"
		"\n"
		"  The new dock window is docked with other similar transient views like constant buffer or pixel\n"
		"  history windows, if they exist, or else docked to the right of the main window.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__DockReference_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__DockReference_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__DockReference_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_DockReference,       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__DockReference_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__DockReference_type};

static SwigPyGetSet CaptureModifications___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__CaptureModifications_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"CaptureModifications.__dict__", (void *) &CaptureModifications___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__CaptureModifications_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__CaptureModifications_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__CaptureModifications_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "CaptureModifications",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_CaptureModifications_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__CaptureModifications_type.as_number,          /* tp_as_number */
    &SwigPyBuiltin__CaptureModifications_type.as_sequence,        /* tp_as_sequence */
    &SwigPyBuiltin__CaptureModifications_type.as_mapping,         /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__CaptureModifications_type.as_buffer,          /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Details any changes that have been made to a capture in the UI which can be saved to\n"
		"disk but currently aren't. Note that detection is conservative - e.g. if a change is made, then\n"
		"cancelled out by reversing the change, this will still count as 'modified' even if the end result is\n"
		"the same data. In that sense it's analogous to adding and then deleting some characters in a text\n"
		"editor, since there is no actual undo system.\n"
		"\n"
		"This is a bitmask, so several values can be present at once.\n"
		"\n"
		".. data:: NoModifications\n"
		"\n"
		"  Fixed value of 0 indicating no modifications have been made.\n"
		"\n"
		".. data:: Renames\n"
		"\n"
		"  One or more resources have been given a custom name which hasn't been saved.\n"
		"\n"
		".. data:: Bookmarks\n"
		"\n"
		"  Event bookmarks have been added or removed.\n"
		"\n"
		".. data:: Notes\n"
		"\n"
		"  The general notes field has been changed.\n"
		"\n"
		".. data:: EditedShaders\n"
		"\n"
		"  There are shader editing changes (new edits or reverts).\n"
		"\n"
		".. data:: All\n"
		"\n"
		"  Fixed value with all bits set, indication all modifications have been made.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__CaptureModifications_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__CaptureModifications_methods,                  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__CaptureModifications_getset,                   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_CaptureModifications,/* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__CaptureModifications_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__CaptureModifications_type};

static SwigPyGetSet EventBookmark___dict___getset = { SwigPyObject_get___dict__, 0 };
static SwigPyGetSet EventBookmark_text_getset = { _wrap_EventBookmark_text_get, _wrap_EventBookmark_text_set };
static SwigPyGetSet EventBookmark_eventId_getset = { _wrap_EventBookmark_eventId_get, _wrap_EventBookmark_eventId_set };
SWIGINTERN PyGetSetDef SwigPyBuiltin__EventBookmark_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"EventBookmark.__dict__", (void *) &EventBookmark___dict___getset }
,
    { (char *) "text", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The text associated with this bookmark - could be empty\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &EventBookmark_text_getset }
,
    { (char *) "eventId", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The :data:`eventId <renderdoc.APIEvent.eventId>` at which this bookmark is placed.\n"
		"\n"
		":type: int\n"
		"\n"
		"", (void *) &EventBookmark_eventId_getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__EventBookmark_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_EventBookmark___eq__(self, other); break;
    case Py_NE : result = _wrap_EventBookmark___ne__(self, other); break;
    case Py_LT : result = _wrap_EventBookmark___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__EventBookmark_methods[] = {
  { "__eq__", (PyCFunction) _wrap_EventBookmark___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_EventBookmark___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_EventBookmark___lt__, METH_O, (char *) "__lt__(o)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__EventBookmark_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.EventBookmark",               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_EventBookmark_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__EventBookmark_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__EventBookmark_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__EventBookmark_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__EventBookmark_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "A description of a bookmark on an event",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__EventBookmark_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__EventBookmark_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__EventBookmark_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_EventBookmark,       /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__EventBookmark_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__EventBookmark_type};

static SwigPyGetSet RGPInterop___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IRGPInterop_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IRGPInterop.__dict__", (void *) &RGPInterop___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IRGPInterop_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IRGPInterop_methods[] = {
  { "HasRGPEvent", (PyCFunction) _wrap_RGPInterop_HasRGPEvent, METH_O, (char *) "\n"
		"HasRGPEvent(eventId)\n"
		"\n"
		"Return true if the given :data:`eventId <renderdoc.APIEvent.eventId>` has and\n"
		"equivalent in RGP.\n"
		"\n"
		":param int eventId: The :data:`eventId <renderdoc.APIEvent.eventId>` to query for.\n"
		":return: ``True`` if there is an equivalent. This only confirms the equivalent exists, not that it\n"
		"  will be selectable in all cases.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "SelectRGPEvent", (PyCFunction) _wrap_RGPInterop_SelectRGPEvent, METH_O, (char *) "\n"
		"SelectRGPEvent(eventId)\n"
		"\n"
		"Select the given :data:`eventId <renderdoc.APIEvent.eventId>` equivalent in RGP.\n"
		"\n"
		":param int eventId: The :data:`eventId <renderdoc.APIEvent.eventId>` to query for.\n"
		":return: ``True`` if the selection request succeeded. This only confirms the request was sent, not\n"
		"  that the event was selected in RGP.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IRGPInterop_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.RGPInterop",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_RGPInterop_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IRGPInterop_type.as_number,                   /* tp_as_number */
    &SwigPyBuiltin__IRGPInterop_type.as_sequence,                 /* tp_as_sequence */
    &SwigPyBuiltin__IRGPInterop_type.as_mapping,                  /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IRGPInterop_type.as_buffer,                   /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "Controlling interface for interop with RGP tool.",           /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IRGPInterop_richcompare,         /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IRGPInterop_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IRGPInterop_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IRGPInterop_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IRGPInterop_type};

static SwigPyGetSet CaptureContext___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ICaptureContext_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ICaptureContext.__dict__", (void *) &CaptureContext___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ICaptureContext_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ICaptureContext_methods[] = {
  { "TempCaptureFilename", (PyCFunction) _wrap_CaptureContext_TempCaptureFilename, METH_O, (char *) "\n"
		"TempCaptureFilename(appname)\n"
		"\n"
		"Retrieve the absolute path where a given temporary capture should be stored.\n"
		"data.\n"
		"\n"
		":param str appname: The name of the application to use as part of the template.\n"
		":return: The absolute path.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "LoadCapture", (PyCFunction) _wrap_CaptureContext_LoadCapture, METH_VARARGS, (char *) "\n"
		"LoadCapture(captureFile, opts, origFilename, temporary, local)\n"
		"\n"
		"Open a capture file for replay.\n"
		"\n"
		":param str captureFile: The actual path to the capture file.\n"
		":param renderdoc.ReplayOptions opts: The options controlling how the capture should be replayed.\n"
		":param str origFilename: The original filename, if the capture was copied remotely for replay.\n"
		":param bool temporary: ``True`` if this is a temporary capture which should prompt the user for\n"
		"  either save or delete on close.\n"
		":param bool local: ``True`` if ``captureFile`` refers to a file on the local machine.\n"
		"\n"
		"" },
  { "SaveCaptureTo", (PyCFunction) _wrap_CaptureContext_SaveCaptureTo, METH_O, (char *) "\n"
		"SaveCaptureTo(captureFile)\n"
		"\n"
		"Saves the current capture file to a given path.\n"
		"\n"
		"If the capture was temporary, this save action means it is no longer temporary and will be treated\n"
		"like any other capture.\n"
		"\n"
		"Any modifications to the capture (see :meth:`GetCaptureModifications`) will be applied at the same\n"
		"time.\n"
		"\n"
		":param str captureFile: The path to save the capture file to.\n"
		":return: ``True`` if the save operation was successful.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "RecompressCapture", (PyCFunction) _wrap_CaptureContext_RecompressCapture, METH_NOARGS, (char *) "\n"
		"RecompressCapture()\n"
		"\n"
		"Recompress the current capture as much as possible.\n"
		"" },
  { "CloseCapture", (PyCFunction) _wrap_CaptureContext_CloseCapture, METH_NOARGS, (char *) "\n"
		"CloseCapture()\n"
		"\n"
		"Close the currently open capture file.\n"
		"" },
  { "ImportCapture", (PyCFunction) _wrap_CaptureContext_ImportCapture, METH_VARARGS, (char *) "\n"
		"ImportCapture(fmt, importfile, rdcfile)\n"
		"\n"
		"Imports a capture file from a non-native format, via conversion to temporary rdc.\n"
		"\n"
		"This converts the file to a specified temporary .rdc and loads it, closing any existing capture.\n"
		"\n"
		"The capture must be available locally, if it's not this function will fail.\n"
		"\n"
		":param renderdoc.CaptureFileFormat fmt: The capture file format to import from.\n"
		":param str importfile: The path to import from.\n"
		":param str rdcfile: The temporary path to save the rdc file to.\n"
		":return: ``True`` if the import operation was successful and the capture was loaded.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "ExportCapture", (PyCFunction) _wrap_CaptureContext_ExportCapture, METH_VARARGS, (char *) "\n"
		"ExportCapture(fmt, exportfile)\n"
		"\n"
		"Exports the current capture file to a given path with a specified capture file format.\n"
		"\n"
		"The capture must be available locally, if it's not this function will fail.\n"
		"\n"
		":param renderdoc.CaptureFileFormat fmt: The capture file format to export to.\n"
		":param str exportfile: The path to export the capture file to.\n"
		"\n"
		"" },
  { "SetEventID", (PyCFunction) _wrap_CaptureContext_SetEventID, METH_VARARGS, (char *) "\n"
		"SetEventID(exclude, selectedEventId, eventId, force=False)\n"
		"SetEventID(exclude, selectedEventId, eventId)\n"
		"\n"
		"Move the current replay to a new event in the capture.\n"
		"\n"
		":param List[CaptureViewer] exclude: A list of viewers to exclude from being notified of this change,\n"
		"  to stop infinite recursion.\n"
		":param int selectedEventId: The selected :data:`eventId <renderdoc.APIEvent.eventId>`. See\n"
		"  :meth:`CaptureViewer.OnSelectedEventChanged` for more information.\n"
		":param int eventId: The new current :data:`eventId <renderdoc.APIEvent.eventId>`. See\n"
		"  :meth:`CaptureViewer.OnEventChanged` for more information.\n"
		":param bool force: Optional parameter, if ``True`` then the replay will 'move' even if it is moving\n"
		"  to the same :data:`eventId <renderdoc.APIEvent.eventId>` as it's currently on.\n"
		"\n"
		"" },
  { "RefreshStatus", (PyCFunction) _wrap_CaptureContext_RefreshStatus, METH_NOARGS, (char *) "\n"
		"RefreshStatus()\n"
		"\n"
		"Replay the capture to the current event again, to pick up any changes that might have\n"
		"been made.\n"
		"\n"
		"" },
  { "IsResourceReplaced", (PyCFunction) _wrap_CaptureContext_IsResourceReplaced, METH_O, (char *) "\n"
		"IsResourceReplaced(id)\n"
		"\n"
		"Determine if a resource has been replaced. See :meth:`RegisterReplacement`.\n"
		"\n"
		":param renderdoc.ResourceId id: The id of the resource to check.\n"
		":return: ``True`` if the resource has been replaced.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "GetResourceReplacement", (PyCFunction) _wrap_CaptureContext_GetResourceReplacement, METH_O, (char *) "\n"
		"GetResourceReplacement(id)\n"
		"\n"
		"Return the id of a replacement for the given resource. See\n"
		":meth:`RegisterReplacement` and :meth:`IsResourceReplaced`.\n"
		"\n"
		":param renderdoc.ResourceId id: The id of the resource to check.\n"
		":return: The replacement id, or a null id if the resource hasn't been replaced\n"
		":rtype: renderdoc.ResourceId\n"
		"\n"
		"" },
  { "RegisterReplacement", (PyCFunction) _wrap_CaptureContext_RegisterReplacement, METH_VARARGS, (char *) "\n"
		"RegisterReplacement(arg2, to)\n"
		"\n"
		"Register that a resource has replaced, so that the UI can be updated to reflect the\n"
		"change.\n"
		"\n"
		"This should be called at the same time as :meth:`ReplayController.ReplaceResource`.\n"
		"\n"
		":param renderdoc.ResourceId from: The id of the resource being replaced.\n"
		":param renderdoc.ResourceId to: The id of the resource replacing it.\n"
		"\n"
		"" },
  { "UnregisterReplacement", (PyCFunction) _wrap_CaptureContext_UnregisterReplacement, METH_O, (char *) "\n"
		"UnregisterReplacement(id)\n"
		"\n"
		"Register that a replacement has been removed, so that the UI can be updated to reflect\n"
		"the change.\n"
		"\n"
		"This should be called at the same time as :meth:`ReplayController.RemoveReplacement`.\n"
		"\n"
		"See :meth:`ReplaceResource`.\n"
		"\n"
		":param renderdoc.ResourceId id: The id of the original resource that was previously replaced.\n"
		"\n"
		"" },
  { "AddCaptureViewer", (PyCFunction) _wrap_CaptureContext_AddCaptureViewer, METH_O, (char *) "\n"
		"AddCaptureViewer(viewer)\n"
		"\n"
		"Register a new instance of :class:`CaptureViewer` to receive capture event notifications.\n"
		"\n"
		":param CaptureViewer viewer: The viewer to register.\n"
		"\n"
		"" },
  { "RemoveCaptureViewer", (PyCFunction) _wrap_CaptureContext_RemoveCaptureViewer, METH_O, (char *) "\n"
		"RemoveCaptureViewer(viewer)\n"
		"\n"
		"Unregister an instance of :class:`CaptureViewer` from receiving notifications.\n"
		"\n"
		":param CaptureViewer viewer: The viewer to unregister.\n"
		"\n"
		"" },
  { "Replay", (PyCFunction) _wrap_CaptureContext_Replay, METH_NOARGS, (char *) "\n"
		"Replay()\n"
		"\n"
		"Retrieve the replay manager for access to the internal RenderDoc replay controller.\n"
		"\n"
		":return: The current replay manager.\n"
		":rtype: ReplayManager\n"
		"\n"
		"" },
  { "ConnectToRemoteServer", (PyCFunction) _wrap_CaptureContext_ConnectToRemoteServer, METH_O, (char *) "\n"
		"ConnectToRemoteServer(host)\n"
		"\n"
		"Connect to a remote server.\n"
		"\n"
		":param RemoteHost host: The host to connect to.\n"
		"\n"
		"" },
  { "IsCaptureLoaded", (PyCFunction) _wrap_CaptureContext_IsCaptureLoaded, METH_NOARGS, (char *) "\n"
		"IsCaptureLoaded()\n"
		"\n"
		"Check whether or not a capture is currently loaded.\n"
		"\n"
		":return: ``True`` if a capture is loaded.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsCaptureLocal", (PyCFunction) _wrap_CaptureContext_IsCaptureLocal, METH_NOARGS, (char *) "\n"
		"IsCaptureLocal()\n"
		"\n"
		"Check whether or not the current capture is stored locally, or on a remote host.\n"
		"\n"
		":return: ``True`` if a capture is local.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsCaptureTemporary", (PyCFunction) _wrap_CaptureContext_IsCaptureTemporary, METH_NOARGS, (char *) "\n"
		"IsCaptureTemporary()\n"
		"\n"
		"Check whether or not the current capture is considered temporary. Captures that were\n"
		"made by an application and then have not been explicitly saved anywhere are temporary and will be\n"
		"cleaned up on close (with a final prompt to save). Once they are save to disk, they are no longer\n"
		"temporary and treated like any other capture.\n"
		"\n"
		":return: ``True`` if a capture is temporary.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsCaptureLoading", (PyCFunction) _wrap_CaptureContext_IsCaptureLoading, METH_NOARGS, (char *) "\n"
		"IsCaptureLoading()\n"
		"\n"
		"Check whether or not a capture is currently loading in-progress.\n"
		"\n"
		":return: ``True`` if a capture is currently loading.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "GetFatalError", (PyCFunction) _wrap_CaptureContext_GetFatalError, METH_NOARGS, (char *) "\n"
		"GetFatalError()\n"
		"\n"
		"If a capture is loaded, return the current fatal error status.\n"
		"\n"
		":return: If a capture is currently loaded, return the fatal error status.\n"
		":rtype: renderdoc.ResultDetails\n"
		"\n"
		"" },
  { "GetCaptureFilename", (PyCFunction) _wrap_CaptureContext_GetCaptureFilename, METH_NOARGS, (char *) "\n"
		"GetCaptureFilename()\n"
		"\n"
		"Retrieve the filename for the currently loaded capture.\n"
		"\n"
		":return: The filename of the current capture.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "GetCaptureModifications", (PyCFunction) _wrap_CaptureContext_GetCaptureModifications, METH_NOARGS, (char *) "\n"
		"GetCaptureModifications()\n"
		"\n"
		"Get a bitmask indicating which modifications (if any) have been made to the capture in\n"
		"the UI which aren't reflected in the capture file on disk.\n"
		"\n"
		":return: The modifications (if any) that have been made to the capture.\n"
		":rtype: CaptureModifications\n"
		"\n"
		"" },
  { "FrameInfo", (PyCFunction) _wrap_CaptureContext_FrameInfo, METH_NOARGS, (char *) "\n"
		"FrameInfo()\n"
		"\n"
		"Retrieve the :class:`~renderdoc.FrameDescription` for the currently loaded capture.\n"
		"\n"
		":return: The frame information.\n"
		":rtype: renderdoc.FrameDescription\n"
		"\n"
		"" },
  { "APIProps", (PyCFunction) _wrap_CaptureContext_APIProps, METH_NOARGS, (char *) "\n"
		"APIProps()\n"
		"\n"
		"Retrieve the :class:`~renderdoc.APIProperties` for the currently loaded capture.\n"
		"\n"
		":return: The API properties.\n"
		":rtype: renderdoc.APIProperties\n"
		"\n"
		"" },
  { "TargetShaderEncodings", (PyCFunction) _wrap_CaptureContext_TargetShaderEncodings, METH_NOARGS, (char *) "\n"
		"TargetShaderEncodings()\n"
		"\n"
		"Retrieve the list of :class:`~renderdoc.ShaderEncoding` that are available for\n"
		"building target shaders for the currently loaded capture. See\n"
		":meth:`~renderdoc.ReplayController.BuildTargetShader`.\n"
		"\n"
		":return: The available encodings.\n"
		":rtype: List[renderdoc.ShaderEncoding]\n"
		"\n"
		"" },
  { "CustomShaderEncodings", (PyCFunction) _wrap_CaptureContext_CustomShaderEncodings, METH_NOARGS, (char *) "\n"
		"CustomShaderEncodings()\n"
		"\n"
		"Retrieve the list of :class:`~renderdoc.ShaderEncoding` that are available for\n"
		"building custom shaders for the currently loaded capture. See\n"
		":meth:`~renderdoc.ReplayController.BuildCustomShader`.\n"
		"\n"
		":return: The available encodings.\n"
		":rtype: List[renderdoc.ShaderEncoding]\n"
		"\n"
		"" },
  { "CustomShaderSourcePrefixes", (PyCFunction) _wrap_CaptureContext_CustomShaderSourcePrefixes, METH_NOARGS, (char *) "\n"
		"CustomShaderSourcePrefixes()\n"
		"\n"
		"Retrieve the list of prefixes for each :class:`~renderdoc.ShaderEncoding` that should\n"
		"be added to custom compiled shaders. See\n"
		":meth:`~renderdoc.ReplayController.GetCustomShaderSourcePrefixes`.\n"
		"\n"
		":return: A list of pairs, listing a prefix for each shader encoding referenced.\n"
		":rtype: List[renderdoc.ShaderSourcePrefix]\n"
		"\n"
		"" },
  { "CurSelectedEvent", (PyCFunction) _wrap_CaptureContext_CurSelectedEvent, METH_NOARGS, (char *) "\n"
		"CurSelectedEvent()\n"
		"\n"
		"Retrieve the currently selected :data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"\n"
		"In most cases, prefer using :meth:`CurEvent`. See :meth:`CaptureViewer.OnSelectedEventChanged` for more\n"
		"information for how this differs.\n"
		"\n"
		":return: The current selected event.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "CurEvent", (PyCFunction) _wrap_CaptureContext_CurEvent, METH_NOARGS, (char *) "\n"
		"CurEvent()\n"
		"\n"
		"Retrieve the current :data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"\n"
		":return: The current event.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "CurSelectedAction", (PyCFunction) _wrap_CaptureContext_CurSelectedAction, METH_NOARGS, (char *) "\n"
		"CurSelectedAction()\n"
		"\n"
		"Retrieve the currently selected action.\n"
		"\n"
		"In most cases, prefer using :meth:`CurAction`. See :meth:`CaptureViewer.OnSelectedEventChanged` for\n"
		"more information for how this differs.\n"
		"\n"
		":return: The currently selected action.\n"
		":rtype: renderdoc.ActionDescription\n"
		"\n"
		"" },
  { "CurAction", (PyCFunction) _wrap_CaptureContext_CurAction, METH_NOARGS, (char *) "\n"
		"CurAction()\n"
		"\n"
		"Retrieve the current action.\n"
		"\n"
		":return: The current action, or ``None`` if no action is selected.\n"
		":rtype: renderdoc.ActionDescription\n"
		"\n"
		"" },
  { "GetFirstAction", (PyCFunction) _wrap_CaptureContext_GetFirstAction, METH_NOARGS, (char *) "\n"
		"GetFirstAction()\n"
		"\n"
		"Retrieve the first action in the capture.\n"
		"\n"
		":return: The first action.\n"
		":rtype: renderdoc.ActionDescription\n"
		"\n"
		"" },
  { "GetLastAction", (PyCFunction) _wrap_CaptureContext_GetLastAction, METH_NOARGS, (char *) "\n"
		"GetLastAction()\n"
		"\n"
		"Retrieve the last action in the capture.\n"
		"\n"
		":return: The last action.\n"
		":rtype: renderdoc.ActionDescription\n"
		"\n"
		"" },
  { "CurRootActions", (PyCFunction) _wrap_CaptureContext_CurRootActions, METH_NOARGS, (char *) "\n"
		"CurRootActions()\n"
		"\n"
		"Retrieve the root list of actions in the current capture.\n"
		"\n"
		":return: The root actions.\n"
		":rtype: List[renderdoc.ActionDescription]\n"
		"\n"
		"" },
  { "GetResource", (PyCFunction) _wrap_CaptureContext_GetResource, METH_O, (char *) "\n"
		"GetResource(id)\n"
		"\n"
		"Retrieve the information about a particular resource.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to query about.\n"
		":return: The information about a resource, or ``None`` if the ID does not correspond to a resource.\n"
		":rtype: renderdoc.ResourceDescription\n"
		"\n"
		"" },
  { "GetResources", (PyCFunction) _wrap_CaptureContext_GetResources, METH_NOARGS, (char *) "\n"
		"GetResources()\n"
		"\n"
		"Retrieve the list of resources in the current capture.\n"
		"\n"
		":return: The list of resources.\n"
		":rtype: List[renderdoc.ResourceDescription]\n"
		"\n"
		"" },
  { "GetResourceName", (PyCFunction) _wrap_CaptureContext_GetResourceName, METH_O, (char *) "\n"
		"GetResourceName(id)\n"
		"\n"
		"Retrieve the human-readable name for the resource to display.\n"
		"\n"
		"This will first check to see if a custom name has been set for the resource, and if so use that. See\n"
		":meth:`SetResourceCustomName`. If no custom name has been set, it will use the resource name found\n"
		"in the capture, either a name set via API-specific debug methods, or an auto-generated name based on\n"
		"the resource type.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to query.\n"
		":return: The current name of the resource.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "GetResourceNameUnsuffixed", (PyCFunction) _wrap_CaptureContext_GetResourceNameUnsuffixed, METH_O, (char *) "\n"
		"GetResourceNameUnsuffixed(id)\n"
		"\n"
		"Returns the same name as :meth:`GetResourceName` but without any added suffix, e.g. to\n"
		"indicate the resource's status such as (Edited).\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to query.\n"
		":return: The unsuffixed resource name.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "IsAutogeneratedName", (PyCFunction) _wrap_CaptureContext_IsAutogeneratedName, METH_O, (char *) "\n"
		"IsAutogeneratedName(id)\n"
		"\n"
		"Determines whether the name for the given resource has been customised at all, either\n"
		"during capture time or with :meth:`SetResourceCustomName`.\n"
		"\n"
		"If not, the name is just auto-generated based on the ID and resource type, so depending on\n"
		"circumstance it may be preferable to omit the name.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to query.\n"
		":return: Whether the name for the resource has just been auto-generated.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasResourceCustomName", (PyCFunction) _wrap_CaptureContext_HasResourceCustomName, METH_O, (char *) "\n"
		"HasResourceCustomName(id)\n"
		"\n"
		"Checks whether a runtime custom name has been set with :meth:`SetResourceCustomName`.\n"
		"\n"
		"In general, :meth:`IsAutogeneratedName` should be preferred to check if the resource name is default\n"
		"generated just from the ID, or if it has been set to some human readable name. This function will\n"
		"only check if a name has been set in the UI itself, a resource could still have a custom name that\n"
		"was set programmatically during capture time.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to query.\n"
		":return: Whether the name for the resource has been customised with :meth:`SetResourceCustomName`.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "SetResourceCustomName", (PyCFunction) _wrap_CaptureContext_SetResourceCustomName, METH_VARARGS, (char *) "\n"
		"SetResourceCustomName(id, name)\n"
		"\n"
		"Set a custom name for a resource.\n"
		"\n"
		"This allows an override to the name returned by :meth:`GetResourceName`, most useful when there are\n"
		"no pre-existing debug names specified in the capture.\n"
		"\n"
		"To remove a custom name that has been set previously, specify the empty string as the name. Then the\n"
		"custom name will be removed, and instead :meth:`GetResourceName` will fall back to returning any\n"
		"name fetched from the capture.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the resource to name.\n"
		":param str name: The name to provide, or an empty string to remove any previous custom name.\n"
		"\n"
		"" },
  { "ResourceNameCacheID", (PyCFunction) _wrap_CaptureContext_ResourceNameCacheID, METH_NOARGS, (char *) "\n"
		"ResourceNameCacheID()\n"
		"\n"
		"Returns an index that can be used to cache the results of resource naming.\n"
		"\n"
		"In some cases (e.g. formatting in widgets) there might be high frequency fetches to names without an\n"
		"easy way to force a refresh on a rename. Instead, the index here can be cached and compared each\n"
		"time to see if any names have changed.\n"
		"\n"
		"The index starts at 1, so initialising an internal cache to 0 will cause the first check to be\n"
		"considered out of date\n"
		"\n"
		":return: An incrementing index that can be used as a quick check if any names have changed.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "GetTexture", (PyCFunction) _wrap_CaptureContext_GetTexture, METH_O, (char *) "\n"
		"GetTexture(id)\n"
		"\n"
		"Retrieve the information about a particular texture.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the texture to query about.\n"
		":return: The information about a texture, or ``None`` if the ID does not correspond to a texture.\n"
		":rtype: renderdoc.TextureDescription\n"
		"\n"
		"" },
  { "GetTextures", (PyCFunction) _wrap_CaptureContext_GetTextures, METH_NOARGS, (char *) "\n"
		"GetTextures()\n"
		"\n"
		"Retrieve the list of textures in the current capture.\n"
		"\n"
		":return: The list of textures.\n"
		":rtype: List[renderdoc.TextureDescription]\n"
		"\n"
		"" },
  { "GetBuffer", (PyCFunction) _wrap_CaptureContext_GetBuffer, METH_O, (char *) "\n"
		"GetBuffer(id)\n"
		"\n"
		"Retrieve the information about a particular buffer.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the buffer to query about.\n"
		":return: The information about a buffer, or ``None`` if the ID does not correspond to a buffer.\n"
		":rtype: renderdoc.BufferDescription\n"
		"\n"
		"" },
  { "GetBuffers", (PyCFunction) _wrap_CaptureContext_GetBuffers, METH_NOARGS, (char *) "\n"
		"GetBuffers()\n"
		"\n"
		"Retrieve the list of buffers in the current capture.\n"
		"\n"
		":return: The list of buffers.\n"
		":rtype: List[renderdoc.BufferDescription]\n"
		"\n"
		"" },
  { "GetDescriptorStore", (PyCFunction) _wrap_CaptureContext_GetDescriptorStore, METH_O, (char *) "\n"
		"GetDescriptorStore(id)\n"
		"\n"
		"Retrieve the information about a particular descriptor store.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the buffer to query about.\n"
		":return: The information about a descriptor store, or ``None`` if the ID does not correspond to a\n"
		"  descriptor store.\n"
		":rtype: renderdoc.DescriptorStoreDescription\n"
		"\n"
		"" },
  { "GetAction", (PyCFunction) _wrap_CaptureContext_GetAction, METH_O, (char *) "\n"
		"GetAction(eventId)\n"
		"\n"
		"Retrieve the information about an action at a given\n"
		":data:`eventId <renderdoc.APIEvent.eventId>`.\n"
		"\n"
		":param int eventId: The :data:`eventId <renderdoc.APIEvent.eventId>` to query for.\n"
		":return: The information about the action, or ``None`` if the\n"
		"  :data:`eventId <renderdoc.APIEvent.eventId>` doesn't correspond to an action.\n"
		":rtype: renderdoc.ActionDescription\n"
		"\n"
		"" },
  { "OpenRGPProfile", (PyCFunction) _wrap_CaptureContext_OpenRGPProfile, METH_O, (char *) "\n"
		"OpenRGPProfile(filename)\n"
		"\n"
		"Sets the path to the RGP profile to use with :meth:`GetRGPInterop`, launches RGP and\n"
		"opens an interop connection. This function will block (with a progress dialog) until either an\n"
		"error is encountered or else the connection is successfully established.\n"
		"\n"
		"This could be newly created, or extracted from an embedded section in the RDC.\n"
		"\n"
		"The connection is automatically closed when the capture is closed. If OpenRGPProfile is called\n"
		"again, any previous connection will be closed.\n"
		"\n"
		":param str filename: The filename of the extracted temporary RGP capture on disk.\n"
		":return: Whether RGP launched successfully.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "ClearReplayCache", (PyCFunction) _wrap_CaptureContext_ClearReplayCache, METH_NOARGS, (char *) "\n"
		"ClearReplayCache()\n"
		"\n"
		"Clear any cached data from previous replays and ensure subsequent replays fully\n"
		"re-initialise any data, including e.g. bindless feedback, printf results or mesh output data.\n"
		"\n"
		"" },
  { "GetRGPInterop", (PyCFunction) _wrap_CaptureContext_GetRGPInterop, METH_NOARGS, (char *) "\n"
		"GetRGPInterop()\n"
		"\n"
		"Returns the current interop handle for RGP.\n"
		"\n"
		"This may return ``None`` in several cases:\n"
		"\n"
		"- if there is no capture loaded\n"
		"- if no RGP profile has been associated with the current capture yet (See :meth:`OpenRGPProfile`)\n"
		"- if RGP failed to launch or connect.\n"
		"\n"
		"The handle returned is invalidated when the capture is closed, or if :meth:`OpenRGPProfile` is\n"
		"called.\n"
		"\n"
		":return: The RGP interop connection handle.\n"
		":rtype: RGPInterop\n"
		"\n"
		"" },
  { "GetStructuredFile", (PyCFunction) _wrap_CaptureContext_GetStructuredFile, METH_NOARGS, (char *) "\n"
		"GetStructuredFile()\n"
		"\n"
		"Retrieve the :class:`~renderdoc.SDFile` for the currently open capture.\n"
		"\n"
		":return: The structured file.\n"
		":rtype: renderdoc.SDFile\n"
		"\n"
		"" },
  { "CurWindowingSystem", (PyCFunction) _wrap_CaptureContext_CurWindowingSystem, METH_NOARGS, (char *) "\n"
		"CurWindowingSystem()\n"
		"\n"
		"Retrieve the current windowing system in use.\n"
		"\n"
		":return: The active windowing system.\n"
		":rtype: renderdoc.WindowingSystem\n"
		"\n"
		"" },
  { "CreateWindowingData", (PyCFunction) _wrap_CaptureContext_CreateWindowingData, METH_O, (char *) "\n"
		"CreateWindowingData(window)\n"
		"\n"
		"Create an opaque pointer suitable for passing to\n"
		":meth:`~renderdoc.ReplayController.CreateOutput` or other functions that expect windowing data.\n"
		"\n"
		".. note::\n"
		"  This function must be called on the main UI thread.\n"
		"\n"
		":param QWidget window: The window to create windowing data for.\n"
		":return: The windowing data.\n"
		":rtype: renderdoc.WindowingData\n"
		"\n"
		"" },
  { "DebugMessages", (PyCFunction) _wrap_CaptureContext_DebugMessages, METH_NOARGS, (char *) "\n"
		"DebugMessages()\n"
		"\n"
		"Retrieve the current list of debug messages. This includes messages from the capture\n"
		"as well as messages generated during replay and analysis.\n"
		"\n"
		":return: The debug messages generated to date.\n"
		":rtype: List[renderdoc.DebugMessage]\n"
		"\n"
		"" },
  { "UnreadMessageCount", (PyCFunction) _wrap_CaptureContext_UnreadMessageCount, METH_NOARGS, (char *) "\n"
		"UnreadMessageCount()\n"
		"\n"
		"Retrieve how many messages in :meth:`DebugMessages` are currently unread.\n"
		"\n"
		":return: The number of unread messages.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "MarkMessagesRead", (PyCFunction) _wrap_CaptureContext_MarkMessagesRead, METH_NOARGS, (char *) "\n"
		"MarkMessagesRead()\n"
		"\n"
		"Mark all messages as read, resets :meth:`UnreadMessageCount` to 0.\n"
		"" },
  { "AddMessages", (PyCFunction) _wrap_CaptureContext_AddMessages, METH_O, (char *) "\n"
		"AddMessages(msgs)\n"
		"\n"
		"Add messages into the list returned by :meth:`DebugMessages`. Initially set to unread.\n"
		"\n"
		":param List[renderdoc.DebugMessage] msgs: A list of debug messages to add.\n"
		"\n"
		"" },
  { "ClearMessages", (PyCFunction) _wrap_CaptureContext_ClearMessages, METH_NOARGS, (char *) "\n"
		"ClearMessages()\n"
		"\n"
		"Clear the currently stored messages, and mark all as unread. This can be used in\n"
		"combination with :meth:`DebugMessages` and :meth:`AddMessages` to filter the current set of messages.\n"
		"\n"
		"" },
  { "GetNotes", (PyCFunction) _wrap_CaptureContext_GetNotes, METH_O, (char *) "\n"
		"GetNotes(key)\n"
		"\n"
		"Retrieve the contents for a given notes field.\n"
		"\n"
		"Examples of fields are:\n"
		"\n"
		"* 'comments' for generic comments to be displayed in a text field\n"
		"* 'hwinfo' for a plaintext summary of the hardware and driver configuration of the system.\n"
		"\n"
		":param str key: The name of the notes field to retrieve.\n"
		":return: The contents, or an empty string if the field doesn't exist.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "SetNotes", (PyCFunction) _wrap_CaptureContext_SetNotes, METH_VARARGS, (char *) "\n"
		"SetNotes(key, contents)\n"
		"\n"
		"Set the contents for a given notes field.\n"
		"\n"
		"See :meth:`GetNotes` for a list of possible common field keys.\n"
		"\n"
		":param str key: The name of the notes field to set.\n"
		":param str contents: The new contents to assign to that field.\n"
		"\n"
		"" },
  { "GetBookmarks", (PyCFunction) _wrap_CaptureContext_GetBookmarks, METH_NOARGS, (char *) "\n"
		"GetBookmarks()\n"
		"\n"
		"Get the current list of bookmarks in the capture. Each bookmark is associated with an\n"
		"eventId and has some text attached. There will only be at most one bookmark for any given eventId.\n"
		"\n"
		"The list of bookmarks is not necessarily sorted by eventId. Thus, bookmark 1 is always bookmark 1\n"
		"until it is removed, the indices do not shift as new bookmarks are added or removed.\n"
		"\n"
		":return: The currently set bookmarks.\n"
		":rtype: List[EventBookmark]\n"
		"\n"
		"" },
  { "SetBookmark", (PyCFunction) _wrap_CaptureContext_SetBookmark, METH_O, (char *) "\n"
		"SetBookmark(mark)\n"
		"\n"
		"Set or update a bookmark.\n"
		"\n"
		"A bookmark will be added at the specified eventId, or if one already exists then the attached text\n"
		"will be replaced.\n"
		"\n"
		":param EventBookmark mark: The bookmark to add.\n"
		"\n"
		"" },
  { "RemoveBookmark", (PyCFunction) _wrap_CaptureContext_RemoveBookmark, METH_O, (char *) "\n"
		"RemoveBookmark(eventId)\n"
		"\n"
		"Remove a bookmark at a given eventId.\n"
		"\n"
		"If no bookmark exists, this function will do nothing.\n"
		"\n"
		":param int eventId: The eventId of the bookmark to remove.\n"
		"\n"
		"" },
  { "DelayedCallback", (PyCFunction) _wrap_CaptureContext_DelayedCallback, METH_VARARGS, (char *) "\n"
		"DelayedCallback(milliseconds, callback)\n"
		"\n"
		"Registers a delayed callback to be called after a certain number of milliseconds\n"
		"on the UI thread.\n"
		"\n"
		":param int milliseconds: The number of milliseconds (approximately) to wait before the callback.\n"
		":param Callable[[], None] callback: The function to call\n"
		"\n"
		"" },
  { "GetMainWindow", (PyCFunction) _wrap_CaptureContext_GetMainWindow, METH_NOARGS, (char *) "\n"
		"GetMainWindow()\n"
		"\n"
		"Retrieve the current singleton :class:`MainWindow`.\n"
		"\n"
		":return: The current window.\n"
		":rtype: MainWindow\n"
		"\n"
		"" },
  { "GetEventBrowser", (PyCFunction) _wrap_CaptureContext_GetEventBrowser, METH_NOARGS, (char *) "\n"
		"GetEventBrowser()\n"
		"\n"
		"Retrieve the current singleton :class:`EventBrowser`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: EventBrowser\n"
		"\n"
		"" },
  { "GetAPIInspector", (PyCFunction) _wrap_CaptureContext_GetAPIInspector, METH_NOARGS, (char *) "\n"
		"GetAPIInspector()\n"
		"\n"
		"Retrieve the current singleton :class:`APIInspector`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: APIInspector\n"
		"\n"
		"" },
  { "GetTextureViewer", (PyCFunction) _wrap_CaptureContext_GetTextureViewer, METH_NOARGS, (char *) "\n"
		"GetTextureViewer()\n"
		"\n"
		"Retrieve the current singleton :class:`TextureViewer`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: TextureViewer\n"
		"\n"
		"" },
  { "GetMeshPreview", (PyCFunction) _wrap_CaptureContext_GetMeshPreview, METH_NOARGS, (char *) "\n"
		"GetMeshPreview()\n"
		"\n"
		"Retrieve the current singleton :class:`BufferViewer` configured for mesh viewing.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: BufferViewer\n"
		"\n"
		"" },
  { "GetPipelineViewer", (PyCFunction) _wrap_CaptureContext_GetPipelineViewer, METH_NOARGS, (char *) "\n"
		"GetPipelineViewer()\n"
		"\n"
		"Retrieve the current singleton :class:`PipelineStateViewer`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: PipelineStateViewer\n"
		"\n"
		"" },
  { "GetCaptureDialog", (PyCFunction) _wrap_CaptureContext_GetCaptureDialog, METH_NOARGS, (char *) "\n"
		"GetCaptureDialog()\n"
		"\n"
		"Retrieve the current singleton :class:`CaptureDialog`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: CaptureDialog\n"
		"\n"
		"" },
  { "GetDebugMessageView", (PyCFunction) _wrap_CaptureContext_GetDebugMessageView, METH_NOARGS, (char *) "\n"
		"GetDebugMessageView()\n"
		"\n"
		"Retrieve the current singleton :class:`DebugMessageView`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: DebugMessageView\n"
		"\n"
		"" },
  { "GetDiagnosticLogView", (PyCFunction) _wrap_CaptureContext_GetDiagnosticLogView, METH_NOARGS, (char *) "\n"
		"GetDiagnosticLogView()\n"
		"\n"
		"Retrieve the current singleton :class:`LogView`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: DiagnosticLogView\n"
		"\n"
		"" },
  { "GetCommentView", (PyCFunction) _wrap_CaptureContext_GetCommentView, METH_NOARGS, (char *) "\n"
		"GetCommentView()\n"
		"\n"
		"Retrieve the current singleton :class:`CommentView`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: CommentView\n"
		"\n"
		"" },
  { "GetPerformanceCounterViewer", (PyCFunction) _wrap_CaptureContext_GetPerformanceCounterViewer, METH_NOARGS, (char *) "\n"
		"GetPerformanceCounterViewer()\n"
		"\n"
		"Retrieve the current singleton :class:`PerformanceCounterViewer`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: PerformanceCounterViewer\n"
		"\n"
		"" },
  { "GetStatisticsViewer", (PyCFunction) _wrap_CaptureContext_GetStatisticsViewer, METH_NOARGS, (char *) "\n"
		"GetStatisticsViewer()\n"
		"\n"
		"Retrieve the current singleton :class:`StatisticsViewer`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: StatisticsViewer\n"
		"\n"
		"" },
  { "GetTimelineBar", (PyCFunction) _wrap_CaptureContext_GetTimelineBar, METH_NOARGS, (char *) "\n"
		"GetTimelineBar()\n"
		"\n"
		"Retrieve the current singleton :class:`TimelineBar`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: TimelineBar\n"
		"\n"
		"" },
  { "GetPythonShell", (PyCFunction) _wrap_CaptureContext_GetPythonShell, METH_NOARGS, (char *) "\n"
		"GetPythonShell()\n"
		"\n"
		"Retrieve the current singleton :class:`PythonShell`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: PythonShell\n"
		"\n"
		"" },
  { "GetResourceInspector", (PyCFunction) _wrap_CaptureContext_GetResourceInspector, METH_NOARGS, (char *) "\n"
		"GetResourceInspector()\n"
		"\n"
		"Retrieve the current singleton :class:`ResourceInspector`.\n"
		"\n"
		":return: The current window, which is created (but not shown) it there wasn't one open.\n"
		":rtype: ResourceInspector\n"
		"\n"
		"" },
  { "HasEventBrowser", (PyCFunction) _wrap_CaptureContext_HasEventBrowser, METH_NOARGS, (char *) "\n"
		"HasEventBrowser()\n"
		"\n"
		"Check if there is a current :class:`EventBrowser` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasAPIInspector", (PyCFunction) _wrap_CaptureContext_HasAPIInspector, METH_NOARGS, (char *) "\n"
		"HasAPIInspector()\n"
		"\n"
		"Check if there is a current :class:`APIInspector` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasTextureViewer", (PyCFunction) _wrap_CaptureContext_HasTextureViewer, METH_NOARGS, (char *) "\n"
		"HasTextureViewer()\n"
		"\n"
		"Check if there is a current :class:`TextureViewer` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasPipelineViewer", (PyCFunction) _wrap_CaptureContext_HasPipelineViewer, METH_NOARGS, (char *) "\n"
		"HasPipelineViewer()\n"
		"\n"
		"Check if there is a current :class:`PipelineStateViewer` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasMeshPreview", (PyCFunction) _wrap_CaptureContext_HasMeshPreview, METH_NOARGS, (char *) "\n"
		"HasMeshPreview()\n"
		"\n"
		"Check if there is a current mesh previewing :class:`BufferViewer` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasCaptureDialog", (PyCFunction) _wrap_CaptureContext_HasCaptureDialog, METH_NOARGS, (char *) "\n"
		"HasCaptureDialog()\n"
		"\n"
		"Check if there is a current :class:`CaptureDialog` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasDebugMessageView", (PyCFunction) _wrap_CaptureContext_HasDebugMessageView, METH_NOARGS, (char *) "\n"
		"HasDebugMessageView()\n"
		"\n"
		"Check if there is a current :class:`DebugMessageView` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasDiagnosticLogView", (PyCFunction) _wrap_CaptureContext_HasDiagnosticLogView, METH_NOARGS, (char *) "\n"
		"HasDiagnosticLogView()\n"
		"\n"
		"Check if there is a current :class:`DiagnosticLogView` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasCommentView", (PyCFunction) _wrap_CaptureContext_HasCommentView, METH_NOARGS, (char *) "\n"
		"HasCommentView()\n"
		"\n"
		"Check if there is a current :class:`CommentView` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasPerformanceCounterViewer", (PyCFunction) _wrap_CaptureContext_HasPerformanceCounterViewer, METH_NOARGS, (char *) "\n"
		"HasPerformanceCounterViewer()\n"
		"\n"
		"Check if there is a current :class:`PerformanceCounterViewer` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasStatisticsViewer", (PyCFunction) _wrap_CaptureContext_HasStatisticsViewer, METH_NOARGS, (char *) "\n"
		"HasStatisticsViewer()\n"
		"\n"
		"Check if there is a current :class:`StatisticsViewer` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasTimelineBar", (PyCFunction) _wrap_CaptureContext_HasTimelineBar, METH_NOARGS, (char *) "\n"
		"HasTimelineBar()\n"
		"\n"
		"Check if there is a current :class:`TimelineBar` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasPythonShell", (PyCFunction) _wrap_CaptureContext_HasPythonShell, METH_NOARGS, (char *) "\n"
		"HasPythonShell()\n"
		"\n"
		"Check if there is a current :class:`PythonShell` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "HasResourceInspector", (PyCFunction) _wrap_CaptureContext_HasResourceInspector, METH_NOARGS, (char *) "\n"
		"HasResourceInspector()\n"
		"\n"
		"Check if there is a current :class:`ResourceInspector` open.\n"
		"\n"
		":return: ``True`` if there is a window open.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "ShowEventBrowser", (PyCFunction) _wrap_CaptureContext_ShowEventBrowser, METH_NOARGS, (char *) "\n"
		"ShowEventBrowser()\n"
		"\n"
		"Raise the current :class:`EventBrowser`, showing it in the default place if needed.\n"
		"" },
  { "ShowAPIInspector", (PyCFunction) _wrap_CaptureContext_ShowAPIInspector, METH_NOARGS, (char *) "\n"
		"ShowAPIInspector()\n"
		"\n"
		"Raise the current :class:`APIInspector`, showing it in the default place if needed.\n"
		"" },
  { "ShowTextureViewer", (PyCFunction) _wrap_CaptureContext_ShowTextureViewer, METH_NOARGS, (char *) "\n"
		"ShowTextureViewer()\n"
		"\n"
		"Raise the current :class:`TextureViewer`, showing it in the default place if needed.\n"
		"" },
  { "ShowMeshPreview", (PyCFunction) _wrap_CaptureContext_ShowMeshPreview, METH_NOARGS, (char *) "\n"
		"ShowMeshPreview()\n"
		"\n"
		"Raise the current mesh previewing :class:`BufferViewer`, showing it in the default\n"
		"place if needed.\n"
		"\n"
		"" },
  { "ShowPipelineViewer", (PyCFunction) _wrap_CaptureContext_ShowPipelineViewer, METH_NOARGS, (char *) "\n"
		"ShowPipelineViewer()\n"
		"\n"
		"Raise the current :class:`PipelineStateViewer`, showing it in the default place if needed.\n"
		"" },
  { "ShowCaptureDialog", (PyCFunction) _wrap_CaptureContext_ShowCaptureDialog, METH_NOARGS, (char *) "\n"
		"ShowCaptureDialog()\n"
		"\n"
		"Raise the current :class:`CaptureDialog`, showing it in the default place if needed.\n"
		"" },
  { "ShowDebugMessageView", (PyCFunction) _wrap_CaptureContext_ShowDebugMessageView, METH_NOARGS, (char *) "\n"
		"ShowDebugMessageView()\n"
		"\n"
		"Raise the current :class:`DebugMessageView`, showing it in the default place if needed.\n"
		"" },
  { "ShowDiagnosticLogView", (PyCFunction) _wrap_CaptureContext_ShowDiagnosticLogView, METH_NOARGS, (char *) "\n"
		"ShowDiagnosticLogView()\n"
		"\n"
		"Raise the current :class:`DiagnosticLogView`, showing it in the default place if needed.\n"
		"" },
  { "ShowCommentView", (PyCFunction) _wrap_CaptureContext_ShowCommentView, METH_NOARGS, (char *) "\n"
		"ShowCommentView()\n"
		"\n"
		"Raise the current :class:`CommentView`, showing it in the default place if needed.\n"
		"" },
  { "ShowPerformanceCounterViewer", (PyCFunction) _wrap_CaptureContext_ShowPerformanceCounterViewer, METH_NOARGS, (char *) "\n"
		"ShowPerformanceCounterViewer()\n"
		"\n"
		"Raise the current :class:`PerformanceCounterViewer`, showing it in the default place if needed.\n"
		"" },
  { "ShowStatisticsViewer", (PyCFunction) _wrap_CaptureContext_ShowStatisticsViewer, METH_NOARGS, (char *) "\n"
		"ShowStatisticsViewer()\n"
		"\n"
		"Raise the current :class:`StatisticsViewer`, showing it in the default place if needed.\n"
		"" },
  { "ShowTimelineBar", (PyCFunction) _wrap_CaptureContext_ShowTimelineBar, METH_NOARGS, (char *) "\n"
		"ShowTimelineBar()\n"
		"\n"
		"Raise the current :class:`TimelineBar`, showing it in the default place if needed.\n"
		"" },
  { "ShowPythonShell", (PyCFunction) _wrap_CaptureContext_ShowPythonShell, METH_NOARGS, (char *) "\n"
		"ShowPythonShell()\n"
		"\n"
		"Raise the current :class:`PythonShell`, showing it in the default place if needed.\n"
		"" },
  { "ShowResourceInspector", (PyCFunction) _wrap_CaptureContext_ShowResourceInspector, METH_NOARGS, (char *) "\n"
		"ShowResourceInspector()\n"
		"\n"
		"Raise the current :class:`ResourceInspector`, showing it in the default place if needed.\n"
		"" },
  { "EditShader", (PyCFunction) _wrap_CaptureContext_EditShader, METH_VARARGS, (char *) "\n"
		"EditShader(id, stage, entryPoint, files, knownTool, shaderEncoding, flags, saveCallback, revertCallback)\n"
		"\n"
		"Show a new :class:`ShaderViewer` window, showing an editable view of a given shader.\n"
		"\n"
		":param renderdoc.ResourceId id: The shader object, if applicable, that's being edited. If this edit\n"
		"  corresponds to no shader object (such as if it's a custom shader) this can be a null ID.\n"
		":param renderdoc.ShaderStage stage: The shader stage for this shader.\n"
		":param str entryPoint: The entry point to be used when compiling the edited shader.\n"
		":param List[Tuple[str,str]] files: The source files, with each tuple being a pair of the filename\n"
		"  and the file contents.\n"
		":param renderdoc.KnownShaderTool knownTool: The preferred tool to use to compile, if known.\n"
		":param renderdoc.ShaderEncoding shaderEncoding: The encoding of the input files.\n"
		":param renderdoc.ShaderCompileFlags flags: The flags originally used to compile the shader.\n"
		":param ShaderViewer.SaveCallback saveCallback: The callback function to call when a save/update is\n"
		"  triggered.\n"
		"  Callback function signature must match :func:`ShaderViewer.SaveCallback`.\n"
		":param ShaderViewer.RevertCallback revertCallback: The callback function to call when the shader\n"
		"  is to be reverted - either by user request or because the shader viewer was closed.\n"
		"  Callback function signature must match :func:`ShaderViewer.RevertCallback`.\n"
		":return: The new :class:`ShaderViewer` window opened but not shown for editing.\n"
		":rtype: ShaderViewer\n"
		"\n"
		"" },
  { "DebugShader", (PyCFunction) _wrap_CaptureContext_DebugShader, METH_VARARGS, (char *) "\n"
		"DebugShader(shader, pipeline, trace, debugContext)\n"
		"\n"
		"Show a new :class:`ShaderViewer` window, showing a read-only view of a debug trace\n"
		"through the execution of a given shader.\n"
		"\n"
		":param renderdoc.ShaderReflection shader: The reflection data for the shader to view.\n"
		":param renderdoc.ResourceId pipeline: The pipeline state object, if applicable, that this shader is\n"
		"  bound to.\n"
		":param renderdoc.ShaderDebugTrace trace: The execution trace of the debugged shader.\n"
		":param str debugContext: A human-readable context string describing which invocation of this shader\n"
		"  was debugged. For example 'Pixel 12,34 at eventId 678'.\n"
		":return: The new :class:`ShaderViewer` window opened, but not shown.\n"
		":rtype: ShaderViewer\n"
		"\n"
		"" },
  { "ViewShader", (PyCFunction) _wrap_CaptureContext_ViewShader, METH_VARARGS, (char *) "\n"
		"ViewShader(shader, pipeline)\n"
		"\n"
		"Show a new :class:`ShaderViewer` window, showing a read-only view of a given shader.\n"
		"\n"
		":param renderdoc.ShaderReflection shader: The reflection data for the shader to view.\n"
		":param renderdoc.ResourceId pipeline: The pipeline state object, if applicable, that this shader is\n"
		"  bound to.\n"
		":return: The new :class:`ShaderViewer` window opened, but not shown.\n"
		":rtype: ShaderViewer\n"
		"\n"
		"" },
  { "ViewShaderMessages", (PyCFunction) _wrap_CaptureContext_ViewShaderMessages, METH_O, (char *) "\n"
		"ViewShaderMessages(stages)\n"
		"\n"
		"Show a new :class:`ShaderMessageViewer` window, showing the current event's messages.\n"
		"\n"
		":param renderdoc.ShaderStageMask stages: The initial stages being viewed.\n"
		":return: The new :class:`ShaderMessageViewer` window opened, but not shown.\n"
		":rtype: ShaderMessageViewer\n"
		"\n"
		"" },
  { "ViewDescriptorStore", (PyCFunction) _wrap_CaptureContext_ViewDescriptorStore, METH_O, (char *) "\n"
		"ViewDescriptorStore(id)\n"
		"\n"
		"Show a new :class:`DescriptorViewer` window, showing the full raw contents of a\n"
		"descriptor store.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the descriptor store to fetch data from.\n"
		":return: The new :class:`DescriptorViewer` window opened, but not shown.\n"
		":rtype: DescriptorViewer\n"
		"\n"
		"" },
  { "ViewDescriptors", (PyCFunction) _wrap_CaptureContext_ViewDescriptors, METH_VARARGS, (char *) "\n"
		"ViewDescriptors(descriptors, samplerDescriptors)\n"
		"\n"
		"Show a new :class:`DescriptorViewer` window, showing contents of an arbitrary list of\n"
		"descriptors.\n"
		"\n"
		"The descriptor lists should be in parallel, with identical sizes. If a non-sampler descriptor is\n"
		"to be displayed, the corresponding sampler descriptor should be uninitialised and vice-versa. If\n"
		"the lists are not the same length, only indices up to the minimum of the two lengths will be used.\n"
		"\n"
		"This function should not be used to view the entirety of a descriptor store - in that case the\n"
		":func:`ViewDescriptorStore` function will be more efficient.\n"
		"\n"
		":param List[renderdoc.Descriptor] descriptors: The list of descriptors to process and show.\n"
		":param List[renderdoc.SamplerDescriptor] samplerDescriptors: The list of sampler descriptors to process and\n"
		"  show.\n"
		":return: The new :class:`DescriptorViewer` window opened, but not shown.\n"
		":rtype: DescriptorViewer\n"
		"\n"
		"" },
  { "ViewBuffer", (PyCFunction) _wrap_CaptureContext_ViewBuffer, METH_VARARGS, (char *) "\n"
		"ViewBuffer(byteOffset, byteSize, id, format)\n"
		"ViewBuffer(byteOffset, byteSize, id)\n"
		"\n"
		"Show a new :class:`BufferViewer` window, showing a read-only view of buffer data.\n"
		"\n"
		":param int byteOffset: The offset in bytes to the start of the buffer data to show.\n"
		":param int byteSize: The number of bytes in the buffer to show.\n"
		":param renderdoc.ResourceId id: The ID of the buffer to fetch data from.\n"
		":param str format: Optionally a HLSL/GLSL style formatting string.\n"
		":return: The new :class:`BufferViewer` window opened, but not shown.\n"
		":rtype: BufferViewer\n"
		"\n"
		"" },
  { "ViewTextureAsBuffer", (PyCFunction) _wrap_CaptureContext_ViewTextureAsBuffer, METH_VARARGS, (char *) "\n"
		"ViewTextureAsBuffer(id, sub, format)\n"
		"ViewTextureAsBuffer(id, sub)\n"
		"\n"
		"Show a new :class:`BufferViewer` window, showing a read-only view of a texture's raw\n"
		"bytes.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the texture itself.\n"
		":param renderdoc.Subresource sub: The subresource within this texture to use.\n"
		":param str format: Optionally a HLSL/GLSL style formatting string.\n"
		":return: The new :class:`BufferViewer` window opened, but not shown.\n"
		":rtype: BufferViewer\n"
		"\n"
		"" },
  { "ViewConstantBuffer", (PyCFunction) _wrap_CaptureContext_ViewConstantBuffer, METH_VARARGS, (char *) "\n"
		"ViewConstantBuffer(stage, slot, idx)\n"
		"\n"
		"Show a new :class:`BufferViewer` window, showing a read-only view of a the\n"
		"variables in a constant buffer with their values.\n"
		"\n"
		":param renderdoc.ShaderStage stage: The stage that the constant buffer is bound to.\n"
		":param int slot: The index in the shader's constant buffer list to look up.\n"
		":param int idx: For APIs that support arrayed resource binds, the index in the constant buffer\n"
		"  array.\n"
		":return: The new :class:`BufferViewer` window opened, but not shown.\n"
		":rtype: BufferViewer\n"
		"\n"
		"" },
  { "ViewPixelHistory", (PyCFunction) _wrap_CaptureContext_ViewPixelHistory, METH_VARARGS, (char *) "\n"
		"ViewPixelHistory(id, x, y, view, display)\n"
		"\n"
		"Show a new :class:`PixelHistoryView` window, showing the results from a pixel history\n"
		"operation.\n"
		"\n"
		":param renderdoc.ResourceId id: The ID of the texture to show the history of.\n"
		":param int x: The x co-ordinate of the pixel to search for.\n"
		":param int y: The y co-ordinate of the pixel to search for.\n"
		":param int view: The layered or multiview rendering view index of the pixel to search for.\n"
		":param renderdoc.TextureDisplay display: The texture display configuration to use when looking up\n"
		"  the history.\n"
		":return: The new :class:`PixelHistoryView` window opened, but not shown.\n"
		":rtype: PixelHistoryView\n"
		"\n"
		"" },
  { "CreateBuiltinWindow", (PyCFunction) _wrap_CaptureContext_CreateBuiltinWindow, METH_O, (char *) "\n"
		"CreateBuiltinWindow(objectName)\n"
		"\n"
		"Creates and returns a built-in window.\n"
		"\n"
		"This function is intended for internal use for restoring layouts, and generally should not be used\n"
		"by user code.\n"
		"\n"
		":param str objectName: The built-in name of a singleton window.\n"
		":return: The handle to the existing or newly created window of this type.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "BuiltinWindowClosed", (PyCFunction) _wrap_CaptureContext_BuiltinWindowClosed, METH_O, (char *) "\n"
		"BuiltinWindowClosed(window)\n"
		"\n"
		"Marks a built-in window as closed.\n"
		"\n"
		"This function is intended for internal use by the built-in windows for singleton management, and\n"
		"should not be called by user code.\n"
		"\n"
		":param QWidget window: The built-in window that closed.\n"
		"\n"
		"" },
  { "RaiseDockWindow", (PyCFunction) _wrap_CaptureContext_RaiseDockWindow, METH_O, (char *) "\n"
		"RaiseDockWindow(dockWindow)\n"
		"\n"
		"Raises a window within its docking manager so it becomes the focus of wherever it is\n"
		"currently docked.\n"
		"\n"
		":param QWidget dockWindow: The window to raise.\n"
		"\n"
		"" },
  { "AddDockWindow", (PyCFunction) _wrap_CaptureContext_AddDockWindow, METH_VARARGS, (char *) "\n"
		"AddDockWindow(newWindow, ref, refWindow, percentage=0.5)\n"
		"AddDockWindow(newWindow, ref, refWindow)\n"
		"\n"
		"Adds a new window within the docking system.\n"
		"\n"
		":param QWidget newWindow: The new window to add.\n"
		":param DockReference ref: The location to add the new window, possibly relative to ``refWindow``.\n"
		":param QWidget refWindow: The window to refer to if the new window is being added relative, or can\n"
		"  be ``None`` if the new location is absolute.\n"
		":param float percentage: Optionally the percentage to split the area. If omitted, a 50% split is\n"
		"  used.\n"
		"\n"
		"" },
  { "CurD3D11PipelineState", (PyCFunction) _wrap_CaptureContext_CurD3D11PipelineState, METH_NOARGS, (char *) "\n"
		"CurD3D11PipelineState()\n"
		"\n"
		"Retrieve the current :class:`~renderdoc.D3D11State` pipeline state.\n"
		"\n"
		"The return value will be ``None`` if the capture is not using the D3D11 API.\n"
		"You should determine the API of the capture first before fetching it.\n"
		"\n"
		":return: The current D3D11 pipeline state.\n"
		":rtype: renderdoc.D3D11State\n"
		"\n"
		"" },
  { "CurD3D12PipelineState", (PyCFunction) _wrap_CaptureContext_CurD3D12PipelineState, METH_NOARGS, (char *) "\n"
		"CurD3D12PipelineState()\n"
		"\n"
		"Retrieve the current :class:`~renderdoc.D3D12State` pipeline state.\n"
		"\n"
		"The return value will be ``None`` if the capture is not using the D3D12 API.\n"
		"You should determine the API of the capture first before fetching it.\n"
		"\n"
		":return: The current D3D12 pipeline state.\n"
		":rtype: renderdoc.D3D12State\n"
		"\n"
		"" },
  { "CurGLPipelineState", (PyCFunction) _wrap_CaptureContext_CurGLPipelineState, METH_NOARGS, (char *) "\n"
		"CurGLPipelineState()\n"
		"\n"
		"Retrieve the current :class:`~renderdoc.GLState` pipeline state.\n"
		"\n"
		"The return value will be ``None`` if the capture is not using the OpenGL API.\n"
		"You should determine the API of the capture first before fetching it.\n"
		"\n"
		":return: The current OpenGL pipeline state.\n"
		":rtype: renderdoc.GLState\n"
		"\n"
		"" },
  { "CurVulkanPipelineState", (PyCFunction) _wrap_CaptureContext_CurVulkanPipelineState, METH_NOARGS, (char *) "\n"
		"CurVulkanPipelineState()\n"
		"\n"
		"Retrieve the current :class:`~renderdoc.VKState` pipeline state.\n"
		"\n"
		"The return value will be ``None`` if the capture is not using the Vulkan API.\n"
		"You should determine the API of the capture first before fetching it.\n"
		"\n"
		":return: The current Vulkan pipeline state.\n"
		":rtype: renderdoc.VKState\n"
		"\n"
		"" },
  { "CurPipelineState", (PyCFunction) _wrap_CaptureContext_CurPipelineState, METH_NOARGS, (char *) "\n"
		"CurPipelineState()\n"
		"\n"
		"Retrieve the current :class:`~renderdoc.PipeState` abstracted pipeline state.\n"
		"\n"
		"This pipeline state will always be valid, and allows queries that will work regardless of the\n"
		"capture's API.\n"
		"\n"
		":return: The current API-agnostic abstracted pipeline state.\n"
		":rtype: renderdoc.PipeState\n"
		"\n"
		"" },
  { "Config", (PyCFunction) _wrap_CaptureContext_Config, METH_NOARGS, (char *) "\n"
		"Config()\n"
		"\n"
		"Retrieve the current persistant config.\n"
		"\n"
		":return: The current persistant config manager.\n"
		":rtype: PersistantConfig\n"
		"\n"
		"" },
  { "Extensions", (PyCFunction) _wrap_CaptureContext_Extensions, METH_NOARGS, (char *) "\n"
		"Extensions()\n"
		"\n"
		"Retrieve the manager for extensions.\n"
		"\n"
		":return: The current extension manager.\n"
		":rtype: ExtensionManager\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ICaptureContext_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.CaptureContext",              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ICaptureContext_type.as_number,               /* tp_as_number */
    &SwigPyBuiltin__ICaptureContext_type.as_sequence,             /* tp_as_sequence */
    &SwigPyBuiltin__ICaptureContext_type.as_mapping,              /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ICaptureContext_type.as_buffer,               /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "The capture context that the python script is running in.",  /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ICaptureContext_richcompare,     /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ICaptureContext_methods,   /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ICaptureContext_getset,    /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ICaptureContext_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ICaptureContext_type};

static SwigPyGetSet ShaderToolOutput_log_getset = { _wrap_ShaderToolOutput_log_get, _wrap_ShaderToolOutput_log_set };
static SwigPyGetSet ShaderToolOutput_result_getset = { _wrap_ShaderToolOutput_result_get, _wrap_ShaderToolOutput_result_set };
static SwigPyGetSet ShaderToolOutput___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ShaderToolOutput_getset[] = {
    { (char *) "log", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The output log - containing the information about the tool run and any errors.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ShaderToolOutput_log_getset }
,
    { (char *) "result", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The actual output data from the tool\n"
		"\n"
		":type: bytes\n"
		"\n"
		"", (void *) &ShaderToolOutput_result_getset }
,
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ShaderToolOutput.__dict__", (void *) &ShaderToolOutput___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ShaderToolOutput_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ShaderToolOutput_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ShaderToolOutput_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ShaderToolOutput",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_ShaderToolOutput_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ShaderToolOutput_type.as_number,              /* tp_as_number */
    &SwigPyBuiltin__ShaderToolOutput_type.as_sequence,            /* tp_as_sequence */
    &SwigPyBuiltin__ShaderToolOutput_type.as_mapping,             /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ShaderToolOutput_type.as_buffer,              /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Contains the output from invoking a :class:`ShaderProcessingTool`, including both the\n"
		"actual output data desired as well as any stdout/stderr messages.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ShaderToolOutput_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ShaderToolOutput_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ShaderToolOutput_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_ShaderToolOutput,    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ShaderToolOutput_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ShaderToolOutput_type};

static SwigPyGetSet ShaderProcessingTool_tool_getset = { _wrap_ShaderProcessingTool_tool_get, _wrap_ShaderProcessingTool_tool_set };
static SwigPyGetSet ShaderProcessingTool_name_getset = { _wrap_ShaderProcessingTool_name_get, _wrap_ShaderProcessingTool_name_set };
static SwigPyGetSet ShaderProcessingTool_input_getset = { _wrap_ShaderProcessingTool_input_get, _wrap_ShaderProcessingTool_input_set };
static SwigPyGetSet ShaderProcessingTool___dict___getset = { SwigPyObject_get___dict__, 0 };
static SwigPyGetSet ShaderProcessingTool_executable_getset = { _wrap_ShaderProcessingTool_executable_get, _wrap_ShaderProcessingTool_executable_set };
static SwigPyGetSet ShaderProcessingTool_output_getset = { _wrap_ShaderProcessingTool_output_get, _wrap_ShaderProcessingTool_output_set };
static SwigPyGetSet ShaderProcessingTool_args_getset = { _wrap_ShaderProcessingTool_args_get, _wrap_ShaderProcessingTool_args_set };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ShaderProcessingTool_getset[] = {
    { (char *) "tool", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The :class:`KnownShaderTool` identifying which known tool this program is.\n"
		"\n"
		":type: KnownShaderTool\n"
		"\n"
		"", (void *) &ShaderProcessingTool_tool_getset }
,
    { (char *) "name", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The human-readable name of the program.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ShaderProcessingTool_name_getset }
,
    { (char *) "input", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The input that this program expects.\n"
		"\n"
		":type: ShaderEncoding\n"
		"\n"
		"", (void *) &ShaderProcessingTool_input_getset }
,
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ShaderProcessingTool.__dict__", (void *) &ShaderProcessingTool___dict___getset }
,
    { (char *) "executable", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The path to the executable to run for this program.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ShaderProcessingTool_executable_getset }
,
    { (char *) "output", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The output that this program provides.\n"
		"\n"
		":type: ShaderEncoding\n"
		"\n"
		"", (void *) &ShaderProcessingTool_output_getset }
,
    { (char *) "args", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The command line argmuents to pass to the program.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ShaderProcessingTool_args_getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ShaderProcessingTool_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_ShaderProcessingTool___eq__(self, other); break;
    case Py_LT : result = _wrap_ShaderProcessingTool___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ShaderProcessingTool_methods[] = {
  { "__eq__", (PyCFunction) _wrap_ShaderProcessingTool___eq__, METH_O, (char *) "__eq__(o)" },
  { "__lt__", (PyCFunction) _wrap_ShaderProcessingTool___lt__, METH_O, (char *) "__lt__(o)" },
  { "DefaultArguments", (PyCFunction) _wrap_ShaderProcessingTool_DefaultArguments, METH_NOARGS, (char *) "\n"
		"DefaultArguments()\n"
		"\n"
		"Return the default arguments used when invoking this tool\n"
		"\n"
		":return: The arguments specified for this tool.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "DisassembleShader", (PyCFunction) _wrap_ShaderProcessingTool_DisassembleShader, METH_VARARGS, (char *) "\n"
		"DisassembleShader(window, shader, args)\n"
		"\n"
		"Runs this program to disassemble a given shader reflection.\n"
		"\n"
		":param QWidget window: A handle to the window to use when showing a progress bar or error messages.\n"
		":param renderdoc.ShaderReflection shader: The shader to disassemble.\n"
		":param str args: arguments to pass to the tool. The default arguments can be obtained using\n"
		"  :meth:`DefaultArguments` which can then be customised as desired. Passing an empty string uses the\n"
		"  default arguments.\n"
		":return: The result of running the tool.\n"
		":rtype: ShaderToolOutput\n"
		"\n"
		"" },
  { "CompileShader", (PyCFunction) _wrap_ShaderProcessingTool_CompileShader, METH_VARARGS, (char *) "\n"
		"CompileShader(window, source, entryPoint, stage, spirvVer, args)\n"
		"\n"
		"Runs this program to disassemble a given shader source.\n"
		"\n"
		":param QWidget window: A handle to the window to use when showing a progress bar or error messages.\n"
		":param str source: The source code, preprocessed into a single file.\n"
		":param str entryPoint: The name of the entry point in the shader to compile.\n"
		":param renderdoc.ShaderStage stage: The pipeline stage that this shader represents.\n"
		":param str spirvVer: The version of SPIR-V in use for this shader, or an empty string for defaults.\n"
		"  The current version can be obtained from reflection data via the ``@spirver`` compile flag.\n"
		":param str args: arguments to pass to the tool. The default arguments can be obtained using\n"
		"  :meth:`DefaultArguments` which can then be customised as desired. Passing an empty string uses the\n"
		"  default arguments.\n"
		":return: The result of running the tool.\n"
		":rtype: ShaderToolOutput\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ShaderProcessingTool_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ShaderProcessingTool",        /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_ShaderProcessingTool_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ShaderProcessingTool_type.as_number,          /* tp_as_number */
    &SwigPyBuiltin__ShaderProcessingTool_type.as_sequence,        /* tp_as_sequence */
    &SwigPyBuiltin__ShaderProcessingTool_type.as_mapping,         /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ShaderProcessingTool_type.as_buffer,          /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Describes an external program that can be used to process shaders, typically either\n"
		"compiling from a high-level language to a binary format, or decompiling from the binary format to\n"
		"a high-level language or textual representation.\n"
		"\n"
		"Commonly used with SPIR-V.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ShaderProcessingTool_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ShaderProcessingTool_methods,                  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ShaderProcessingTool_getset,                   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_ShaderProcessingTool,/* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ShaderProcessingTool_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ShaderProcessingTool_type};

static SwigPyGetSet BugReport_submitDate_getset = { _wrap_BugReport_submitDate_get, _wrap_BugReport_submitDate_set };
static SwigPyGetSet BugReport_checkDate_getset = { _wrap_BugReport_checkDate_get, _wrap_BugReport_checkDate_set };
static SwigPyGetSet BugReport___dict___getset = { SwigPyObject_get___dict__, 0 };
static SwigPyGetSet BugReport_reportId_getset = { _wrap_BugReport_reportId_get, _wrap_BugReport_reportId_set };
static SwigPyGetSet BugReport_unreadUpdates_getset = { _wrap_BugReport_unreadUpdates_get, _wrap_BugReport_unreadUpdates_set };
SWIGINTERN PyGetSetDef SwigPyBuiltin__BugReport_getset[] = {
    { (char *) "submitDate", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The original date when this bug was submitted.\n"
		"\n"
		":type: datetime\n"
		"\n"
		"", (void *) &BugReport_submitDate_getset }
,
    { (char *) "checkDate", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The last date that we checked for updates.\n"
		"\n"
		":type: datetime\n"
		"\n"
		"", (void *) &BugReport_checkDate_getset }
,
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"BugReport.__dict__", (void *) &BugReport___dict___getset }
,
    { (char *) "reportId", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The private ID of the bug report.\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &BugReport_reportId_getset }
,
    { (char *) "unreadUpdates", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"Unread updates to the bug exist\n"
		"\n"
		":type: bool\n"
		"\n"
		"", (void *) &BugReport_unreadUpdates_getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__BugReport_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_BugReport___eq__(self, other); break;
    case Py_LT : result = _wrap_BugReport___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__BugReport_methods[] = {
  { "__eq__", (PyCFunction) _wrap_BugReport___eq__, METH_O, (char *) "__eq__(o)" },
  { "__lt__", (PyCFunction) _wrap_BugReport___lt__, METH_O, (char *) "__lt__(o)" },
  { "URL", (PyCFunction) _wrap_BugReport_URL, METH_NOARGS, (char *) "\n"
		"URL()\n"
		"\n"
		"Gets the URL for this report.\n"
		"\n"
		":return: The URL to the report.\n"
		":rtype: str\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__BugReport_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.BugReport",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_BugReport_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__BugReport_type.as_number, /* tp_as_number */
    &SwigPyBuiltin__BugReport_type.as_sequence,                   /* tp_as_sequence */
    &SwigPyBuiltin__BugReport_type.as_mapping,/* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__BugReport_type.as_buffer, /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "Describes a submitted bug report.",      /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__BugReport_richcompare,           /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__BugReport_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__BugReport_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_BugReport,           /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__BugReport_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__BugReport_type};

static SwigPyGetSet OffsetSizeDisplayMode___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__OffsetSizeDisplayMode_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"OffsetSizeDisplayMode.__dict__", (void *) &OffsetSizeDisplayMode___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__OffsetSizeDisplayMode_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__OffsetSizeDisplayMode_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__OffsetSizeDisplayMode_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "OffsetSizeDisplayMode",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_OffsetSizeDisplayMode_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__OffsetSizeDisplayMode_type.as_number,         /* tp_as_number */
    &SwigPyBuiltin__OffsetSizeDisplayMode_type.as_sequence,       /* tp_as_sequence */
    &SwigPyBuiltin__OffsetSizeDisplayMode_type.as_mapping,        /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__OffsetSizeDisplayMode_type.as_buffer,         /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The formatting mode used when displaying fields marked as Offsets or Sizes.\n"
		"\n"
		".. data:: Auto\n"
		"\n"
		"  The data is displayed as decimal values by default and hexadecimal if above a certain threshold.\n"
		"\n"
		".. data:: Decimal\n"
		"\n"
		"  The data is displayed as decimal values.\n"
		"\n"
		".. data:: Hexadecimal\n"
		"\n"
		"  The data is displayed as hexadecimal values.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__OffsetSizeDisplayMode_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__OffsetSizeDisplayMode_methods,                 /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__OffsetSizeDisplayMode_getset,                  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_OffsetSizeDisplayMode,                   /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__OffsetSizeDisplayMode_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__OffsetSizeDisplayMode_type};

static SwigPyGetSet TimeUnit___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__TimeUnit_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"TimeUnit.__dict__", (void *) &TimeUnit___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__TimeUnit_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__TimeUnit_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__TimeUnit_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "TimeUnit",                               /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_TimeUnit_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__TimeUnit_type.as_number,  /* tp_as_number */
    &SwigPyBuiltin__TimeUnit_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__TimeUnit_type.as_mapping, /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__TimeUnit_type.as_buffer,  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"The unit that GPU durations are displayed in.\n"
		"\n"
		".. data:: Seconds\n"
		"\n"
		"  The durations are displayed as seconds (s).\n"
		"\n"
		".. data:: Milliseconds\n"
		"\n"
		"  The durations are displayed as milliseconds (ms).\n"
		"\n"
		".. data:: Microseconds\n"
		"\n"
		"  The durations are displayed as microseconds (s).\n"
		"\n"
		".. data:: Nanoseconds\n"
		"\n"
		"  The durations are displayed as nanoseconds (ns).\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__TimeUnit_richcompare,            /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__TimeUnit_methods,          /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__TimeUnit_getset,           /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_TimeUnit,            /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__TimeUnit_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__TimeUnit_type};

static SwigPyGetSet PersistantConfig_CheckUpdate_AllowChecks_getset = { _wrap_PersistantConfig_CheckUpdate_AllowChecks_get, _wrap_PersistantConfig_CheckUpdate_AllowChecks_set };
static SwigPyGetSet PersistantConfig_UnsupportedAndroid_LastUpdate_getset = { _wrap_PersistantConfig_UnsupportedAndroid_LastUpdate_get, _wrap_PersistantConfig_UnsupportedAndroid_LastUpdate_set };
static SwigPyGetSet PersistantConfig_CheckUpdate_LastUpdate_getset = { _wrap_PersistantConfig_CheckUpdate_LastUpdate_get, _wrap_PersistantConfig_CheckUpdate_LastUpdate_set };
static SwigPyGetSet PersistantConfig_DegradedCapture_LastUpdate_getset = { _wrap_PersistantConfig_DegradedCapture_LastUpdate_get, _wrap_PersistantConfig_DegradedCapture_LastUpdate_set };
static SwigPyGetSet PersistantConfig_CrashReport_EmailAddress_getset = { _wrap_PersistantConfig_CrashReport_EmailAddress_get, _wrap_PersistantConfig_CrashReport_EmailAddress_set };
static SwigPyGetSet PersistantConfig_RecentCaptureSettings_getset = { _wrap_PersistantConfig_RecentCaptureSettings_get, _wrap_PersistantConfig_RecentCaptureSettings_set };
static SwigPyGetSet PersistantConfig_TextureViewer_PerTexSettings_getset = { _wrap_PersistantConfig_TextureViewer_PerTexSettings_get, _wrap_PersistantConfig_TextureViewer_PerTexSettings_set };
static SwigPyGetSet PersistantConfig_ExternalTool_RadeonGPUProfiler_getset = { _wrap_PersistantConfig_ExternalTool_RadeonGPUProfiler_get, _wrap_PersistantConfig_ExternalTool_RadeonGPUProfiler_set };
static SwigPyGetSet PersistantConfig_CheckUpdate_CurrentVersion_getset = { _wrap_PersistantConfig_CheckUpdate_CurrentVersion_get, _wrap_PersistantConfig_CheckUpdate_CurrentVersion_set };
static SwigPyGetSet PersistantConfig_RecentCaptureFiles_getset = { _wrap_PersistantConfig_RecentCaptureFiles_get, _wrap_PersistantConfig_RecentCaptureFiles_set };
static SwigPyGetSet PersistantConfig_AllowProcessInject_getset = { _wrap_PersistantConfig_AllowProcessInject_get, _wrap_PersistantConfig_AllowProcessInject_set };
static SwigPyGetSet PersistantConfig_UIStyle_getset = { _wrap_PersistantConfig_UIStyle_get, _wrap_PersistantConfig_UIStyle_set };
static SwigPyGetSet PersistantConfig_EventBrowser_TimeUnit_getset = { _wrap_PersistantConfig_EventBrowser_TimeUnit_get, _wrap_PersistantConfig_EventBrowser_TimeUnit_set };
static SwigPyGetSet PersistantConfig_LastCapturePath_getset = { _wrap_PersistantConfig_LastCapturePath_get, _wrap_PersistantConfig_LastCapturePath_set };
static SwigPyGetSet PersistantConfig_Formatter_MaxFigures_getset = { _wrap_PersistantConfig_Formatter_MaxFigures_get, _wrap_PersistantConfig_Formatter_MaxFigures_set };
static SwigPyGetSet PersistantConfig_Formatter_MinFigures_getset = { _wrap_PersistantConfig_Formatter_MinFigures_get, _wrap_PersistantConfig_Formatter_MinFigures_set };
static SwigPyGetSet PersistantConfig_LastCaptureExe_getset = { _wrap_PersistantConfig_LastCaptureExe_get, _wrap_PersistantConfig_LastCaptureExe_set };
static SwigPyGetSet PersistantConfig_TemporaryCaptureDirectory_getset = { _wrap_PersistantConfig_TemporaryCaptureDirectory_get, _wrap_PersistantConfig_TemporaryCaptureDirectory_set };
static SwigPyGetSet PersistantConfig_DefaultCaptureSaveDirectory_getset = { _wrap_PersistantConfig_DefaultCaptureSaveDirectory_get, _wrap_PersistantConfig_DefaultCaptureSaveDirectory_set };
static SwigPyGetSet PersistantConfig_CrashReport_ShouldRememberEmail_getset = { _wrap_PersistantConfig_CrashReport_ShouldRememberEmail_get, _wrap_PersistantConfig_CrashReport_ShouldRememberEmail_set };
static SwigPyGetSet PersistantConfig_Comments_ShowOnLoad_getset = { _wrap_PersistantConfig_Comments_ShowOnLoad_get, _wrap_PersistantConfig_Comments_ShowOnLoad_set };
static SwigPyGetSet PersistantConfig_TextureViewer_ResetRange_getset = { _wrap_PersistantConfig_TextureViewer_ResetRange_get, _wrap_PersistantConfig_TextureViewer_ResetRange_set };
static SwigPyGetSet PersistantConfig_Formatter_NegExp_getset = { _wrap_PersistantConfig_Formatter_NegExp_get, _wrap_PersistantConfig_Formatter_NegExp_set };
static SwigPyGetSet PersistantConfig_Font_PreferMonospaced_getset = { _wrap_PersistantConfig_Font_PreferMonospaced_get, _wrap_PersistantConfig_Font_PreferMonospaced_set };
static SwigPyGetSet PersistantConfig_Font_MonoFamily_getset = { _wrap_PersistantConfig_Font_MonoFamily_get, _wrap_PersistantConfig_Font_MonoFamily_set };
static SwigPyGetSet PersistantConfig_Font_Family_getset = { _wrap_PersistantConfig_Font_Family_get, _wrap_PersistantConfig_Font_Family_set };
static SwigPyGetSet PersistantConfig___dict___getset = { SwigPyObject_get___dict__, 0 };
static SwigPyGetSet PersistantConfig_ShaderProcessors_getset = { _wrap_PersistantConfig_ShaderProcessors_get, _wrap_PersistantConfig_ShaderProcessors_set };
static SwigPyGetSet PersistantConfig_CrashReport_ReportedBugs_getset = { _wrap_PersistantConfig_CrashReport_ReportedBugs_get, _wrap_PersistantConfig_CrashReport_ReportedBugs_set };
static SwigPyGetSet PersistantConfig_TextureViewer_ShaderDirs_getset = { _wrap_PersistantConfig_TextureViewer_ShaderDirs_get, _wrap_PersistantConfig_TextureViewer_ShaderDirs_set };
static SwigPyGetSet PersistantConfig_DefaultReplayOptions_getset = { _wrap_PersistantConfig_DefaultReplayOptions_get, _wrap_PersistantConfig_DefaultReplayOptions_set };
static SwigPyGetSet PersistantConfig_AlwaysReplayLocally_getset = { _wrap_PersistantConfig_AlwaysReplayLocally_get, _wrap_PersistantConfig_AlwaysReplayLocally_set };
static SwigPyGetSet PersistantConfig_Analytics_ManualCheck_getset = { _wrap_PersistantConfig_Analytics_ManualCheck_get, _wrap_PersistantConfig_Analytics_ManualCheck_set };
static SwigPyGetSet PersistantConfig_AlwaysLoad_Extensions_getset = { _wrap_PersistantConfig_AlwaysLoad_Extensions_get, _wrap_PersistantConfig_AlwaysLoad_Extensions_set };
static SwigPyGetSet PersistantConfig_EventBrowser_AddFake_getset = { _wrap_PersistantConfig_EventBrowser_AddFake_get, _wrap_PersistantConfig_EventBrowser_AddFake_set };
static SwigPyGetSet PersistantConfig_TextureViewer_PerTexYFlip_getset = { _wrap_PersistantConfig_TextureViewer_PerTexYFlip_get, _wrap_PersistantConfig_TextureViewer_PerTexYFlip_set };
static SwigPyGetSet PersistantConfig_CheckUpdate_UpdateResponse_getset = { _wrap_PersistantConfig_CheckUpdate_UpdateResponse_get, _wrap_PersistantConfig_CheckUpdate_UpdateResponse_set };
static SwigPyGetSet PersistantConfig_LocalProxyAPI_getset = { _wrap_PersistantConfig_LocalProxyAPI_get, _wrap_PersistantConfig_LocalProxyAPI_set };
static SwigPyGetSet PersistantConfig_Font_GlobalScale_getset = { _wrap_PersistantConfig_Font_GlobalScale_get, _wrap_PersistantConfig_Font_GlobalScale_set };
static SwigPyGetSet PersistantConfig_LastFileBrowsePath_getset = { _wrap_PersistantConfig_LastFileBrowsePath_get, _wrap_PersistantConfig_LastFileBrowsePath_set };
static SwigPyGetSet PersistantConfig_EventBrowser_ApplyColors_getset = { _wrap_PersistantConfig_EventBrowser_ApplyColors_get, _wrap_PersistantConfig_EventBrowser_ApplyColors_set };
static SwigPyGetSet PersistantConfig_CrashReport_EmailNagged_getset = { _wrap_PersistantConfig_CrashReport_EmailNagged_get, _wrap_PersistantConfig_CrashReport_EmailNagged_set };
static SwigPyGetSet PersistantConfig_BufferFormatter_SavedFormats_getset = { _wrap_PersistantConfig_BufferFormatter_SavedFormats_get, _wrap_PersistantConfig_BufferFormatter_SavedFormats_set };
static SwigPyGetSet PersistantConfig_AllowGlobalHook_getset = { _wrap_PersistantConfig_AllowGlobalHook_get, _wrap_PersistantConfig_AllowGlobalHook_set };
static SwigPyGetSet PersistantConfig_Analytics_TotalOptOut_getset = { _wrap_PersistantConfig_Analytics_TotalOptOut_get, _wrap_PersistantConfig_Analytics_TotalOptOut_set };
static SwigPyGetSet PersistantConfig_Formatter_OffsetSizeDisplayMode_getset = { _wrap_PersistantConfig_Formatter_OffsetSizeDisplayMode_get, _wrap_PersistantConfig_Formatter_OffsetSizeDisplayMode_set };
static SwigPyGetSet PersistantConfig_EventBrowser_ColorEventRow_getset = { _wrap_PersistantConfig_EventBrowser_ColorEventRow_get, _wrap_PersistantConfig_EventBrowser_ColorEventRow_set };
static SwigPyGetSet PersistantConfig_CheckUpdate_UpdateAvailable_getset = { _wrap_PersistantConfig_CheckUpdate_UpdateAvailable_get, _wrap_PersistantConfig_CheckUpdate_UpdateAvailable_set };
static SwigPyGetSet PersistantConfig_Formatter_PosExp_getset = { _wrap_PersistantConfig_Formatter_PosExp_get, _wrap_PersistantConfig_Formatter_PosExp_set };
static SwigPyGetSet PersistantConfig_Tips_HasSeenFirst_getset = { _wrap_PersistantConfig_Tips_HasSeenFirst_get, _wrap_PersistantConfig_Tips_HasSeenFirst_set };
static SwigPyGetSet PersistantConfig_CrashReport_LastOpenedCapture_getset = { _wrap_PersistantConfig_CrashReport_LastOpenedCapture_get, _wrap_PersistantConfig_CrashReport_LastOpenedCapture_set };
static SwigPyGetSet PersistantConfig_LastCaptureFilePath_getset = { _wrap_PersistantConfig_LastCaptureFilePath_get, _wrap_PersistantConfig_LastCaptureFilePath_set };
SWIGINTERN PyGetSetDef SwigPyBuiltin__PersistantConfig_getset[] = {
    { (char *) "CheckUpdate_AllowChecks", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the UI should be allowed to make update checks remotely to see if a new version is available.\n"
		"\n"
		"Defaults to ``True``.:type: bool\n"
		"", (void *) &PersistantConfig_CheckUpdate_AllowChecks_getset }
,
    { (char *) "UnsupportedAndroid_LastUpdate", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"A date containing the last time that the user was warned about an Android device being older than is generally supported. This prevents the user being spammed if they consistently use an old Android device. If it has been more than 3 weeks since the last time an old device was seen, we re-warn the user, but if it's less than 3 weeks we silently update this date so continuous use doesn't nag.:type: datetime", (void *) &PersistantConfig_UnsupportedAndroid_LastUpdate_getset }
,
    { (char *) "CheckUpdate_LastUpdate", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"A date containing the last time that update checks happened.:type: datetime", (void *) &PersistantConfig_CheckUpdate_LastUpdate_getset }
,
    { (char *) "DegradedCapture_LastUpdate", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"A date containing the last time that the user was warned about captures being loaded in degraded support. This prevents the user being spammed if their hardware is low spec.:type: datetime", (void *) &PersistantConfig_DegradedCapture_LastUpdate_getset }
,
    { (char *) "CrashReport_EmailAddress", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The saved email address for pre-filling out in crash reports.:type: str", (void *) &PersistantConfig_CrashReport_EmailAddress_getset }
,
    { (char *) "RecentCaptureSettings", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The recently opened capture settings files.\n"
		"\n"
		":type: List[str]\n"
		"", (void *) &PersistantConfig_RecentCaptureSettings_getset }
,
    { (char *) "TextureViewer_PerTexSettings", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the :class:`TextureViewer` should store most visualisation settings on a per-texture basis instead of keeping it persistent across different textures.\n"
		"\n"
		":Defaults to ``True``.:type: bool\n"
		"", (void *) &PersistantConfig_TextureViewer_PerTexSettings_getset }
,
    { (char *) "ExternalTool_RadeonGPUProfiler", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The path to the executable of the external Radeon GPU Profiler tool.:type: str", (void *) &PersistantConfig_ExternalTool_RadeonGPUProfiler_getset }
,
    { (char *) "CheckUpdate_CurrentVersion", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The current version at the time of update checks. Used to determine if a cached pending update is no longer valid because we got updated through some other method.:type: str", (void *) &PersistantConfig_CheckUpdate_CurrentVersion_getset }
,
    { (char *) "RecentCaptureFiles", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The recently opened capture files.\n"
		"\n"
		":type: List[str]\n"
		"", (void *) &PersistantConfig_RecentCaptureFiles_getset }
,
    { (char *) "AllowProcessInject", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if process injection is enabled. Since it can often break and is almost always not want users want to do. New users can get confused by it being there and go to it first.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_AllowProcessInject_getset }
,
    { (char *) "UIStyle", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The style to load for the UI. Possible values include 'Native', 'RDLight', 'RDDark'. If empty, the closest of RDLight and RDDark will be chosen, based on the overall light-on-dark or dark-on-light theme of the application native style.:type: str", (void *) &PersistantConfig_UIStyle_getset }
,
    { (char *) "EventBrowser_TimeUnit", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The :class:`TimeUnit` to use to display the duration column in the :class:`EventBrowser`.\n"
		"\n"
		"Defaults to microseconds.:type: TimeUnit\n"
		"", (void *) &PersistantConfig_EventBrowser_TimeUnit_getset }
,
    { (char *) "LastCapturePath", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The path containing the last executable that was captured, which is useful as a default location for browsing.:type: str", (void *) &PersistantConfig_LastCapturePath_getset }
,
    { (char *) "Formatter_MaxFigures", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The maximum number of decimal places to show in formatted floating point values.\n"
		"\n"
		".. note::\n"
		"  The naming of 'MaxFigures' is a historical artifact - this controls the number of   decimal places only, not the number of significant figures.\n"
		"\n"
		"Defaults to ``5``.:type: int\n"
		"", (void *) &PersistantConfig_Formatter_MaxFigures_getset }
,
    { (char *) "Formatter_MinFigures", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The minimum number of decimal places to show in formatted floating point values.\n"
		"\n"
		".. note::\n"
		"  The naming of 'MinFigures' is a historical artifact - this controls the number of   decimal places only, not the number of significant figures.\n"
		"\n"
		"Defaults to ``2``.:type: int\n"
		"", (void *) &PersistantConfig_Formatter_MinFigures_getset }
,
    { (char *) "LastCaptureExe", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The filename of the last executable that was captured, inside :data:`LastCapturePath`.:type: str", (void *) &PersistantConfig_LastCaptureExe_getset }
,
    { (char *) "TemporaryCaptureDirectory", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The path to where temporary capture files should be stored until they're saved permanently.:type: str", (void *) &PersistantConfig_TemporaryCaptureDirectory_getset }
,
    { (char *) "DefaultCaptureSaveDirectory", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The default path to save captures in, when browsing to save a temporary capture somewhere.:type: str", (void *) &PersistantConfig_DefaultCaptureSaveDirectory_getset }
,
    { (char *) "CrashReport_ShouldRememberEmail", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the email address entered in the crash reporter should be remembered for next time. If no email is entered then nothing happens (any previous saved email is kept).\n"
		"\n"
		"Defaults to ``True``.:type: bool\n"
		"", (void *) &PersistantConfig_CrashReport_ShouldRememberEmail_getset }
,
    { (char *) "Comments_ShowOnLoad", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if when loading a new capture that contains a comments section, the comment viewer will be opened and focussed.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_Comments_ShowOnLoad_getset }
,
    { (char *) "TextureViewer_ResetRange", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the :class:`TextureViewer` should reset the visible range when a new texture is selected.\n"
		"\n"
		":Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_TextureViewer_ResetRange_getset }
,
    { (char *) "Formatter_NegExp", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The cut-off on negative exponents of a normalised values to display using scientific notation.\n"
		"\n"
		"E.g. for a value of 5, anything below 1.0e-5 will be displayed using scientific notation.\n"
		"\n"
		"Defaults to ``5``.:type: int\n"
		"", (void *) &PersistantConfig_Formatter_NegExp_getset }
,
    { (char *) "Font_PreferMonospaced", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if a monospaced font should be used in all places where data is displayed, even if the data is not tabular such as names.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_Font_PreferMonospaced_getset }
,
    { (char *) "Font_MonoFamily", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The monospaced font family to use in the UI.\n"
		"\n"
		"Defaults to an empty string which means to use the system default.:type: str\n"
		"", (void *) &PersistantConfig_Font_MonoFamily_getset }
,
    { (char *) "Font_Family", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The font family to use in the UI.\n"
		"\n"
		"Defaults to an empty string which means to use the system default.:type: str\n"
		"", (void *) &PersistantConfig_Font_Family_getset }
,
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"PersistantConfig.__dict__", (void *) &PersistantConfig___dict___getset }
,
    { (char *) "ShaderProcessors", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"A list of :class:`ShaderProcessingTool` detailing shader processing programs. The list comes in priority order, with earlier processors preferred over later ones.\n"
		"\n"
		":type: List[ShaderProcessingTool]\n"
		"", (void *) &PersistantConfig_ShaderProcessors_getset }
,
    { (char *) "CrashReport_ReportedBugs", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"A list of :class:`BugReport` detailing previously submitted bugs that we're watching for updates.\n"
		"\n"
		":type: List[BugReport]\n"
		"", (void *) &PersistantConfig_CrashReport_ReportedBugs_getset }
,
    { (char *) "TextureViewer_ShaderDirs", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"List of the directories containing custom shader files for the Texture Viewer.\n"
		"\n"
		":type: List[str]\n"
		"", (void *) &PersistantConfig_TextureViewer_ShaderDirs_getset }
,
    { (char *) "DefaultReplayOptions", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"A :class:`ReplayOptions` containing the configured default replay options to use in most scenarios when no specific options are given.\n"
		"\n"
		":type: renderdoc.ReplayOptions\n"
		"", (void *) &PersistantConfig_DefaultReplayOptions_getset }
,
    { (char *) "AlwaysReplayLocally", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if when loading a capture that was originally captured on a remote device but uses an API that can be supported locally, should be loaded locally without prompting to switch to a remote context.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_AlwaysReplayLocally_getset }
,
    { (char *) "Analytics_ManualCheck", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the user has remained with analytics turned on, but has chosen to manually check each report that is sent out.\n"
		"collection and reporting.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_Analytics_ManualCheck_getset }
,
    { (char *) "AlwaysLoad_Extensions", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"A list of strings with extension packages to always load on startup, without needing manual enabling.\n"
		"\n"
		":type: List[str]\n"
		"", (void *) &PersistantConfig_AlwaysLoad_Extensions_getset }
,
    { (char *) "EventBrowser_AddFake", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if fake action marker regions should be added to captures that don't have any markers, for easier browsing. The regions are identified by grouping actions that write to the same targets together.\n"
		"\n"
		"Defaults to ``True``.:type: bool\n"
		"", (void *) &PersistantConfig_EventBrowser_AddFake_getset }
,
    { (char *) "TextureViewer_PerTexYFlip", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the :class:`TextureViewer` should treat y-flipping as a per-texture state rather than a global toggle.\n"
		"\n"
		"Does nothing if per-texture settings are disabled in general.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_TextureViewer_PerTexYFlip_getset }
,
    { (char *) "CheckUpdate_UpdateResponse", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"Contains the response from the update server from the last update check, with any release notes for the new version.:type: str", (void *) &PersistantConfig_CheckUpdate_UpdateResponse_getset }
,
    { (char *) "LocalProxyAPI", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The index of the local proxy API to use when using remote context replay. ``-1`` if the default proxy should be used.\n"
		"\n"
		"Defaults to ``-1``.:type: int\n"
		"", (void *) &PersistantConfig_LocalProxyAPI_getset }
,
    { (char *) "Font_GlobalScale", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The global scale to apply to fonts in the application, expressed as a float.\n"
		"\n"
		"Defaults to ``1.0`` which means 100%.:type: float\n"
		"", (void *) &PersistantConfig_Font_GlobalScale_getset }
,
    { (char *) "LastFileBrowsePath", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The path to the last file browsed to in any dialog. Used as a default location for all file browsers without another explicit default directory (such as opening capture files - see :data:`LastCaptureFilePath`).:type: str", (void *) &PersistantConfig_LastFileBrowsePath_getset }
,
    { (char *) "EventBrowser_ApplyColors", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the :class:`EventBrowser` should apply any colors specified with API marker regions.\n"
		"\n"
		"Defaults to ``True``.:type: bool\n"
		"", (void *) &PersistantConfig_EventBrowser_ApplyColors_getset }
,
    { (char *) "CrashReport_EmailNagged", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the user has been prompted to enter their email address on a crash report. This really helps find fixes for bugs, so we prompt the user once only if they didn't enter an email. Once the prompt has happened, regardless of the answer this is set to true and remains there forever.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_CrashReport_EmailNagged_getset }
,
    { (char *) "BufferFormatter_SavedFormats", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"A list of strings with saved formats for the buffer formatter. The first line is the name and the rest of the contents are the formats.\n"
		"\n"
		":type: List[str]\n"
		"", (void *) &PersistantConfig_BufferFormatter_SavedFormats_getset }
,
    { (char *) "AllowGlobalHook", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if global hooking is enabled. Since it has potentially problematic side-effects and is dangerous, it requires explicit opt-in.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_AllowGlobalHook_getset }
,
    { (char *) "Analytics_TotalOptOut", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the user has selected to completely opt-out from and disable all analytics collection and reporting.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_Analytics_TotalOptOut_getset }
,
    { (char *) "Formatter_OffsetSizeDisplayMode", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The formatting mode to use for values marked as Offsets or Sizes.\n"
		"\n"
		"E.g. Auto: decimal by default and hexadecimal if above a certain threshold, Decimal: always use decimal, Hexadecimal: always use hexadecimal.\n"
		"Defaults to ``Auto``.:type: OffsetSizeDisplayMode\n"
		"", (void *) &PersistantConfig_Formatter_OffsetSizeDisplayMode_getset }
,
    { (char *) "EventBrowser_ColorEventRow", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if when coloring marker regions in the :class:`EventBrowser`, the whole row should be colored instead of just a side-bar.\n"
		"\n"
		"Defaults to ``True``.:type: bool\n"
		"", (void *) &PersistantConfig_EventBrowser_ColorEventRow_getset }
,
    { (char *) "CheckUpdate_UpdateAvailable", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if an update to a newer version is currently available.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_CheckUpdate_UpdateAvailable_getset }
,
    { (char *) "Formatter_PosExp", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The cut-off on positive exponents of a normalised values to display using scientific notation.\n"
		"\n"
		"E.g. for a value of 7, anything below 1.0e+7 will be displayed using scientific notation.\n"
		"\n"
		"Defaults to ``7``.:type: int\n"
		"", (void *) &PersistantConfig_Formatter_PosExp_getset }
,
    { (char *) "Tips_HasSeenFirst", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"``True`` if the user has seen the first tip, which should always be shown first before randomising.\n"
		"\n"
		"Defaults to ``False``.:type: bool\n"
		"", (void *) &PersistantConfig_Tips_HasSeenFirst_getset }
,
    { (char *) "CrashReport_LastOpenedCapture", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The last opened capture, to send if any crash is encountered. This is different to the most recent opened file, because it's set before any processing happens (recent files are only added to the list when they successfully open), and it's cleared again when the capture is closed.:type: str", (void *) &PersistantConfig_CrashReport_LastOpenedCapture_getset }
,
    { (char *) "LastCaptureFilePath", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"The path to the last capture to be opened, which is useful as a default location for browsing.:type: str", (void *) &PersistantConfig_LastCaptureFilePath_getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__PersistantConfig_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__PersistantConfig_methods[] = {
  { "GetRemoteHosts", (PyCFunction) _wrap_PersistantConfig_GetRemoteHosts, METH_NOARGS, (char *) "\n"
		"GetRemoteHosts()\n"
		"\n"
		"Returns a list of all remote hosts.\n"
		"\n"
		":return: The remote host list\n"
		":rtype: List[RemoteHost]\n"
		"\n"
		"" },
  { "GetRemoteHost", (PyCFunction) _wrap_PersistantConfig_GetRemoteHost, METH_O, (char *) "\n"
		"GetRemoteHost(hostname)\n"
		"\n"
		"Look up a remote host by hostname.\n"
		"\n"
		":param str hostname: The hostname to look up\n"
		":return: The remote host for the given hostname, or an invalid ``RemoteHost`` if no such exists.\n"
		":rtype: RemoteHost\n"
		"\n"
		"" },
  { "AddRemoteHost", (PyCFunction) _wrap_PersistantConfig_AddRemoteHost, METH_O, (char *) "\n"
		"AddRemoteHost(host)\n"
		"\n"
		"Adds a new remote host.\n"
		"\n"
		":param RemoteHost host: The remote host to add.\n"
		"\n"
		"" },
  { "RemoveRemoteHost", (PyCFunction) _wrap_PersistantConfig_RemoveRemoteHost, METH_O, (char *) "\n"
		"RemoveRemoteHost(host)\n"
		"\n"
		"Removes an existing remote host.\n"
		"\n"
		":param RemoteHost host: The remote host to remove.\n"
		"\n"
		"" },
  { "UpdateEnumeratedProtocolDevices", (PyCFunction) _wrap_PersistantConfig_UpdateEnumeratedProtocolDevices, METH_NOARGS, (char *) "\n"
		"UpdateEnumeratedProtocolDevices()\n"
		"\n"
		"If configured, queries available device protocols to update auto-configured hosts.\n"
		"" },
  { "Load", (PyCFunction) _wrap_PersistantConfig_Load, METH_O, (char *) "\n"
		"Load(filename)\n"
		"\n"
		"Loads the config from a given filename. This happens automatically on startup, so it's\n"
		"not recommended that you call this function manually.\n"
		"\n"
		":param str filename: The filename to load from\n"
		":return: A boolean status if the load was successful.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "Save", (PyCFunction) _wrap_PersistantConfig_Save, METH_NOARGS, (char *) "\n"
		"Save()\n"
		"\n"
		"Saves the config to disk. This can happen if you want to be sure a setting has been\n"
		"propagated and will not be forgotten in the case of crash or otherwise unexpected exit.\n"
		"\n"
		":return: A boolean status if the save was successful.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "Close", (PyCFunction) _wrap_PersistantConfig_Close, METH_NOARGS, (char *) "\n"
		"Close()\n"
		"\n"
		"Closes the config file so that subsequent calls to Save() will not write to disk at\n"
		"the file the config was loaded from.\n"
		"\n"
		"This function is rarely directly used, except in the case where RenderDoc is relaunching itself and\n"
		"wants to avoid file locking conflicts between the closing instance saving, and the loading instance\n"
		"loading. It can explicitly save and close before relaunching.\n"
		"\n"
		"" },
  { "SetupFormatting", (PyCFunction) _wrap_PersistantConfig_SetupFormatting, METH_NOARGS, (char *) "\n"
		"SetupFormatting()\n"
		"\n"
		"Configures the :class:`Formatter` class with the settings from this config.\n"
		"" },
  { "SetStyle", (PyCFunction) _wrap_PersistantConfig_SetStyle, METH_NOARGS, (char *) "\n"
		"SetStyle()\n"
		"\n"
		"Sets the UI style to the value in :data:`UIStyle`.\n"
		"\n"
		"Changing the style after the application has started may not properly update everything, so to be\n"
		"sure the new style is applied, the application should be restarted.\n"
		"\n"
		":return: ``True`` if the style was set successfully, ``False`` if there was a problem e.g. the value\n"
		"  of :data:`UIStyle` was unrecognised or empty.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__PersistantConfig_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.PersistantConfig",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_PersistantConfig_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__PersistantConfig_type.as_number,              /* tp_as_number */
    &SwigPyBuiltin__PersistantConfig_type.as_sequence,            /* tp_as_sequence */
    &SwigPyBuiltin__PersistantConfig_type.as_mapping,             /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__PersistantConfig_type.as_buffer,              /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A persistant config file that is automatically loaded and saved, which contains any\n"
		"settings and information that needs to be preserved from one run to the next.\n"
		"\n"
		"The config is retrieved by calling :meth:`CaptureContext.Config`.\n"
		"\n"
		"For more information about some of these settings that are user-facing see\n"
		":ref:`the documentation for the settings window <settings-window>`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__PersistantConfig_richcompare,    /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__PersistantConfig_methods,  /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__PersistantConfig_getset,   /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_PersistantConfig,    /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__PersistantConfig_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__PersistantConfig_type};

static SwigPyGetSet RemoteHost___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__RemoteHost_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"RemoteHost.__dict__", (void *) &RemoteHost___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__RemoteHost_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_RemoteHost___eq__(self, other); break;
    case Py_NE : result = _wrap_RemoteHost___ne__(self, other); break;
    case Py_LT : result = _wrap_RemoteHost___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__RemoteHost_methods[] = {
  { "__eq__", (PyCFunction) _wrap_RemoteHost___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_RemoteHost___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_RemoteHost___lt__, METH_O, (char *) "__lt__(o)" },
  { "CheckStatus", (PyCFunction) _wrap_RemoteHost_CheckStatus, METH_NOARGS, (char *) "\n"
		"CheckStatus()\n"
		"\n"
		"Ping the host to check current status - if the server is running, connection status, etc.\n"
		"" },
  { "Launch", (PyCFunction) _wrap_RemoteHost_Launch, METH_NOARGS, (char *) "\n"
		"Launch()\n"
		"\n"
		"Runs the command specified in :data:`runCommand`. Returns\n"
		":class:`~renderdoc.ResultDetails` which indicates success or the type of failure.\n"
		"\n"
		":return: The result from launching the remote server.\n"
		":rtype: renderdoc.ResultDetails\n"
		"\n"
		"" },
  { "IsServerRunning", (PyCFunction) _wrap_RemoteHost_IsServerRunning, METH_NOARGS, (char *) "\n"
		"IsServerRunning()\n"
		"\n"
		"\n"
		":return: ``True`` if a remote server is currently running on this host.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsConnected", (PyCFunction) _wrap_RemoteHost_IsConnected, METH_NOARGS, (char *) "\n"
		"IsConnected()\n"
		"\n"
		"\n"
		":return: ``True`` if an active connection exists to this remote server.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsBusy", (PyCFunction) _wrap_RemoteHost_IsBusy, METH_NOARGS, (char *) "\n"
		"IsBusy()\n"
		"\n"
		"\n"
		":return: ``True`` if someone else is currently connected to this server.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsVersionMismatch", (PyCFunction) _wrap_RemoteHost_IsVersionMismatch, METH_NOARGS, (char *) "\n"
		"IsVersionMismatch()\n"
		"\n"
		"\n"
		":return: ``True`` if there is a code version mismatch with this server.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "VersionMismatchError", (PyCFunction) _wrap_RemoteHost_VersionMismatchError, METH_NOARGS, (char *) "\n"
		"VersionMismatchError()\n"
		"\n"
		"\n"
		":return: The version mismatch error.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "Hostname", (PyCFunction) _wrap_RemoteHost_Hostname, METH_NOARGS, (char *) "\n"
		"Hostname()\n"
		"\n"
		"\n"
		":return: The hostname of this host.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "FriendlyName", (PyCFunction) _wrap_RemoteHost_FriendlyName, METH_NOARGS, (char *) "\n"
		"FriendlyName()\n"
		"\n"
		"\n"
		":return: The friendly name for this host, if available (if empty, the Hostname is used).\n"
		":rtype: str\n"
		"\n"
		"" },
  { "RunCommand", (PyCFunction) _wrap_RemoteHost_RunCommand, METH_NOARGS, (char *) "\n"
		"RunCommand()\n"
		"\n"
		"\n"
		":return: The command to run locally to try to launch the server remotely.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "SetRunCommand", (PyCFunction) _wrap_RemoteHost_SetRunCommand, METH_O, (char *) "\n"
		"SetRunCommand(cmd)\n"
		"\n"
		"Sets the run command. See :meth:`RunCommand`.\n"
		"\n"
		":param str cmd: The new command to set.\n"
		"\n"
		"" },
  { "LastCapturePath", (PyCFunction) _wrap_RemoteHost_LastCapturePath, METH_NOARGS, (char *) "\n"
		"LastCapturePath()\n"
		"\n"
		"\n"
		":return: The last folder browsed to on this host, to provide a reasonable default path.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "SetLastCapturePath", (PyCFunction) _wrap_RemoteHost_SetLastCapturePath, METH_O, (char *) "\n"
		"SetLastCapturePath(path)\n"
		"\n"
		"Sets the last folder browsed to. See :meth:`LastCapturePath`.\n"
		"\n"
		":param str path: The new path to set.\n"
		"\n"
		"" },
  { "Connect", (PyCFunction) _wrap_RemoteHost_Connect, METH_O, (char *) "\n"
		"Connect(server)\n"
		"\n"
		"Create a connection to the remote server.\n"
		"\n"
		":return: The status of opening the capture, whether success or failure, and a :class:`RemoteServer`\n"
		"  instance if it were successful\n"
		":rtype: Tuple[renderdoc.ResultDetails, renderdoc.RemoteServer]\n"
		"\n"
		"" },
  { "Protocol", (PyCFunction) _wrap_RemoteHost_Protocol, METH_NOARGS, (char *) "\n"
		"Protocol()\n"
		"\n"
		"\n"
		":return: The :class:`~renderdoc.DeviceProtocolController` for this host, or ``None`` if no protocol\n"
		"  is in use\n"
		":rtype: renderdoc.DeviceProtocolController\n"
		"\n"
		"" },
  { "Name", (PyCFunction) _wrap_RemoteHost_Name, METH_NOARGS, (char *) "\n"
		"Name()\n"
		"\n"
		"\n"
		":return: The name to display for this host in the UI, either :meth:`FriendlyName` if it is valid, or\n"
		"  :meth:`Hostname` if not.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "IsLocalhost", (PyCFunction) _wrap_RemoteHost_IsLocalhost, METH_NOARGS, (char *) "\n"
		"IsLocalhost()\n"
		"\n"
		"\n"
		":return: Returns ``True`` if this host represents the special localhost device.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "IsValid", (PyCFunction) _wrap_RemoteHost_IsValid, METH_NOARGS, (char *) "\n"
		"IsValid()\n"
		"\n"
		"Returns ``True`` if this host represents a valid remote host.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__RemoteHost_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.RemoteHost",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_RemoteHost_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__RemoteHost_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__RemoteHost_type.as_sequence,                  /* tp_as_sequence */
    &SwigPyBuiltin__RemoteHost_type.as_mapping,                   /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__RemoteHost_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "A handle for interacting with a remote server on a given host.",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__RemoteHost_richcompare,          /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__RemoteHost_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__RemoteHost_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_RemoteHost,          /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__RemoteHost_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__RemoteHost_type};

static SwigPyGetSet WindowMenu___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__WindowMenu_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"WindowMenu.__dict__", (void *) &WindowMenu___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__WindowMenu_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__WindowMenu_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__WindowMenu_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "WindowMenu",                             /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_WindowMenu_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__WindowMenu_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__WindowMenu_type.as_sequence,                  /* tp_as_sequence */
    &SwigPyBuiltin__WindowMenu_type.as_mapping,                   /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__WindowMenu_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Specifies the base menu to add a menu item into.\n"
		"\n"
		".. data:: Unknown\n"
		"\n"
		"  Unknown/invalid window.\n"
		"\n"
		".. data:: File\n"
		"\n"
		"  The menu item will be in a section between Open/Save/Close captures and Import/Export.\n"
		"\n"
		".. data:: Window\n"
		"\n"
		"  The menu item will be in a new section at the end of the menu.\n"
		"\n"
		".. data:: Tools\n"
		"\n"
		"  The menu item will be added to a new section above Settings.\n"
		"\n"
		".. data:: NewMenu\n"
		"\n"
		"  The menu item will be a root menu, placed between Tools and Help.\n"
		"\n"
		".. data:: Help\n"
		"\n"
		"  The menu item will be added after the error reporting item.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__WindowMenu_richcompare,          /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__WindowMenu_methods,        /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__WindowMenu_getset,         /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_WindowMenu,          /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__WindowMenu_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__WindowMenu_type};

static SwigPyGetSet PanelMenu___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__PanelMenu_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"PanelMenu.__dict__", (void *) &PanelMenu___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__PanelMenu_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__PanelMenu_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__PanelMenu_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "PanelMenu",                              /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_PanelMenu_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__PanelMenu_type.as_number, /* tp_as_number */
    &SwigPyBuiltin__PanelMenu_type.as_sequence,                   /* tp_as_sequence */
    &SwigPyBuiltin__PanelMenu_type.as_mapping,/* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__PanelMenu_type.as_buffer, /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Specifies the panel to add a menu item into.\n"
		"\n"
		".. data:: Unknown\n"
		"\n"
		"  Unknown/invalid panel.\n"
		"\n"
		".. data:: EventBrowser\n"
		"\n"
		"  The :class:`EventBrowser`.\n"
		"\n"
		".. data:: PipelineStateViewer\n"
		"\n"
		"  The :class:`PipelineStateViewer`.\n"
		"\n"
		".. data:: MeshPreview\n"
		"\n"
		"  The mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: TextureViewer\n"
		"\n"
		"  The :class:`TextureViewer`.\n"
		"\n"
		".. data:: BufferViewer\n"
		"\n"
		"  Any non-mesh previewing :class:`BufferViewer`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__PanelMenu_richcompare,           /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__PanelMenu_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__PanelMenu_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_PanelMenu,           /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__PanelMenu_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__PanelMenu_type};

static SwigPyGetSet ContextMenu___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ContextMenu_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ContextMenu.__dict__", (void *) &ContextMenu___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ContextMenu_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ContextMenu_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ContextMenu_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "ContextMenu",                            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_ContextMenu_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ContextMenu_type.as_number,                   /* tp_as_number */
    &SwigPyBuiltin__ContextMenu_type.as_sequence,                 /* tp_as_sequence */
    &SwigPyBuiltin__ContextMenu_type.as_mapping,                  /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ContextMenu_type.as_buffer,                   /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Specifies the panel to add a menu item into.\n"
		"\n"
		".. data:: Unknown\n"
		"\n"
		"  Unknown/invalid context menu.\n"
		"\n"
		".. data:: EventBrowser_Event\n"
		"\n"
		"  Adds the item to the context menu for events in the :class:`EventBrowser`.\n"
		"\n"
		".. data:: MeshPreview_Vertex\n"
		"\n"
		"  Adds the item to the context menu for all vertices in the mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: MeshPreview_VSInVertex\n"
		"\n"
		"  Adds the item to the context menu for vertex inputs in the mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: MeshPreview_VSOutVertex\n"
		"\n"
		"  Adds the item to the context menu for VS output in the mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: MeshPreview_GSOutVertex\n"
		"\n"
		"  Adds the item to the context menu for GS/Tess output in the mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: MeshPreview_TaskOutVertex\n"
		"\n"
		"  Adds the item to the context menu for task shader output in the mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: MeshPreview_MeshOutVertex\n"
		"\n"
		"  Adds the item to the context menu for mesh shader output in the mesh previewing :class:`BufferViewer`.\n"
		"\n"
		".. data:: TextureViewer_Thumbnail\n"
		"\n"
		"  Adds the item to the context menu for all thumbnails in the :class:`TextureViewer`.\n"
		"\n"
		".. data:: TextureViewer_InputThumbnail\n"
		"\n"
		"  Adds the item to the context menu for input thumbnails in the :class:`TextureViewer`.\n"
		"\n"
		".. data:: TextureViewer_OutputThumbnail\n"
		"\n"
		"  Adds the item to the context menu for output thumbnails in the :class:`TextureViewer`.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ContextMenu_richcompare,         /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ContextMenu_methods,       /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ContextMenu_getset,        /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_ContextMenu,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ContextMenu_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ContextMenu_type};

static SwigPyGetSet DialogButton___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__DialogButton_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"DialogButton.__dict__", (void *) &DialogButton___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__DialogButton_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__DialogButton_methods[] = {
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__DialogButton_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "DialogButton",                           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_DialogButton_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__DialogButton_type.as_number,                  /* tp_as_number */
    &SwigPyBuiltin__DialogButton_type.as_sequence,                /* tp_as_sequence */
    &SwigPyBuiltin__DialogButton_type.as_mapping,                 /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__DialogButton_type.as_buffer,                  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A button for a dialog prompt.\n"
		"\n"
		".. data:: OK\n"
		"\n"
		"  An OK button\n"
		"\n"
		".. data:: Save\n"
		"\n"
		"  A Save button\n"
		"\n"
		".. data:: SaveAll\n"
		"\n"
		"  A Save All button\n"
		"\n"
		".. data:: Open\n"
		"\n"
		"  An Open button\n"
		"\n"
		".. data:: Yes\n"
		"\n"
		"  A Yes button\n"
		"\n"
		".. data:: YesToAll\n"
		"\n"
		"  A Yes To All button\n"
		"\n"
		".. data:: No\n"
		"\n"
		"  A No button\n"
		"\n"
		".. data:: NoToAll\n"
		"\n"
		"  A No To All button\n"
		"\n"
		".. data:: Abort\n"
		"\n"
		"  An Abort button\n"
		"\n"
		".. data:: Retry\n"
		"\n"
		"  A Retry button\n"
		"\n"
		".. data:: Ignore\n"
		"\n"
		"  An Ignore button\n"
		"\n"
		".. data:: Close\n"
		"\n"
		"  A Close button\n"
		"\n"
		".. data:: Cancel\n"
		"\n"
		"  A Cancel button\n"
		"\n"
		".. data:: Discard\n"
		"\n"
		"  A Discard button\n"
		"\n"
		".. data:: Help\n"
		"\n"
		"  A Help button\n"
		"\n"
		".. data:: Apply\n"
		"\n"
		"  An Apply button\n"
		"\n"
		".. data:: Reset\n"
		"\n"
		"  A Reset button\n"
		"\n"
		".. data:: RestoreDefaults\n"
		"\n"
		"  A Restore Defaults button\n"
		"\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__DialogButton_richcompare,        /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__DialogButton_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__DialogButton_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_DialogButton,        /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__DialogButton_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__DialogButton_type};

static SwigPyGetSet ExtensionMetadata_package_getset = { _wrap_ExtensionMetadata_package_get, _wrap_ExtensionMetadata_package_set };
static SwigPyGetSet ExtensionMetadata_version_getset = { _wrap_ExtensionMetadata_version_get, _wrap_ExtensionMetadata_version_set };
static SwigPyGetSet ExtensionMetadata_description_getset = { _wrap_ExtensionMetadata_description_get, _wrap_ExtensionMetadata_description_set };
static SwigPyGetSet ExtensionMetadata_extensionAPI_getset = { _wrap_ExtensionMetadata_extensionAPI_get, _wrap_ExtensionMetadata_extensionAPI_set };
static SwigPyGetSet ExtensionMetadata___dict___getset = { SwigPyObject_get___dict__, 0 };
static SwigPyGetSet ExtensionMetadata_author_getset = { _wrap_ExtensionMetadata_author_get, _wrap_ExtensionMetadata_author_set };
static SwigPyGetSet ExtensionMetadata_extensionURL_getset = { _wrap_ExtensionMetadata_extensionURL_get, _wrap_ExtensionMetadata_extensionURL_set };
static SwigPyGetSet ExtensionMetadata_name_getset = { _wrap_ExtensionMetadata_name_get, _wrap_ExtensionMetadata_name_set };
static SwigPyGetSet ExtensionMetadata_filePath_getset = { _wrap_ExtensionMetadata_filePath_get, _wrap_ExtensionMetadata_filePath_set };
SWIGINTERN PyGetSetDef SwigPyBuiltin__ExtensionMetadata_getset[] = {
    { (char *) "package", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The python package for this extension, e.g. foo.bar\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_package_getset }
,
    { (char *) "version", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The version of the extension\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_version_getset }
,
    { (char *) "description", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"A longer description of what the extension does\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_description_getset }
,
    { (char *) "extensionAPI", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The version of the extension API that this extension is written against\n"
		"\n"
		":type: int\n"
		"\n"
		"", (void *) &ExtensionMetadata_extensionAPI_getset }
,
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"ExtensionMetadata.__dict__", (void *) &ExtensionMetadata___dict___getset }
,
    { (char *) "author", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The author of the extension, optionally with an email contact\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_author_getset }
,
    { (char *) "extensionURL", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The URL for where the extension is fetched from\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_extensionURL_getset }
,
    { (char *) "name", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The short friendly name for the extension\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_name_getset }
,
    { (char *) "filePath", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) SwigPyBuiltin_FunpackSetterClosure, (char *)"\n"
		"The location of this package on disk\n"
		"\n"
		":type: str\n"
		"\n"
		"", (void *) &ExtensionMetadata_filePath_getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__ExtensionMetadata_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_ExtensionMetadata___eq__(self, other); break;
    case Py_LT : result = _wrap_ExtensionMetadata___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__ExtensionMetadata_methods[] = {
  { "__eq__", (PyCFunction) _wrap_ExtensionMetadata___eq__, METH_O, (char *) "__eq__(o)" },
  { "__lt__", (PyCFunction) _wrap_ExtensionMetadata___lt__, METH_O, (char *) "__lt__(o)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__ExtensionMetadata_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ExtensionMetadata",           /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_ExtensionMetadata_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__ExtensionMetadata_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__ExtensionMetadata_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__ExtensionMetadata_type.as_mapping,            /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__ExtensionMetadata_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "The metadata for an extension.",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__ExtensionMetadata_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__ExtensionMetadata_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__ExtensionMetadata_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) _wrap_new_ExtensionMetadata,   /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__ExtensionMetadata_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__ExtensionMetadata_type};

static SwigPyGetSet MiniQtHelper___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IMiniQtHelper_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IMiniQtHelper.__dict__", (void *) &MiniQtHelper___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IMiniQtHelper_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IMiniQtHelper_methods[] = {
  { "InvokeOntoUIThread", (PyCFunction) _wrap_MiniQtHelper_InvokeOntoUIThread, METH_O, (char *) "\n"
		"InvokeOntoUIThread(callback)\n"
		"\n"
		"Invoke a callback on the UI thread. All widget accesses must come from the UI thread,\n"
		"so if work has been done on the render thread then this function can be used to asynchronously and\n"
		"safely go back to the UI thread.\n"
		"\n"
		"This function is safe to call on the UI thread, but it will synchronously call the callback\n"
		"immediately before returning.\n"
		"\n"
		".. note::\n"
		"  No parameters are provided to the callback, it is assumed that the callback will maintain its own\n"
		"  context as needed.\n"
		"\n"
		":param InvokeCallback callback: The callback to invoke on the UI thread.\n"
		"  Callback function signature must match :func:`InvokeCallback`.\n"
		"\n"
		"" },
  { "CreateToplevelWidget", (PyCFunction) _wrap_MiniQtHelper_CreateToplevelWidget, METH_VARARGS, (char *) "\n"
		"CreateToplevelWidget(windowTitle, closed)\n"
		"\n"
		"Creates and returns a top-level widget for creating layouts.\n"
		"\n"
		"The widget is not immediately visible. It should be shown either with :meth:`ShowWidgetAsDialog` or\n"
		"with :meth:`CaptureContext.AddDockWindow` once it's ready.\n"
		"\n"
		"This widget can have children added, but it is recommended to immediately add only one child which\n"
		"is a layout type widget, to allow customising how children are added. By default the children are\n"
		"added in a vertical layout.\n"
		"\n"
		":param str windowTitle: The title of any window with this widget as its root.\n"
		":param WidgetCallback closed: A callback that will be called when the widget is closed by the user.\n"
		"  This implicitly deletes the widget and all its children, which will no longer be valid even if a\n"
		"  handle to them exists.\n"
		"  Callback function signature must match :func:`WidgetCallback`.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CloseToplevelWidget", (PyCFunction) _wrap_MiniQtHelper_CloseToplevelWidget, METH_O, (char *) "\n"
		"CloseToplevelWidget(widget)\n"
		"\n"
		"Closes a top-level widget as if the user had clicked to close.\n"
		"\n"
		"This function is undefined if used on a non top-level widget. It will invoke the closed widget\n"
		"callback.\n"
		"\n"
		":param QWidget widget: The top-level widget to close.\n"
		"\n"
		"" },
  { "SetWidgetName", (PyCFunction) _wrap_MiniQtHelper_SetWidgetName, METH_VARARGS, (char *) "\n"
		"SetWidgetName(widget, name)\n"
		"\n"
		"Set the internal name of a widget. This is not displayed anywhere but can be used by\n"
		":meth:`FindChildByName` to locate a widget within a hierarchy.\n"
		"\n"
		".. note::\n"
		"  Names are optional and only for your use. Nothing prevents from you from setting duplicate names,\n"
		"  but this makes searches by name ambiguous.\n"
		"\n"
		":param QWidget widget: The widget to set an internal name for.\n"
		":param str name: The internal name to set for the widget.\n"
		"\n"
		"" },
  { "GetWidgetName", (PyCFunction) _wrap_MiniQtHelper_GetWidgetName, METH_O, (char *) "\n"
		"GetWidgetName(widget)\n"
		"\n"
		"Return the internal name of a widget, as set my :meth:`SetWidgetName`.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: The widget's internal name, which may be an empty string if no name has been set.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "GetWidgetType", (PyCFunction) _wrap_MiniQtHelper_GetWidgetType, METH_O, (char *) "\n"
		"GetWidgetType(widget)\n"
		"\n"
		"Return the type of the widget as a string. This type is the Qt type name so this\n"
		"should only be used for debugging as the name may change even if for the same type of widget.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: The widget's type name.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "FindChildByName", (PyCFunction) _wrap_MiniQtHelper_FindChildByName, METH_VARARGS, (char *) "\n"
		"FindChildByName(parent, name)\n"
		"\n"
		"Find a child widget of a parent by internal name.\n"
		"\n"
		":param QWidget parent: The widget to start the search from.\n"
		":param str name: The internal name to search for.\n"
		":return: The handle to the first widget with a matching name, or ``None`` if no widget is found.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "GetParent", (PyCFunction) _wrap_MiniQtHelper_GetParent, METH_O, (char *) "\n"
		"GetParent(widget)\n"
		"\n"
		"Return the parent of a widget in the widget hierarchy.\n"
		"\n"
		".. note::\n"
		"  The widget returned may not be a widget created through this helper interface if the specified\n"
		"  widget has been docked somewhere. Beware making changes to any widgets returned as you may modify\n"
		"  the RenderDoc UI itself.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: The handle to the parent widget with a matching name, or ``None`` if this widget is either\n"
		"  not yet parented or is a top-level window.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "GetNumChildren", (PyCFunction) _wrap_MiniQtHelper_GetNumChildren, METH_O, (char *) "\n"
		"GetNumChildren(widget)\n"
		"\n"
		"Return the number of children this widget has. This is generally only useful for\n"
		"layout type widgets.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: The number of child widgets this widget has.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "GetChild", (PyCFunction) _wrap_MiniQtHelper_GetChild, METH_VARARGS, (char *) "\n"
		"GetChild(parent, index)\n"
		"\n"
		"Return a child widget for a parent.\n"
		"\n"
		":param QWidget parent: The parent widget to look up.\n"
		":param int index: The child index to return.\n"
		":return: The specified child of the parent, or ``None`` if the index is out of bounds.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "DestroyWidget", (PyCFunction) _wrap_MiniQtHelper_DestroyWidget, METH_O, (char *) "\n"
		"DestroyWidget(widget)\n"
		"\n"
		"Destroy a widget. Widgets stay alive unless explicitly destroyed here, OR in one other\n"
		"case when they are in a widget hiearchy under a top-level window which the user closes, which can\n"
		"be detected with the callback parameter in :meth:`CreateToplevelWidget`.\n"
		"\n"
		"If the widget being destroyed is a top-level window, it will be closed. Otherwise if it is part of a\n"
		"widget hierarchy it will be removed from its parent automatically. You can remove a widget and then\n"
		"destroy it if you wish, but you must not destroy a widget then attempt to remove it from its parent,\n"
		"as after the call to this function the widget is no longer valid to use.\n"
		"\n"
		"All children under this widget will be destroyed recursively as well, which will be made invalid\n"
		"even if a handle to them exists.\n"
		"\n"
		":param QWidget widget: The widget to destroy.\n"
		"\n"
		"" },
  { "ShowWidgetAsDialog", (PyCFunction) _wrap_MiniQtHelper_ShowWidgetAsDialog, METH_O, (char *) "\n"
		"ShowWidgetAsDialog(widget)\n"
		"\n"
		"Show a top-level widget as a blocking modal dialog. This is most useful to prompt the\n"
		"user for some specific information.\n"
		"\n"
		"The dialog is only closed when the user closes the window explicitly or if you call\n"
		":meth:`CloseCurrentDialog` in a widget callback, e.g. upon a button press.\n"
		"\n"
		":param QWidget widget: The top-level widget to show as a dialog.\n"
		":return: Whether the dialog was closed successfully, via :meth:`CloseCurrentDialog`.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "CloseCurrentDialog", (PyCFunction) _wrap_MiniQtHelper_CloseCurrentDialog, METH_O, (char *) "\n"
		"CloseCurrentDialog(success)\n"
		"\n"
		"Close the active modal dialog. This does nothing if no dialog is being shown.\n"
		"\n"
		".. note::\n"
		"  Closing a dialog 'sucessfully' does nothing except modify the return value of\n"
		"  :meth:`CloseCurrentDialog`. It allows quick distinguishing between OK and Cancel actions without\n"
		"  having to carry that information separately in a global or other state.\n"
		"\n"
		":param bool success: ``True`` if the dialog was successful (the user clicked an OK/Accept type\n"
		"  button).\n"
		"\n"
		"" },
  { "CreateHorizontalContainer", (PyCFunction) _wrap_MiniQtHelper_CreateHorizontalContainer, METH_NOARGS, (char *) "\n"
		"CreateHorizontalContainer()\n"
		"\n"
		"Creates and returns a horizontal layout widget.\n"
		"\n"
		"The widget needs to be added to a parent to become part of a panel or window.\n"
		"\n"
		"Children added to this layout widget are listed horizontally. Widget sizing follows default logic,\n"
		"which typically has some widgets be only large enough for their content and others which are\n"
		"'greedy' evenly divide any remaining free space.\n"
		"\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateVerticalContainer", (PyCFunction) _wrap_MiniQtHelper_CreateVerticalContainer, METH_NOARGS, (char *) "\n"
		"CreateVerticalContainer()\n"
		"\n"
		"Creates and returns a vertical layout widget.\n"
		"\n"
		"The widget needs to be added to a parent to become part of a panel or window.\n"
		"\n"
		"Children added to this layout widget are listed vertically. Widget sizing follows default logic,\n"
		"which typically has some widgets be only large enough for their content and others which are\n"
		"'greedy' evenly divide any remaining free space.\n"
		"\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateGridContainer", (PyCFunction) _wrap_MiniQtHelper_CreateGridContainer, METH_NOARGS, (char *) "\n"
		"CreateGridContainer()\n"
		"\n"
		"Creates and returns a grid layout widget.\n"
		"\n"
		"The widget needs to be added to a parent to become part of a panel or window.\n"
		"\n"
		"Children added to this layout widget are arranged in a grid. Widget sizing follows default logic,\n"
		"which typically has some widgets be only large enough for their content and others which are\n"
		"'greedy' evenly divide any remaining free space. This will not violate the grid constraint though.\n"
		"\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateSpacer", (PyCFunction) _wrap_MiniQtHelper_CreateSpacer, METH_O, (char *) "\n"
		"CreateSpacer(horizontal)\n"
		"\n"
		"Creates and returns a spacer widget.\n"
		"\n"
		"This widget is completely empty but consumes empty space, meaning all other non-greedy widgets in\n"
		"the same container will be minimally sized. This can be useful for simple layouts.\n"
		"\n"
		":param bool horizontal: ``True`` if this spacer should consume horizontal space, ``False`` if this\n"
		"  spacer should consume vertical space. Typically this matches the direction of the layout it is\n"
		"  in.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "ClearContainedWidgets", (PyCFunction) _wrap_MiniQtHelper_ClearContainedWidgets, METH_O, (char *) "\n"
		"ClearContainedWidgets(parent)\n"
		"\n"
		"Removes all child widgets from a parent and makes them invisible.\n"
		"\n"
		"These widgets remain valid and can be re-added to another parent or the same parent.\n"
		"\n"
		":param QWidget parent: The parent widget to clear of  children.\n"
		"\n"
		"" },
  { "AddGridWidget", (PyCFunction) _wrap_MiniQtHelper_AddGridWidget, METH_VARARGS, (char *) "\n"
		"AddGridWidget(parent, row, column, child, rowSpan, columnSpan)\n"
		"\n"
		"Adds a child widget to a grid layout. If the parent is not a grid layout nothing will\n"
		"happen and the widget will not be added anywhere.\n"
		"\n"
		":param QWidget parent: The parent grid layout widget.\n"
		":param int row: The row at which to add the child widget.\n"
		":param int column: The column at which to add the child widget.\n"
		":param QWidget child: The child widget to add.\n"
		":param int rowSpan: How many rows should this child span over.\n"
		":param int columnSpan: How many columns should this child span over.\n"
		"\n"
		"" },
  { "AddWidget", (PyCFunction) _wrap_MiniQtHelper_AddWidget, METH_VARARGS, (char *) "\n"
		"AddWidget(parent, child)\n"
		"\n"
		"Adds a child widget to the end of an ordered layout (either horizontal or vertical).\n"
		"If the parent is not an ordered layout nothing will happen and the widget will not be added anywhere.\n"
		"\n"
		":param QWidget parent: The parent grid layout widget.\n"
		":param QWidget child: The child widget to add.\n"
		"\n"
		"" },
  { "InsertWidget", (PyCFunction) _wrap_MiniQtHelper_InsertWidget, METH_VARARGS, (char *) "\n"
		"InsertWidget(parent, index, child)\n"
		"\n"
		"Insert a child widget at the specified index in an ordered layout (either horizontal\n"
		"or vertical). If the parent is not an ordered layout nothing will happen and the widget will not be\n"
		"added anywhere.\n"
		"\n"
		":param QWidget parent: The parent grid layout widget.\n"
		":param int index: The index to insert the widget at. If this index is out of bounds it will be\n"
		"  clamped, so that negative indices will be equivalent to index 0 and all indices above the number\n"
		"  of children will append the widget\n"
		":param QWidget child: The child widget to add.\n"
		"\n"
		"" },
  { "SetWidgetText", (PyCFunction) _wrap_MiniQtHelper_SetWidgetText, METH_VARARGS, (char *) "\n"
		"SetWidgetText(widget, text)\n"
		"\n"
		"Set the 'text' of a widget. How this manifests depends on the type of the widget, for\n"
		"example a text-box or label will set the text directly. For a checkbox or radio button this will\n"
		"add text next to it.\n"
		"\n"
		":param QWidget widget: The widget to set text for.\n"
		":param str text: The text to set for the widget.\n"
		"\n"
		"" },
  { "GetWidgetText", (PyCFunction) _wrap_MiniQtHelper_GetWidgetText, METH_O, (char *) "\n"
		"GetWidgetText(widget)\n"
		"\n"
		"Return the current text of a widget. See :meth:`SetWidgetText`.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: The widget's current text, which may be an empty string if no valid text is available.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "SetWidgetFont", (PyCFunction) _wrap_MiniQtHelper_SetWidgetFont, METH_VARARGS, (char *) "\n"
		"SetWidgetFont(widget, font, fontSize, bold, italic)\n"
		"\n"
		"Change the font properties of a widget.\n"
		"\n"
		":param QWidget widget: The widget to change font of.\n"
		":param str font: The new font family to use, or an empty string to leave the font family the same.\n"
		":param int fontSize: The new font point size to use, or 0 to leave the size the same.\n"
		":param bool bold: ``True`` if the font should be bold.\n"
		":param bool italic: ``True`` if the font should be italic.\n"
		"\n"
		"" },
  { "SetWidgetEnabled", (PyCFunction) _wrap_MiniQtHelper_SetWidgetEnabled, METH_VARARGS, (char *) "\n"
		"SetWidgetEnabled(widget, enabled)\n"
		"\n"
		"Set whether the widget is enabled or not. This generally only affects interactive\n"
		"widgets and not fixed widgets, interactive widgets become read-only while still displaying the same\n"
		"data.\n"
		"\n"
		".. note::\n"
		"  Disabled widgets can still be modified programmatically, they are only disabled for the user.\n"
		"\n"
		":param QWidget widget: The widget to enable or disable.\n"
		":param bool enabled: ``True`` if the widget should be enabled.\n"
		"\n"
		"" },
  { "IsWidgetEnabled", (PyCFunction) _wrap_MiniQtHelper_IsWidgetEnabled, METH_O, (char *) "\n"
		"IsWidgetEnabled(widget)\n"
		"\n"
		"Return the current enabled-state of a widget. See :meth:`SetWidgetEnabled`.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: ``True`` if the widget is currently enabled.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "SetWidgetVisible", (PyCFunction) _wrap_MiniQtHelper_SetWidgetVisible, METH_VARARGS, (char *) "\n"
		"SetWidgetVisible(widget, visible)\n"
		"\n"
		"Set whether the widget is visible or not. An invisible widget maintains its position\n"
		"in the hierarchy but is not visible and cannot be interacted with in any way.\n"
		"\n"
		":param QWidget widget: The widget to show or hide.\n"
		":param bool visible: ``True`` if the widget should be made visible (shown).\n"
		"\n"
		"" },
  { "IsWidgetVisible", (PyCFunction) _wrap_MiniQtHelper_IsWidgetVisible, METH_O, (char *) "\n"
		"IsWidgetVisible(widget)\n"
		"\n"
		"Return the current visibility of a widget. See :meth:`SetWidgetVisible`.\n"
		"\n"
		"This query is recursive - a widget could be individually visible, but if it is under a parent which\n"
		"is invisible then this widget will be returned as invisible.\n"
		"\n"
		":param QWidget widget: The widget to query.\n"
		":return: ``True`` if the widget is currently visible.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "CreateGroupBox", (PyCFunction) _wrap_MiniQtHelper_CreateGroupBox, METH_O, (char *) "\n"
		"CreateGroupBox(collapsible)\n"
		"\n"
		"Create a groupbox widget which can optionally allow collapsing.\n"
		"\n"
		"This widget can have children added, but it is recommended to immediately add only one child which\n"
		"is a layout type widget, to allow customising how children are added. By default the children are\n"
		"added in a vertical layout.\n"
		"\n"
		"The widget needs to be added to a parent to become part of a panel or window.\n"
		"\n"
		":param bool collapsible: ``True`` if the groupbox should have a toggle in its header to allow\n"
		"  collapsing its contents down vertically.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateButton", (PyCFunction) _wrap_MiniQtHelper_CreateButton, METH_O, (char *) "\n"
		"CreateButton(pressed)\n"
		"\n"
		"Create a normal button widget.\n"
		"\n"
		":param WidgetCallback pressed: Callback to be called when the button is pressed.\n"
		"  Callback function signature must match :func:`WidgetCallback`.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateLabel", (PyCFunction) _wrap_MiniQtHelper_CreateLabel, METH_NOARGS, (char *) "\n"
		"CreateLabel()\n"
		"\n"
		"Create a read-only label widget.\n"
		"\n"
		".. note::\n"
		"  This widget will be blank by default, you can set the text with :meth:`SetWidgetText`.\n"
		"\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetLabelImage", (PyCFunction) _wrap_MiniQtHelper_SetLabelImage, METH_VARARGS, (char *) "\n"
		"SetLabelImage(widget, data, width, height, alpha)\n"
		"\n"
		"Set an image for a label widget. If the widget isn't a label, this call has no effect.\n"
		"\n"
		"The label will be resized to a fixed size to display the image at 100% scale. Any text in the label\n"
		"will not be displayed, but passing an empty image will revert the label back to being text-based.\n"
		"\n"
		"The data must be in RGB(A) format with the first byte of each texel being R.\n"
		"\n"
		":param QWidget widget: The widget to set the picture for.\n"
		":param bytes data: The image data itself, tightly packed.\n"
		":param int width: The width of the image in pixels.\n"
		":param int height: The height of the image in pixels.\n"
		":param bool alpha: ``True`` if the image data contains an alpha channel.\n"
		"\n"
		"" },
  { "CreateOutputRenderingWidget", (PyCFunction) _wrap_MiniQtHelper_CreateOutputRenderingWidget, METH_NOARGS, (char *) "\n"
		"CreateOutputRenderingWidget()\n"
		"\n"
		"Create a widget suitable for rendering to with a :class:`renderdoc.ReplayOutput`. This\n"
		"widget takes care of painting on demand and recreating the internal display widget when necessary,\n"
		"however this means you must use :meth:`GetWidgetWindowingData` to retrieve the windowing data for\n"
		"creating the output as well as call :meth:`SetWidgetReplayOutput` to notify the widget of the\n"
		"current output.\n"
		"\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "GetWidgetWindowingData", (PyCFunction) _wrap_MiniQtHelper_GetWidgetWindowingData, METH_O, (char *) "\n"
		"GetWidgetWindowingData(widget)\n"
		"\n"
		"Return the opaque pointer of windowing data suitable for passing to\n"
		":meth:`~renderdoc.ReplayController.CreateOutput` or other functions that expect windowing data.\n"
		"\n"
		"If the widget is not a output rendering widget created with :meth:`CreateOutputRenderingWidget` this\n"
		"function will fail and return an invalid set of windowing data.\n"
		"\n"
		"It's important to note that the windowing data is not valid forever, so this function should be\n"
		"called as close to where you call :meth:`~renderdoc.ReplayController.CreateOutput` as possible.\n"
		"Also don't fetch windowing data unless you are going to create an output, because this function will\n"
		"cause the widget to go into an undefined state unless an output is created to render onto it.\n"
		"\n"
		".. note::\n"
		"  This function must be called on the main UI thread.\n"
		"\n"
		":param QWidget widget: The widget to create windowing data for.\n"
		":return: The windowing data.\n"
		":rtype: renderdoc.WindowingData\n"
		"\n"
		"" },
  { "SetWidgetReplayOutput", (PyCFunction) _wrap_MiniQtHelper_SetWidgetReplayOutput, METH_VARARGS, (char *) "\n"
		"SetWidgetReplayOutput(widget, output)\n"
		"\n"
		"Set the current output for a widget. This only affects output rendering widgets. If\n"
		"another type of widget is passed nothing will happen.\n"
		"\n"
		"Passing ``None`` as the output will reset the widget and make it display the default background\n"
		"until another output is set.\n"
		"\n"
		"When a capture is closed and all outputs are destroyed, the widget will automatically unset the\n"
		"output so there is no need to do that manually.\n"
		"\n"
		":param QWidget widget: The widget to set the output for.\n"
		":param renderdoc.ReplayOutput output: The new output to set, or ``None`` to unset any previous\n"
		"  output.\n"
		"\n"
		"" },
  { "SetWidgetBackgroundColor", (PyCFunction) _wrap_MiniQtHelper_SetWidgetBackgroundColor, METH_VARARGS, (char *) "\n"
		"SetWidgetBackgroundColor(widget, red, green, blue)\n"
		"\n"
		"Set the default backkground color for a rendering widget. This background color is\n"
		"used when no output is currently configured, e.g. when a capture is closed.\n"
		"\n"
		"For all other widget types this has no effect.\n"
		"\n"
		"To disable the background color pass negative values for the components, this will cause a default\n"
		"checkerboard to be rendered instead. This is the default behaviour when a widget is created.\n"
		"\n"
		":param QWidget widget: The widget to set the background color of.\n"
		":param float red: The red component of the color, in the range ``0.0 - 1.0``.\n"
		":param float green: The green component of the color, in the range ``0.0 - 1.0``.\n"
		":param float blue: The blue component of the color, in the range ``0.0 - 1.0``.\n"
		"\n"
		"" },
  { "CreateCheckbox", (PyCFunction) _wrap_MiniQtHelper_CreateCheckbox, METH_O, (char *) "\n"
		"CreateCheckbox(changed)\n"
		"\n"
		"Create a checkbox widget which can be toggled between unchecked and checked. When\n"
		"created the checkbox is unchecked.\n"
		"\n"
		":param WidgetCallback changed: Callback to be called when the widget is toggled.\n"
		"  Callback function signature must match :func:`WidgetCallback`.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateRadiobox", (PyCFunction) _wrap_MiniQtHelper_CreateRadiobox, METH_O, (char *) "\n"
		"CreateRadiobox(changed)\n"
		"\n"
		"Create a radio box widget which can be toggled between unchecked and checked but with\n"
		"at most one radio box in any group of sibling radio boxes being checked.\n"
		"\n"
		"Upon creation the radio box is unchecked, even in a group of other radio boxes that are unchecked.\n"
		"If you want a default radio box to be checked, you should use :meth:`SetWidgetChecked`.\n"
		"\n"
		":param WidgetCallback changed: Callback to be called when the widget is toggled.\n"
		"  Callback function signature must match :func:`WidgetCallback`.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetWidgetChecked", (PyCFunction) _wrap_MiniQtHelper_SetWidgetChecked, METH_VARARGS, (char *) "\n"
		"SetWidgetChecked(checkableWidget, checked)\n"
		"\n"
		"Set whether the widget is checked or not. This only affects checkboxes and radio\n"
		"boxes and group box. If another type of widget is passed nothing will happen.\n"
		"\n"
		":param QWidget checkableWidget: The widget to check or uncheck.\n"
		":param bool checked: ``True`` if the widget should be checked.\n"
		"\n"
		"" },
  { "IsWidgetChecked", (PyCFunction) _wrap_MiniQtHelper_IsWidgetChecked, METH_O, (char *) "\n"
		"IsWidgetChecked(checkableWidget)\n"
		"\n"
		"Return the current checked-state of a widget. See :meth:`SetWidgetChecked`. If another\n"
		"type of widget is passed other than a checkbox or radio box or group box ``False`` will be returned.\n"
		"\n"
		":param QWidget checkableWidget: The widget to query.\n"
		":return: ``True`` if the widget is currently checked.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "CreateSpinbox", (PyCFunction) _wrap_MiniQtHelper_CreateSpinbox, METH_VARARGS, (char *) "\n"
		"CreateSpinbox(decimalPlaces, step)\n"
		"\n"
		"Create a spinbox widget with a numerical value and up/down buttons to change it.\n"
		"\n"
		"The number of decimal places can be set to 0 for an integer spinbox, and in that case the step\n"
		"should be set to 1.0.\n"
		"\n"
		"By default the spinbox has minimum and maximum values of 0.0 and 100.0, these can be changed with\n"
		":meth:`SetSpinboxBounds`.\n"
		"\n"
		":param int decimalPlaces: The number of decimal places to display when showing the number.\n"
		":param float step: The step value to apply in each direction when clicking up or down.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetSpinboxBounds", (PyCFunction) _wrap_MiniQtHelper_SetSpinboxBounds, METH_VARARGS, (char *) "\n"
		"SetSpinboxBounds(spinbox, minVal, maxVal)\n"
		"\n"
		"Set the minimum and maximum values allowed in the spinbox. If another type of widget\n"
		"is passed nothing will happen.\n"
		"\n"
		":param QWidget spinbox: The spinbox.\n"
		":param float minVal: The minimum value allowed for the spinbox to reach. Lower values entered will\n"
		"  be clamped to this.\n"
		":param float maxVal: The maximum value allowed for the spinbox to reach. Higher values entered will\n"
		"  be clamped to this.\n"
		"\n"
		"" },
  { "SetSpinboxValue", (PyCFunction) _wrap_MiniQtHelper_SetSpinboxValue, METH_VARARGS, (char *) "\n"
		"SetSpinboxValue(spinbox, value)\n"
		"\n"
		"Set the value contained in a spinbox. If another type of widget is passed nothing will\n"
		"happen.\n"
		"\n"
		":param QWidget spinbox: The spinbox.\n"
		":param float value: The value for the spinbox, which will be clamped by the current bounds.\n"
		"\n"
		"" },
  { "GetSpinboxValue", (PyCFunction) _wrap_MiniQtHelper_GetSpinboxValue, METH_O, (char *) "\n"
		"GetSpinboxValue(spinbox)\n"
		"\n"
		"Return the current value of a spinbox widget. If another type of widget is passed\n"
		"``0.0`` will be returned.\n"
		"\n"
		":param QWidget spinbox: The widget to query.\n"
		":return: The current  value of the spinbox.\n"
		":rtype: float\n"
		"\n"
		"" },
  { "CreateTextBox", (PyCFunction) _wrap_MiniQtHelper_CreateTextBox, METH_VARARGS, (char *) "\n"
		"CreateTextBox(singleLine, changed)\n"
		"\n"
		"Create a text box widget for the user to enter text into.\n"
		"\n"
		":param bool singleLine: ``True`` if the widget should be a single-line entry, otherwise it is a\n"
		"  multi-line text box.\n"
		":param WidgetCallback changed: Callback to be called when the text in the textbox is changed.\n"
		"  Callback function signature must match :func:`WidgetCallback`.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "CreateComboBox", (PyCFunction) _wrap_MiniQtHelper_CreateComboBox, METH_VARARGS, (char *) "\n"
		"CreateComboBox(editable, changed)\n"
		"\n"
		"Create a drop-down combo box widget.\n"
		"\n"
		"When created there are no pre-defined entries in the drop-down section. This can be changed with\n"
		":meth:`SetComboOptions`.\n"
		"\n"
		":param bool editable: ``True`` if the widget should allow the user to enter any text they wish as\n"
		"  well as being able to select a pre-defined entry.\n"
		":param WidgetCallback changed: Callback to be called when the text in the combobox is changed. This\n"
		"  will be called both when a new option is selected or when the user edits the text.\n"
		"  Callback function signature must match :func:`WidgetCallback`.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"" },
  { "SetComboOptions", (PyCFunction) _wrap_MiniQtHelper_SetComboOptions, METH_VARARGS, (char *) "\n"
		"SetComboOptions(combo, options)\n"
		"\n"
		"Set the pre-defined options in a drop-down combo box. If another type of widget is\n"
		"passed nothing will happen.\n"
		"\n"
		":param QWidget combo: The combo box.\n"
		":param List[str] options: The new options for the combo box.\n"
		"\n"
		"" },
  { "GetComboCount", (PyCFunction) _wrap_MiniQtHelper_GetComboCount, METH_O, (char *) "\n"
		"GetComboCount(combo)\n"
		"\n"
		"Get the number of options in a drop-down combo box. If another type of widget is\n"
		"passed ``0`` will be returned.\n"
		"\n"
		":param QWidget combo: The combo box.\n"
		":return: The current number of options.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "SelectComboOption", (PyCFunction) _wrap_MiniQtHelper_SelectComboOption, METH_VARARGS, (char *) "\n"
		"SelectComboOption(combo, option)\n"
		"\n"
		"Select the current option in a drop-down combo box. If another type of widget or\n"
		"an unknown option is passed, nothing will happen.\n"
		"\n"
		":param QWidget combo: The combo box.\n"
		":param str option: The option to select.\n"
		"\n"
		"" },
  { "CreateProgressBar", (PyCFunction) _wrap_MiniQtHelper_CreateProgressBar, METH_O, (char *) "\n"
		"CreateProgressBar(horizontal)\n"
		"\n"
		"Create a progress bar widget.\n"
		"\n"
		"By default the progress bar has minimum and maximum values of 0 and 100. These can be changed with\n"
		":meth:`SetProgressBarRange`.\n"
		"\n"
		":param bool horizontal: the progress bar orientation, true for horizontal otherwise vertical.\n"
		":return: The handle to the newly created widget.\n"
		":rtype: QWidget\n"
		"\n"
		"\n"
		"" },
  { "ResetProgressBar", (PyCFunction) _wrap_MiniQtHelper_ResetProgressBar, METH_O, (char *) "\n"
		"ResetProgressBar(pbar)\n"
		"\n"
		"Reset a progress bar widget.\n"
		"\n"
		"Rewinds the progress bar's indicator and hides the indicator's label (theme dependent). If you want\n"
		"to keep the label visible, call :meth:`SetProgressBarValue(0)` instead. The minimum and maximum values\n"
		"are not changed.\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		"\n"
		"" },
  { "SetProgressBarValue", (PyCFunction) _wrap_MiniQtHelper_SetProgressBarValue, METH_VARARGS, (char *) "\n"
		"SetProgressBarValue(pbar, value)\n"
		"\n"
		"Set the progress bar's current value.\n"
		"\n"
		"Attempting to change the current value outside the minimum and maximum range does not affect\n"
		"the current value.\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		":param int value: the new current value.\n"
		"\n"
		"" },
  { "UpdateProgressBarValue", (PyCFunction) _wrap_MiniQtHelper_UpdateProgressBarValue, METH_VARARGS, (char *) "\n"
		"UpdateProgressBarValue(pbar, delta)\n"
		"\n"
		"Set the progress bar's current value relative to the existing value.\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		":param int delta: the relative value to update the current value.\n"
		"\n"
		"" },
  { "GetProgressBarValue", (PyCFunction) _wrap_MiniQtHelper_GetProgressBarValue, METH_O, (char *) "\n"
		"GetProgressBarValue(pbar)\n"
		"\n"
		"Get the progress bar's current value.\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		":return: The current value of the progress bar.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "SetProgressBarRange", (PyCFunction) _wrap_MiniQtHelper_SetProgressBarRange, METH_VARARGS, (char *) "\n"
		"SetProgressBarRange(pbar, minimum, maximum)\n"
		"\n"
		"Set a progress bar's minimum and maximum values.\n"
		"\n"
		"If maximum is smaller than minimum, minimum is set as the maximum, too. If the current value falls\n"
		"outside the new range, the progress bar is reset. Use range (0, 0) to set the progress bar to\n"
		"indeterminated state (the progress cannot be estimated or is not being calculated).\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		":param int minimum: the minimum value.\n"
		":param int maximum: the maximum value.\n"
		"\n"
		"" },
  { "GetProgressBarMinimum", (PyCFunction) _wrap_MiniQtHelper_GetProgressBarMinimum, METH_O, (char *) "\n"
		"GetProgressBarMinimum(pbar)\n"
		"\n"
		"Get the minimum value of the progress bar's range.\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		":return: The minimum value of the range.\n"
		":rtype: int\n"
		"\n"
		"" },
  { "GetProgressBarMaximum", (PyCFunction) _wrap_MiniQtHelper_GetProgressBarMaximum, METH_O, (char *) "\n"
		"GetProgressBarMaximum(pbar)\n"
		"\n"
		"Get the maximum value of the progress bar's range.\n"
		"\n"
		":param QWidget pbar: the progress bar.\n"
		":return: The maximum value of the range.\n"
		":rtype: int\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IMiniQtHelper_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.MiniQtHelper",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IMiniQtHelper_type.as_number,                 /* tp_as_number */
    &SwigPyBuiltin__IMiniQtHelper_type.as_sequence,               /* tp_as_sequence */
    &SwigPyBuiltin__IMiniQtHelper_type.as_mapping,                /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IMiniQtHelper_type.as_buffer,                 /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"Python can have direct access to Qt via PySide2, but this is not always available in\n"
		"all RenderDoc builds. To aid extensions to manipulate widgets in a simple but portable fashion this\n"
		"helper exposes a small subset of Qt via RenderDoc's python bindings.\n"
		"\n"
		"The intention is not to allow fully flexible building of Qt panels, but to allow access to some\n"
		"basic UI building tools for simple data input and display which can be used on any RenderDoc build.\n"
		"\n"
		"This manager is retrieved by calling :meth:`ExtensionManager.GetMiniQtHelper`.\n"
		"\n"
		".. note::\n"
		"  The widget handles returned are PySide2 widgets where that is available, so this can be used to\n"
		"  make a basic UI and optionally customise it further with PySide2 when possible.\n"
		"\n"
		".. function:: WidgetCallback(context, widget, text)\n"
		"\n"
		"  Not a member function - the signature for any ``WidgetCallback`` callbacks.\n"
		"\n"
		"  Callback for widgets can be registered at creation time, the text field is optional and may be\n"
		"  blank depending on the event, but the context and widget are always valid.\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param QWidget widget: The widget sending the callback.\n"
		"  :param str text: Additional data for the call, such as the current or selected text.\n"
		"\n"
		".. function:: InvokeCallback(context, widget, text)\n"
		"\n"
		"  Not a member function - the signature for any ``InvokeCallback`` callbacks.\n"
		"\n"
		"  Callback for invoking onto the UI thread from another thread (in particular the replay thread).\n"
		"  Takes no parameters as the callback is expected to store its own state.\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IMiniQtHelper_richcompare,       /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IMiniQtHelper_methods,     /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IMiniQtHelper_getset,      /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IMiniQtHelper_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IMiniQtHelper_type};

static SwigPyGetSet ExtensionManager___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__IExtensionManager_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"IExtensionManager.__dict__", (void *) &ExtensionManager___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__IExtensionManager_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__IExtensionManager_methods[] = {
  { "GetInstalledExtensions", (PyCFunction) _wrap_ExtensionManager_GetInstalledExtensions, METH_NOARGS, (char *) "\n"
		"GetInstalledExtensions()\n"
		"\n"
		"Retrieve a list of installed extensions.\n"
		"\n"
		":return: The list of installed extensions.\n"
		":rtype: List[ExtensionMetadata]\n"
		"\n"
		"" },
  { "IsExtensionLoaded", (PyCFunction) _wrap_ExtensionManager_IsExtensionLoaded, METH_O, (char *) "\n"
		"IsExtensionLoaded(name)\n"
		"\n"
		"Check if an installed extension is enabled.\n"
		"\n"
		":param str name: The qualified name of the extension, e.g. ``foo.bar``\n"
		":return: If the extension is enabled or not.\n"
		":rtype: bool\n"
		"\n"
		"" },
  { "LoadExtension", (PyCFunction) _wrap_ExtensionManager_LoadExtension, METH_O, (char *) "\n"
		"LoadExtension(name)\n"
		"\n"
		"Enable an extension by name. If the extension is already enabled, this will reload it.\n"
		"\n"
		":param str name: The qualified name of the extension, e.g. ``foo.bar``\n"
		":return: If the extension loaded successfully, an empty string, otherwise the errors encountered\n"
		"  while loading it.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "RegisterWindowMenu", (PyCFunction) _wrap_ExtensionManager_RegisterWindowMenu, METH_VARARGS, (char *) "\n"
		"RegisterWindowMenu(base, submenus, callback)\n"
		"\n"
		"Register a new menu item in the main window's menus for an extension.\n"
		"\n"
		".. note:\n"
		"  The intermediate submenu items will be created as needed, there's no need to register each item\n"
		"  in the hierarchy. Registering a menu item and then registering a child is undefined, and the item\n"
		"  with a child may not receive callbacks at the correct times.\n"
		"\n"
		":param WindowMenu base: The base menu to add the item to.\n"
		":param List[str] submenus: A list of strings containing the submenus to add before the item. The\n"
		"  last string will be the name of the menu item itself. Must contain at least one entry, or two\n"
		"  entries if ``base`` is :data:`WindowMenu.NewMenu`.\n"
		":param ExtensionCallback callback: The function to callback when the menu item is selected.\n"
		"  Callback function signature must match :func:`ExtensionCallback`.\n"
		"\n"
		"" },
  { "RegisterPanelMenu", (PyCFunction) _wrap_ExtensionManager_RegisterPanelMenu, METH_VARARGS, (char *) "\n"
		"RegisterPanelMenu(base, submenus, callback)\n"
		"\n"
		"Register a menu item in a panel for an extension.\n"
		"\n"
		".. note:\n"
		"  The intermediate submenu items will be created as needed, there's no need to register each item\n"
		"  in the hierarchy. Registering a menu item and then registering a child is undefined, and the item\n"
		"  with a child may not receive callbacks at the correct times.\n"
		"\n"
		":param PanelMenu base: The panel to add the item to.\n"
		":param List[str] submenus: A list of strings containing the submenus to add before the item. The\n"
		"  last string will be the name of the menu item itself. Must contain at least one entry.\n"
		":param ExtensionCallback callback: The function to callback when the menu item is selected.\n"
		"  Callback function signature must match :func:`ExtensionCallback`.\n"
		"\n"
		"" },
  { "RegisterContextMenu", (PyCFunction) _wrap_ExtensionManager_RegisterContextMenu, METH_VARARGS, (char *) "\n"
		"RegisterContextMenu(base, submenus, callback)\n"
		"\n"
		"Register a context menu item in a panel for an extension.\n"
		"\n"
		".. note:\n"
		"  The intermediate submenu items will be created as needed, there's no need to register each item\n"
		"  in the hierarchy. Registering a menu item and then registering a child is undefined, and the item\n"
		"  with a child may not receive callbacks at the correct times.\n"
		"\n"
		":param ContextMenu base: The panel to add the item to.\n"
		":param List[str] submenus: A list of strings containing the submenus to add before the item. The\n"
		"  last string will be the name of the menu item itself. Must contain at least one entry.\n"
		":param ExtensionCallback callback: The function to callback when the menu item is selected.\n"
		"  Callback function signature must match :func:`ExtensionCallback`.\n"
		"\n"
		"" },
  { "GetMiniQtHelper", (PyCFunction) _wrap_ExtensionManager_GetMiniQtHelper, METH_NOARGS, (char *) "\n"
		"GetMiniQtHelper()\n"
		"\n"
		"Returns a handle to the mini Qt helper. See :class:`MiniQtHelper`.\n"
		"\n"
		":return: The helper interface.\n"
		":rtype: MiniQtHelper\n"
		"\n"
		"" },
  { "MessageDialog", (PyCFunction) _wrap_ExtensionManager_MessageDialog, METH_VARARGS, (char *) "\n"
		"MessageDialog(text, title)\n"
		"MessageDialog(text)\n"
		"\n"
		"Display a simple informational message dialog.\n"
		"\n"
		":param str text: The text of the dialog itself, required.\n"
		":param str title: The dialog title, optional.\n"
		"\n"
		"" },
  { "ErrorDialog", (PyCFunction) _wrap_ExtensionManager_ErrorDialog, METH_VARARGS, (char *) "\n"
		"ErrorDialog(text, title)\n"
		"ErrorDialog(text)\n"
		"\n"
		"Display an error message dialog.\n"
		"\n"
		":param str text: The text of the dialog itself, required.\n"
		":param str title: The dialog title, optional.\n"
		"\n"
		"" },
  { "QuestionDialog", (PyCFunction) _wrap_ExtensionManager_QuestionDialog, METH_VARARGS, (char *) "\n"
		"QuestionDialog(text, options, title)\n"
		"QuestionDialog(text, options)\n"
		"\n"
		"Display an error message dialog.\n"
		"\n"
		":param str text: The text of the dialog itself, required.\n"
		":param List[DialogButton] options: The buttons to display on the dialog.\n"
		":param str title: The dialog title, optional.\n"
		":return: The button that was clicked on.\n"
		":rtype: DialogButton\n"
		"\n"
		"" },
  { "OpenFileName", (PyCFunction) _wrap_ExtensionManager_OpenFileName, METH_VARARGS, (char *) "\n"
		"OpenFileName(caption, dir, filter)\n"
		"OpenFileName(caption, dir)\n"
		"OpenFileName(caption)\n"
		"OpenFileName()\n"
		"\n"
		"Browse for a filename to open.\n"
		"\n"
		":param str caption: The dialog title, optional.\n"
		":param str dir: The starting directory for browsing, optional.\n"
		":param str filter: The filter to apply for filenames, optional.\n"
		":return: The filename selected, or an empty string if nothing was selected.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "OpenDirectoryName", (PyCFunction) _wrap_ExtensionManager_OpenDirectoryName, METH_VARARGS, (char *) "\n"
		"OpenDirectoryName(caption, dir)\n"
		"OpenDirectoryName(caption)\n"
		"OpenDirectoryName()\n"
		"\n"
		"Browse for a directory to open.\n"
		"\n"
		":param str caption: The dialog title, optional.\n"
		":param str dir: The starting directory for browsing, optional.\n"
		":return: The directory selected, or an empty string if nothing was selected.\n"
		":rtype: str\n"
		"\n"
		"" },
  { "SaveFileName", (PyCFunction) _wrap_ExtensionManager_SaveFileName, METH_VARARGS, (char *) "\n"
		"SaveFileName(caption, dir, filter)\n"
		"SaveFileName(caption, dir)\n"
		"SaveFileName(caption)\n"
		"SaveFileName()\n"
		"\n"
		"Browse for a filename to save to.\n"
		"\n"
		":param str caption: The dialog title, optional.\n"
		":param str dir: The starting directory for browsing, optional.\n"
		":param str filter: The filter to apply for filenames, optional.\n"
		":return: The filename selected, or an empty string if nothing was selected.\n"
		":rtype: str\n"
		"\n"
		"" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__IExtensionManager_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.ExtensionManager",            /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) SwigPyBuiltin_BadDealloc,    /* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) 0,                             /* tp_repr */
    &SwigPyBuiltin__IExtensionManager_type.as_number,             /* tp_as_number */
    &SwigPyBuiltin__IExtensionManager_type.as_sequence,           /* tp_as_sequence */
    &SwigPyBuiltin__IExtensionManager_type.as_mapping,            /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) 0,                             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__IExtensionManager_type.as_buffer,             /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "\n"
		"A manager for listing available and active extensions, as well as the interface for\n"
		"extensions to register hooks and additional functionality.\n"
		"\n"
		"This manager is retrieved by calling :meth:`CaptureContext.Extensions`.\n"
		"\n"
		".. function:: ExtensionCallback(context, data)\n"
		"\n"
		"  Not a member function - the signature for any ``ExtensionCallback`` callbacks.\n"
		"\n"
		"  Callback for extensions to register entry points with, used in many situations depending on how it\n"
		"  was registered.\n"
		"\n"
		"  :param CaptureContext context: The current capture context.\n"
		"  :param dict data: Additional data for the call, as a dictionary with string keys.\n"
		"    Context-dependent based on what generated the callback\n"
		"\n"
		"",/* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__IExtensionManager_richcompare,   /* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__IExtensionManager_methods, /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__IExtensionManager_getset,  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) 0,                           /* mp_subscript */
    (objobjargproc) 0,                        /* mp_ass_subscript */
  },
  {
    (lenfunc) 0,                              /* sq_length */
    (binaryfunc) 0,                           /* sq_concat */
    (ssizeargfunc) 0,                         /* sq_repeat */
    (ssizeargfunc) 0,                         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) 0,                      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) 0,                           /* sq_inplace_concat */
    (ssizeargfunc) 0,                         /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__IExtensionManager_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__IExtensionManager_type};

static SwigPyGetSet rdcarray_of_EventBookmark___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_EventBookmark_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(EventBookmark)>.__dict__", (void *) &rdcarray_of_EventBookmark___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_EventBookmark_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_EventBookmark___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_EventBookmark___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_EventBookmark___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_EventBookmark_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_EventBookmark___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_EventBookmark___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_EventBookmark___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_EventBookmark_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_EventBookmark_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_EventBookmark_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_EventBookmark_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_EventBookmark_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_EventBookmark_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_EventBookmark_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_EventBookmark_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_EventBookmark_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_EventBookmark_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_EventBookmark_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_EventBookmark_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_EventBookmark_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_EventBookmark_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_EventBookmark_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_EventBookmark_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_EventBookmark_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_EventBookmark",   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_EventBookmark_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_EventBookmark,/* tp_repr */
    &SwigPyBuiltin__rdcarrayT_EventBookmark_t_type.as_number,     /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_EventBookmark_t_type.as_sequence,   /* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_EventBookmark_t_type.as_mapping,    /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_EventBookmark,/* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_EventBookmark_t_type.as_buffer,     /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< EventBookmark >",            /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_EventBookmark_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_EventBookmark_t_methods,             /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_EventBookmark_t_getset,              /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_EventBookmark,          /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_EventBookmark,       /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_EventBookmark,                   /* sq_length */
    (binaryfunc) concat_rdcarray_of_EventBookmark,                /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_EventBookmark,              /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_EventBookmark,             /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_EventBookmark,          /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_EventBookmark,            /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_EventBookmark,          /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_EventBookmark_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_EventBookmark_t_type};

static SwigPyGetSet rdcarray_of_ShaderProcessingTool___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(ShaderProcessingTool)>.__dict__", (void *) &rdcarray_of_ShaderProcessingTool___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_ShaderProcessingTool___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_ShaderProcessingTool___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_ShaderProcessingTool___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_ShaderProcessingTool_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_ShaderProcessingTool",                /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_ShaderProcessingTool_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_ShaderProcessingTool,             /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type.as_number,/* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type.as_mapping,/* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_ShaderProcessingTool,             /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type.as_buffer,/* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< ShaderProcessingTool >",     /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_methods,      /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_getset,       /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_ShaderProcessingTool,   /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_ShaderProcessingTool,/* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_ShaderProcessingTool,            /* sq_length */
    (binaryfunc) concat_rdcarray_of_ShaderProcessingTool,         /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_ShaderProcessingTool,       /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_ShaderProcessingTool,      /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_ShaderProcessingTool,   /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_ShaderProcessingTool,     /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_ShaderProcessingTool,   /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type};

static SwigPyGetSet rdcarray_of_rdcstrpair___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_rdcstrpair_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(rdcstrpair)>.__dict__", (void *) &rdcarray_of_rdcstrpair___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_rdcstrpair_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_rdcstrpair___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_rdcstrpair___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_rdcstrpair___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_rdcstrpair_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_rdcstrpair___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_rdcstrpair___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_rdcstrpair___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_rdcstrpair_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_rdcstrpair",      /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_rdcstrpair_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_rdcstrpair,   /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type.as_number,        /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type.as_sequence,      /* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type.as_mapping,       /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_rdcstrpair,   /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type.as_buffer,        /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< rdcstrpair >",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_rdcstrpair_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_rdcstrpair_t_methods,                /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_rdcstrpair_t_getset,                 /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_rdcstrpair,             /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_rdcstrpair,          /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_rdcstrpair,  /* sq_length */
    (binaryfunc) concat_rdcarray_of_rdcstrpair,                   /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_rdcstrpair,                 /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_rdcstrpair,                /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_rdcstrpair,             /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_rdcstrpair,               /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_rdcstrpair,             /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_rdcstrpair_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type};

static SwigPyGetSet rdcarray_of_BugReport___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_BugReport_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(BugReport)>.__dict__", (void *) &rdcarray_of_BugReport___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_BugReport_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_BugReport___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_BugReport___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_BugReport___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_BugReport_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_BugReport___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_BugReport___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_BugReport___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_BugReport_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_BugReport_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_BugReport_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_BugReport_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_BugReport_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_BugReport_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_BugReport_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_BugReport_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_BugReport_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_BugReport_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_BugReport_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_BugReport_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_BugReport_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_BugReport_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_BugReport_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_BugReport_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_BugReport_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_BugReport",       /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_BugReport_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_BugReport,    /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_BugReport_t_type.as_number,         /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_BugReport_t_type.as_sequence,       /* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_BugReport_t_type.as_mapping,        /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_BugReport,    /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_BugReport_t_type.as_buffer,         /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< BugReport >",                /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_BugReport_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_BugReport_t_methods,                 /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_BugReport_t_getset,                  /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_BugReport,              /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_BugReport,           /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_BugReport,   /* sq_length */
    (binaryfunc) concat_rdcarray_of_BugReport,/* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_BugReport,                  /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_BugReport,                 /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_BugReport,              /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_BugReport,                /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_BugReport,              /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_BugReport_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_BugReport_t_type};

static SwigPyGetSet rdcarray_of_ExtensionMetadata___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(ExtensionMetadata)>.__dict__", (void *) &rdcarray_of_ExtensionMetadata___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_ExtensionMetadata___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_ExtensionMetadata___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_ExtensionMetadata___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_ExtensionMetadata_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_ExtensionMetadata",                   /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_ExtensionMetadata_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_ExtensionMetadata,                /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type.as_number, /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type.as_mapping,/* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_ExtensionMetadata,                /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type.as_buffer, /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< ExtensionMetadata >",        /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_methods,         /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_getset,          /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_ExtensionMetadata,      /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_ExtensionMetadata,   /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_ExtensionMetadata,               /* sq_length */
    (binaryfunc) concat_rdcarray_of_ExtensionMetadata,            /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_ExtensionMetadata,          /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_ExtensionMetadata,         /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_ExtensionMetadata,      /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_ExtensionMetadata,        /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_ExtensionMetadata,      /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type};

static SwigPyGetSet rdcarray_of_DialogButton___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_DialogButton_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(DialogButton)>.__dict__", (void *) &rdcarray_of_DialogButton___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_DialogButton_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_DialogButton___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_DialogButton___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_DialogButton___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_DialogButton_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_DialogButton___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_DialogButton___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_DialogButton___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_DialogButton_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_DialogButton_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_DialogButton_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_DialogButton_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_DialogButton_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_DialogButton_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_DialogButton_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_DialogButton_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_DialogButton_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_DialogButton_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_DialogButton_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_DialogButton_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_DialogButton_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_DialogButton_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_DialogButton_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_DialogButton_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_DialogButton_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_DialogButton",    /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_DialogButton_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_DialogButton, /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_DialogButton_t_type.as_number,      /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_DialogButton_t_type.as_sequence,    /* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_DialogButton_t_type.as_mapping,     /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_DialogButton, /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_DialogButton_t_type.as_buffer,      /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< DialogButton >",             /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_DialogButton_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_DialogButton_t_methods,              /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_DialogButton_t_getset,               /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_DialogButton,           /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_DialogButton,        /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_DialogButton,/* sq_length */
    (binaryfunc) concat_rdcarray_of_DialogButton,                 /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_DialogButton,               /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_DialogButton,              /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_DialogButton,           /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_DialogButton,             /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_DialogButton,           /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_DialogButton_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_DialogButton_t_type};

static SwigPyGetSet rdcarray_of_RemoteHost___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_RemoteHost_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(RemoteHost)>.__dict__", (void *) &rdcarray_of_RemoteHost___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_RemoteHost_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_RemoteHost___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_RemoteHost___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_RemoteHost___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_RemoteHost_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_RemoteHost___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_RemoteHost___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_RemoteHost___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_RemoteHost_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_RemoteHost_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_RemoteHost_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_RemoteHost_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_RemoteHost_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_RemoteHost_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_RemoteHost_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_RemoteHost_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_RemoteHost_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_RemoteHost_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_RemoteHost_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_RemoteHost_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_RemoteHost_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_RemoteHost_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_RemoteHost_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_RemoteHost_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_RemoteHost_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_RemoteHost",      /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_RemoteHost_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_RemoteHost,   /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_RemoteHost_t_type.as_number,        /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_RemoteHost_t_type.as_sequence,      /* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_RemoteHost_t_type.as_mapping,       /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_RemoteHost,   /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_RemoteHost_t_type.as_buffer,        /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< RemoteHost >",               /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_RemoteHost_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_RemoteHost_t_methods,                /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_RemoteHost_t_getset,                 /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_RemoteHost,             /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_RemoteHost,          /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_RemoteHost,  /* sq_length */
    (binaryfunc) concat_rdcarray_of_RemoteHost,                   /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_RemoteHost,                 /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_RemoteHost,                /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_RemoteHost,             /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_RemoteHost,               /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_RemoteHost,             /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_RemoteHost_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_RemoteHost_t_type};

static SwigPyGetSet rdcarray_of_ptr_ICaptureViewer___dict___getset = { SwigPyObject_get___dict__, 0 };
SWIGINTERN PyGetSetDef SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_getset[] = {
    { (char *) "__dict__", (getter) SwigPyBuiltin_FunpackGetterClosure, (setter) 0, (char *)"rdcarray<(p.ICaptureViewer)>.__dict__", (void *) &rdcarray_of_ptr_ICaptureViewer___dict___getset }
,
    {NULL, NULL, NULL, NULL, NULL} /* Sentinel */
};

SWIGINTERN PyObject *
SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_richcompare(PyObject *self, PyObject *other, int op) {
  PyObject *result = NULL;
  switch (op) {
    case Py_EQ : result = _wrap_rdcarray_of_ptr_ICaptureViewer___eq__(self, other); break;
    case Py_NE : result = _wrap_rdcarray_of_ptr_ICaptureViewer___ne__(self, other); break;
    case Py_LT : result = _wrap_rdcarray_of_ptr_ICaptureViewer___lt__(self, other); break;
    default : break;
  }
  if (!result) {
    if (SwigPyObject_Check(self) && SwigPyObject_Check(other)) {
      result = SwigPyObject_richcompare((SwigPyObject *)self, (SwigPyObject *)other, op);
    } else {
      result = Py_NotImplemented;
      Py_INCREF(result);
    }
  }
  return result;
}

SWIGINTERN PyMethodDef SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_methods[] = {
  { "__eq__", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer___eq__, METH_O, (char *) "__eq__(o)" },
  { "__ne__", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer___ne__, METH_O, (char *) "__ne__(o)" },
  { "__lt__", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer___lt__, METH_O, (char *) "__lt__(o)" },
  { "resize_for_index", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_resize_for_index, METH_O, (char *) "resize_for_index(s)" },
  { "fill", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_fill, METH_VARARGS, (char *) "fill(count, el)" },
  { "pop_back", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_pop_back, METH_NOARGS, (char *) "pop_back()" },
  { "removeIf", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_removeIf, METH_O, (char *) "removeIf(predicate)" },
  { "removeOneIf", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_removeOneIf, METH_O, (char *) "removeOneIf(predicate)" },
  { "append", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_append, METH_O, (char *) "append(value)" },
  { "clear", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_clear, METH_NOARGS, (char *) "clear()" },
  { "insert", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_insert, METH_VARARGS, (char *) "insert(index, value)" },
  { "pop", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_pop, METH_VARARGS|METH_KEYWORDS, (char *) "pop(index=None)" },
  { "sort", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_sort, METH_VARARGS|METH_KEYWORDS, (char *) "sort(key=None, reverse=False)" },
  { "copy", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_copy, METH_NOARGS, (char *) "copy()" },
  { "reverse", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_reverse, METH_NOARGS, (char *) "reverse()" },
  { "index", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_index, METH_VARARGS|METH_KEYWORDS, (char *) "index(item, start=None, end=None)" },
  { "count", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_count, METH_O, (char *) "count(item)" },
  { "extend", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_extend, METH_O, (char *) "extend(items)" },
  { "remove", (PyCFunction) _wrap_rdcarray_of_ptr_ICaptureViewer_remove, METH_O, (char *) "remove(item)" },
  { NULL, NULL, 0, NULL } /* Sentinel */
};

static PyHeapTypeObject SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type = {
  {
#if PY_VERSION_HEX >= 0x03000000
    PyVarObject_HEAD_INIT(NULL, 0)
#else
    PyObject_HEAD_INIT(NULL)
    0,                                        /* ob_size */
#endif
    "qrenderdoc.rdcarray_of_ptr_ICaptureViewer",                  /* tp_name */
    sizeof(SwigPyObject),                     /* tp_basicsize */
    0,                                        /* tp_itemsize */
    (destructor) (destructor) _wrap_delete_rdcarray_of_ptr_ICaptureViewer_destructor_closure,/* tp_dealloc */
    (printfunc) 0,                            /* tp_print */
    (getattrfunc) 0,                          /* tp_getattr */
    (setattrfunc) 0,                          /* tp_setattr */
#if PY_VERSION_HEX >= 0x03000000
    0,                                        /* tp_compare */
#else
    (cmpfunc) 0,                              /* tp_compare */
#endif
    (reprfunc) repr_rdcarray_of_ptr_ICaptureViewer,               /* tp_repr */
    &SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type.as_number,  /* tp_as_number */
    &SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type.as_sequence,/* tp_as_sequence */
    &SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type.as_mapping, /* tp_as_mapping */
    (hashfunc) SwigPyObject_hash,             /* tp_hash */
    (ternaryfunc) 0,                          /* tp_call */
    (reprfunc) repr_rdcarray_of_ptr_ICaptureViewer,               /* tp_str */
    (getattrofunc) 0,                         /* tp_getattro */
    (setattrofunc) 0,                         /* tp_setattro */
    &SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type.as_buffer,  /* tp_as_buffer */
#if PY_VERSION_HEX >= 0x03000000
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE,   /* tp_flags */
#else
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_CHECKTYPES, /* tp_flags */
#endif
    "::rdcarray< ICaptureViewer * >",         /* tp_doc */
    (traverseproc) 0,                         /* tp_traverse */
    (inquiry) 0,                              /* tp_clear */
    (richcmpfunc) SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_richcompare,/* tp_richcompare */
    0,                                        /* tp_weaklistoffset */
    (getiterfunc) 0,                          /* tp_iter */
    (iternextfunc) 0,                         /* tp_iternext */
    SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_methods,          /* tp_methods */
    0,                                        /* tp_members */
    SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_getset,           /* tp_getset */
    0,                                        /* tp_base */
    0,                                        /* tp_dict */
    (descrgetfunc) 0,                         /* tp_descr_get */
    (descrsetfunc) 0,                         /* tp_descr_set */
    (Py_ssize_t) offsetof(SwigPyObject, dict),/* tp_dictoffset */
    (initproc) SwigPyBuiltin_BadInit,         /* tp_init */
    (allocfunc) 0,                            /* tp_alloc */
    (newfunc) 0,                              /* tp_new */
    (freefunc) 0,                             /* tp_free */
    (inquiry) 0,                              /* tp_is_gc */
    (PyObject *) 0,                           /* tp_bases */
    (PyObject *) 0,                           /* tp_mro */
    (PyObject *) 0,                           /* tp_cache */
    (PyObject *) 0,                           /* tp_subclasses */
    (PyObject *) 0,                           /* tp_weaklist */
    (destructor) 0,                           /* tp_del */
#if PY_VERSION_HEX >= 0x02060000
    (int) 0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
    (destructor) 0,                           /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
    (Py_ssize_t) 0,                           /* tp_allocs */
    (Py_ssize_t) 0,                           /* tp_frees */
    (Py_ssize_t) 0,                           /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
    0,                                        /* tp_prev */
#endif
    0,                                        /* tp_next */
#endif
  },
#if PY_VERSION_HEX >= 0x03050000
  {
    (unaryfunc) 0,                            /* am_await */
    (unaryfunc) 0,                            /* am_aiter */
    (unaryfunc) 0,                            /* am_anext */
  },
#endif
  {
    (binaryfunc) 0,                           /* nb_add */
    (binaryfunc) 0,                           /* nb_subtract */
    (binaryfunc) 0,                           /* nb_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_divide */
#endif
    (binaryfunc) 0,                           /* nb_remainder */
    (binaryfunc) 0,                           /* nb_divmod */
    (ternaryfunc) 0,                          /* nb_power */
    (unaryfunc) 0,                            /* nb_negative */
    (unaryfunc) 0,                            /* nb_positive */
    (unaryfunc) 0,                            /* nb_absolute */
    (inquiry) 0,                              /* nb_nonzero */
    (unaryfunc) 0,                            /* nb_invert */
    (binaryfunc) 0,                           /* nb_lshift */
    (binaryfunc) 0,                           /* nb_rshift */
    (binaryfunc) 0,                           /* nb_and */
    (binaryfunc) 0,                           /* nb_xor */
    (binaryfunc) 0,                           /* nb_or */
#if PY_VERSION_HEX < 0x03000000
    (coercion) 0,                             /* nb_coerce */
#endif
    (unaryfunc) 0,                            /* nb_int */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* nb_reserved */
#else
    (unaryfunc) 0,                            /* nb_long */
#endif
    (unaryfunc) 0,                            /* nb_float */
#if PY_VERSION_HEX < 0x03000000
    (unaryfunc) 0,                            /* nb_oct */
    (unaryfunc) 0,                            /* nb_hex */
#endif
    (binaryfunc) 0,                           /* nb_inplace_add */
    (binaryfunc) 0,                           /* nb_inplace_subtract */
    (binaryfunc) 0,                           /* nb_inplace_multiply */
#if PY_VERSION_HEX < 0x03000000
    (binaryfunc) 0,                           /* nb_inplace_divide */
#endif
    (binaryfunc) 0,                           /* nb_inplace_remainder */
    (ternaryfunc) 0,                          /* nb_inplace_power */
    (binaryfunc) 0,                           /* nb_inplace_lshift */
    (binaryfunc) 0,                           /* nb_inplace_rshift */
    (binaryfunc) 0,                           /* nb_inplace_and */
    (binaryfunc) 0,                           /* nb_inplace_xor */
    (binaryfunc) 0,                           /* nb_inplace_or */
    (binaryfunc) 0,                           /* nb_floor_divide */
    (binaryfunc) 0,                           /* nb_true_divide */
    (binaryfunc) 0,                           /* nb_inplace_floor_divide */
    (binaryfunc) 0,                           /* nb_inplace_true_divide */
#if PY_VERSION_HEX >= 0x02050000
    (unaryfunc) 0,                            /* nb_index */
#endif
#if PY_VERSION_HEX >= 0x03050000
    (binaryfunc) 0,                           /* nb_matrix_multiply */
    (binaryfunc) 0,                           /* nb_inplace_matrix_multiply */
#endif
  },
  {
    (lenfunc) 0,                              /* mp_length */
    (binaryfunc) getsubscript_rdcarray_of_ptr_ICaptureViewer,     /* mp_subscript */
    (objobjargproc) setsubscript_rdcarray_of_ptr_ICaptureViewer,  /* mp_ass_subscript */
  },
  {
    (lenfunc) length_rdcarray_of_ptr_ICaptureViewer,              /* sq_length */
    (binaryfunc) concat_rdcarray_of_ptr_ICaptureViewer,           /* sq_concat */
    (ssizeargfunc) repeat_rdcarray_of_ptr_ICaptureViewer,         /* sq_repeat */
    (ssizeargfunc) getitem_rdcarray_of_ptr_ICaptureViewer,        /* sq_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_slice */
#else
    (ssizessizeargfunc) 0,                    /* sq_slice */
#endif
    (ssizeobjargproc) setitem_rdcarray_of_ptr_ICaptureViewer,     /* sq_ass_item */
#if PY_VERSION_HEX >= 0x03000000
    (void *) 0,                               /* was_sq_ass_slice */
#else
    (ssizessizeobjargproc) 0,                 /* sq_ass_slice */
#endif
    (objobjproc) 0,                           /* sq_contains */
    (binaryfunc) selfconcat_rdcarray_of_ptr_ICaptureViewer,       /* sq_inplace_concat */
    (ssizeargfunc) selfrepeat_rdcarray_of_ptr_ICaptureViewer,     /* sq_inplace_repeat */
  },
  {
#if PY_VERSION_HEX < 0x03000000
    (readbufferproc) 0,                       /* bf_getreadbuffer */
    (writebufferproc) 0,                      /* bf_getwritebuffer */
    (segcountproc) 0,                         /* bf_getsegcount */
    (charbufferproc) 0,                       /* bf_getcharbuffer */
#endif
#if PY_VERSION_HEX >= 0x02060000
    (getbufferproc) 0,                        /* bf_getbuffer */
    (releasebufferproc) 0,                    /* bf_releasebuffer */
#endif
  },
    (PyObject *) 0,                           /* ht_name */
    (PyObject *) 0,                           /* ht_slots */
#if PY_VERSION_HEX >= 0x03030000
    (PyObject *) 0,                           /* ht_qualname */
    0,                                        /* ht_cached_keys */
#endif
};

SWIGINTERN SwigPyClientData SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_clientdata = {0, 0, 0, 0, 0, 0, (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_SDChunkTo_p_SDObject(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((SDObject *)  ((SDChunk *) x));
}
static void *_p_ICaptureFileTo_p_ICaptureAccess(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ICaptureAccess *)  ((ICaptureFile *) x));
}
static void *_p_IRemoteServerTo_p_ICaptureAccess(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((ICaptureAccess *)  ((IRemoteServer *) x));
}
static swig_type_info _swigt__p_APIEvent = {"_p_APIEvent", "APIEvent *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_APIProperties = {"_p_APIProperties", "APIProperties *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ActionDescription = {"_p_ActionDescription", "ActionDescription *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_AutoCompleteCallback = {"_p_AutoCompleteCallback", "AutoCompleteCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BufferDescription = {"_p_BufferDescription", "BufferDescription *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_BugReport = {"_p_BugReport", "BugReport *", 0, 0, (void*)&SwigPyBuiltin__BugReport_clientdata, 0};
static swig_type_info _swigt__p_CaptureFileFormat = {"_p_CaptureFileFormat", "CaptureFileFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CaptureModifications = {"_p_CaptureModifications", "enum CaptureModifications *|CaptureModifications *", 0, 0, (void*)&SwigPyBuiltin__CaptureModifications_clientdata, 0};
static swig_type_info _swigt__p_CaptureOptions = {"_p_CaptureOptions", "struct CaptureOptions *|CaptureOptions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_CaptureSettings = {"_p_CaptureSettings", "CaptureSettings *", 0, 0, (void*)&SwigPyBuiltin__CaptureSettings_clientdata, 0};
static swig_type_info _swigt__p_ContextMenu = {"_p_ContextMenu", "enum ContextMenu *|ContextMenu *", 0, 0, (void*)&SwigPyBuiltin__ContextMenu_clientdata, 0};
static swig_type_info _swigt__p_D3D11Pipe__State = {"_p_D3D11Pipe__State", "D3D11Pipe::State *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_D3D12Pipe__State = {"_p_D3D12Pipe__State", "D3D12Pipe::State *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DebugOverlay = {"_p_DebugOverlay", "enum DebugOverlay *|DebugOverlay *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DescriptorStoreDescription = {"_p_DescriptorStoreDescription", "DescriptorStoreDescription *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DialogButton = {"_p_DialogButton", "enum DialogButton *|DialogButton *", 0, 0, (void*)&SwigPyBuiltin__DialogButton_clientdata, 0};
static swig_type_info _swigt__p_DirectoryBrowseCallback = {"_p_DirectoryBrowseCallback", "DirectoryBrowseCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_DockReference = {"_p_DockReference", "enum DockReference *|DockReference *", 0, 0, (void*)&SwigPyBuiltin__DockReference_clientdata, 0};
static swig_type_info _swigt__p_EventBookmark = {"_p_EventBookmark", "EventBookmark *", 0, 0, (void*)&SwigPyBuiltin__EventBookmark_clientdata, 0};
static swig_type_info _swigt__p_EventFilterCallback = {"_p_EventFilterCallback", "EventFilterCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExecuteResult = {"_p_ExecuteResult", "ExecuteResult *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExtensionCallback = {"_p_ExtensionCallback", "ExtensionCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExtensionMetadata = {"_p_ExtensionMetadata", "ExtensionMetadata *", 0, 0, (void*)&SwigPyBuiltin__ExtensionMetadata_clientdata, 0};
static swig_type_info _swigt__p_FilterParseCallback = {"_p_FilterParseCallback", "FilterParseCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_FollowType = {"_p_FollowType", "enum FollowType *|FollowType *", 0, 0, (void*)&SwigPyBuiltin__FollowType_clientdata, 0};
static swig_type_info _swigt__p_FrameDescription = {"_p_FrameDescription", "FrameDescription *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_GLPipe__State = {"_p_GLPipe__State", "GLPipe::State *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IAPIInspector = {"_p_IAPIInspector", "IAPIInspector *", 0, 0, (void*)&SwigPyBuiltin__IAPIInspector_clientdata, 0};
static swig_type_info _swigt__p_IBufferViewer = {"_p_IBufferViewer", "IBufferViewer *", 0, 0, (void*)&SwigPyBuiltin__IBufferViewer_clientdata, 0};
static swig_type_info _swigt__p_ICaptureAccess = {"_p_ICaptureAccess", "ICaptureAccess *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IRemoteServer = {"_p_IRemoteServer", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_ICaptureContext = {"_p_ICaptureContext", "ICaptureContext *", 0, 0, (void*)&SwigPyBuiltin__ICaptureContext_clientdata, 0};
static swig_type_info _swigt__p_ICaptureDialog = {"_p_ICaptureDialog", "ICaptureDialog *", 0, 0, (void*)&SwigPyBuiltin__ICaptureDialog_clientdata, 0};
static swig_type_info _swigt__p_ICaptureFile = {"_p_ICaptureFile", "ICaptureFile *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ICaptureViewer = {"_p_ICaptureViewer", "ICaptureViewer *", 0, 0, (void*)&SwigPyBuiltin__ICaptureViewer_clientdata, 0};
static swig_type_info _swigt__p_ICommentView = {"_p_ICommentView", "ICommentView *", 0, 0, (void*)&SwigPyBuiltin__ICommentView_clientdata, 0};
static swig_type_info _swigt__p_IDebugMessageView = {"_p_IDebugMessageView", "IDebugMessageView *", 0, 0, (void*)&SwigPyBuiltin__IDebugMessageView_clientdata, 0};
static swig_type_info _swigt__p_IDescriptorViewer = {"_p_IDescriptorViewer", "IDescriptorViewer *", 0, 0, (void*)&SwigPyBuiltin__IDescriptorViewer_clientdata, 0};
static swig_type_info _swigt__p_IDeviceProtocolController = {"_p_IDeviceProtocolController", "IDeviceProtocolController *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IDiagnosticLogView = {"_p_IDiagnosticLogView", "IDiagnosticLogView *", 0, 0, (void*)&SwigPyBuiltin__IDiagnosticLogView_clientdata, 0};
static swig_type_info _swigt__p_IEventBrowser = {"_p_IEventBrowser", "IEventBrowser *", 0, 0, (void*)&SwigPyBuiltin__IEventBrowser_clientdata, 0};
static swig_type_info _swigt__p_IExtensionManager = {"_p_IExtensionManager", "IExtensionManager *", 0, 0, (void*)&SwigPyBuiltin__IExtensionManager_clientdata, 0};
static swig_type_info _swigt__p_IMainWindow = {"_p_IMainWindow", "IMainWindow *", 0, 0, (void*)&SwigPyBuiltin__IMainWindow_clientdata, 0};
static swig_type_info _swigt__p_IMiniQtHelper = {"_p_IMiniQtHelper", "IMiniQtHelper *", 0, 0, (void*)&SwigPyBuiltin__IMiniQtHelper_clientdata, 0};
static swig_type_info _swigt__p_IPerformanceCounterViewer = {"_p_IPerformanceCounterViewer", "IPerformanceCounterViewer *", 0, 0, (void*)&SwigPyBuiltin__IPerformanceCounterViewer_clientdata, 0};
static swig_type_info _swigt__p_IPipelineStateViewer = {"_p_IPipelineStateViewer", "IPipelineStateViewer *", 0, 0, (void*)&SwigPyBuiltin__IPipelineStateViewer_clientdata, 0};
static swig_type_info _swigt__p_IPixelHistoryView = {"_p_IPixelHistoryView", "IPixelHistoryView *", 0, 0, (void*)&SwigPyBuiltin__IPixelHistoryView_clientdata, 0};
static swig_type_info _swigt__p_IPythonShell = {"_p_IPythonShell", "IPythonShell *", 0, 0, (void*)&SwigPyBuiltin__IPythonShell_clientdata, 0};
static swig_type_info _swigt__p_IRGPInterop = {"_p_IRGPInterop", "IRGPInterop *", 0, 0, (void*)&SwigPyBuiltin__IRGPInterop_clientdata, 0};
static swig_type_info _swigt__p_IReplayManager = {"_p_IReplayManager", "IReplayManager *", 0, 0, (void*)&SwigPyBuiltin__IReplayManager_clientdata, 0};
static swig_type_info _swigt__p_IReplayOutput = {"_p_IReplayOutput", "IReplayOutput *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IResourceInspector = {"_p_IResourceInspector", "IResourceInspector *", 0, 0, (void*)&SwigPyBuiltin__IResourceInspector_clientdata, 0};
static swig_type_info _swigt__p_IShaderMessageViewer = {"_p_IShaderMessageViewer", "IShaderMessageViewer *", 0, 0, (void*)&SwigPyBuiltin__IShaderMessageViewer_clientdata, 0};
static swig_type_info _swigt__p_IShaderViewer = {"_p_IShaderViewer", "IShaderViewer *", 0, 0, (void*)&SwigPyBuiltin__IShaderViewer_clientdata, 0};
static swig_type_info _swigt__p_IStatisticsViewer = {"_p_IStatisticsViewer", "IStatisticsViewer *", 0, 0, (void*)&SwigPyBuiltin__IStatisticsViewer_clientdata, 0};
static swig_type_info _swigt__p_ITextureViewer = {"_p_ITextureViewer", "ITextureViewer *", 0, 0, (void*)&SwigPyBuiltin__ITextureViewer_clientdata, 0};
static swig_type_info _swigt__p_ITimelineBar = {"_p_ITimelineBar", "ITimelineBar *", 0, 0, (void*)&SwigPyBuiltin__ITimelineBar_clientdata, 0};
static swig_type_info _swigt__p_InvokeCallback = {"_p_InvokeCallback", "InvokeCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_KnownShaderTool = {"_p_KnownShaderTool", "enum KnownShaderTool *|KnownShaderTool *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_OffsetSizeDisplayMode = {"_p_OffsetSizeDisplayMode", "enum OffsetSizeDisplayMode *|OffsetSizeDisplayMode *", 0, 0, (void*)&SwigPyBuiltin__OffsetSizeDisplayMode_clientdata, 0};
static swig_type_info _swigt__p_PanelMenu = {"_p_PanelMenu", "enum PanelMenu *|PanelMenu *", 0, 0, (void*)&SwigPyBuiltin__PanelMenu_clientdata, 0};
static swig_type_info _swigt__p_PersistantConfig = {"_p_PersistantConfig", "PersistantConfig *", 0, 0, (void*)&SwigPyBuiltin__PersistantConfig_clientdata, 0};
static swig_type_info _swigt__p_PipeState = {"_p_PipeState", "PipeState *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PipelineStage = {"_p_PipelineStage", "enum PipelineStage *|PipelineStage *", 0, 0, (void*)&SwigPyBuiltin__PipelineStage_clientdata, 0};
static swig_type_info _swigt__p_QWidget = {"_p_QWidget", "QWidget *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RemoteHost = {"_p_RemoteHost", "RemoteHost *", 0, 0, (void*)&SwigPyBuiltin__RemoteHost_clientdata, 0};
static swig_type_info _swigt__p_ReplayOptions = {"_p_ReplayOptions", "ReplayOptions *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ResourceDescription = {"_p_ResourceDescription", "ResourceDescription *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ResourceId = {"_p_ResourceId", "ResourceId *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ResultDetails = {"_p_ResultDetails", "ResultDetails *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RevertCallback = {"_p_RevertCallback", "RevertCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SDFile = {"_p_SDFile", "SDFile *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SDObject = {"_p_SDObject", "SDObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SDChunk = {"_p_SDChunk", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_SaveCallback = {"_p_SaveCallback", "SaveCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ShaderCompileFlags = {"_p_ShaderCompileFlags", "ShaderCompileFlags *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ShaderDebugTrace = {"_p_ShaderDebugTrace", "ShaderDebugTrace *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ShaderEncoding = {"_p_ShaderEncoding", "enum ShaderEncoding *|ShaderEncoding *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ShaderProcessingTool = {"_p_ShaderProcessingTool", "ShaderProcessingTool *", 0, 0, (void*)&SwigPyBuiltin__ShaderProcessingTool_clientdata, 0};
static swig_type_info _swigt__p_ShaderReflection = {"_p_ShaderReflection", "ShaderReflection *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ShaderToolOutput = {"_p_ShaderToolOutput", "ShaderToolOutput *", 0, 0, (void*)&SwigPyBuiltin__ShaderToolOutput_clientdata, 0};
static swig_type_info _swigt__p_ShortcutCallback = {"_p_ShortcutCallback", "ShortcutCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Subresource = {"_p_Subresource", "Subresource *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SwigPyObject = {"_p_SwigPyObject", "SwigPyObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TextureDescription = {"_p_TextureDescription", "TextureDescription *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TextureDisplay = {"_p_TextureDisplay", "TextureDisplay *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TimeUnit = {"_p_TimeUnit", "enum TimeUnit *|TimeUnit *", 0, 0, (void*)&SwigPyBuiltin__TimeUnit_clientdata, 0};
static swig_type_info _swigt__p_VKPipe__State = {"_p_VKPipe__State", "VKPipe::State *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_WidgetCallback = {"_p_WidgetCallback", "WidgetCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_WindowMenu = {"_p_WindowMenu", "enum WindowMenu *|WindowMenu *", 0, 0, (void*)&SwigPyBuiltin__WindowMenu_clientdata, 0};
static swig_type_info _swigt__p_WindowingData = {"_p_WindowingData", "WindowingData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_WindowingSystem = {"_p_WindowingSystem", "enum WindowingSystem *|WindowingSystem *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__XDisplay = {"_p__XDisplay", "_XDisplay *|Display *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p__object = {"_p__object", "_object *|PyObject *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_bytebuf = {"_p_bytebuf", "bytebuf *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_int = {"_p_int", "intptr_t *|int *|int_least32_t *|int_fast32_t *|int32_t *|int_fast16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_long_long = {"_p_long_long", "int_least64_t *|int_fast64_t *|int64_t *|long long *|intmax_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_IRemoteServer = {"_p_p_IRemoteServer", "IRemoteServer **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_ActionDescription_t = {"_p_rdcarrayT_ActionDescription_t", "rdcarray< ActionDescription > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_BufferDescription_t = {"_p_rdcarrayT_BufferDescription_t", "rdcarray< BufferDescription > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_BugReport_t = {"_p_rdcarrayT_BugReport_t", "rdcarray< BugReport > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_BugReport_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_DebugMessage_t = {"_p_rdcarrayT_DebugMessage_t", "rdcarray< DebugMessage > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_Descriptor_t = {"_p_rdcarrayT_Descriptor_t", "rdcarray< Descriptor > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_DialogButton_t = {"_p_rdcarrayT_DialogButton_t", "rdcarray< enum DialogButton > *|rdcarray< DialogButton > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_DialogButton_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_EnvironmentModification_t = {"_p_rdcarrayT_EnvironmentModification_t", "rdcarray< EnvironmentModification > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_EventBookmark_t = {"_p_rdcarrayT_EventBookmark_t", "rdcarray< EventBookmark > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_EventBookmark_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_ExtensionMetadata_t = {"_p_rdcarrayT_ExtensionMetadata_t", "rdcarray< ExtensionMetadata > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_ICaptureViewer_p_t = {"_p_rdcarrayT_ICaptureViewer_p_t", "rdcarray< ICaptureViewer * > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_PixelModification_t = {"_p_rdcarrayT_PixelModification_t", "rdcarray< PixelModification > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_RemoteHost_t = {"_p_rdcarrayT_RemoteHost_t", "rdcarray< RemoteHost > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_RemoteHost_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_ResourceDescription_t = {"_p_rdcarrayT_ResourceDescription_t", "rdcarray< ResourceDescription > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_SamplerDescriptor_t = {"_p_rdcarrayT_SamplerDescriptor_t", "rdcarray< SamplerDescriptor > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_ShaderEncoding_t = {"_p_rdcarrayT_ShaderEncoding_t", "rdcarray< enum ShaderEncoding > *|rdcarray< ShaderEncoding > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_ShaderMessage_t = {"_p_rdcarrayT_ShaderMessage_t", "rdcarray< ShaderMessage > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_ShaderProcessingTool_t = {"_p_rdcarrayT_ShaderProcessingTool_t", "rdcarray< ShaderProcessingTool > *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_ShaderSourcePrefix_t = {"_p_rdcarrayT_ShaderSourcePrefix_t", "rdcarray< ShaderSourcePrefix > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_TextureDescription_t = {"_p_rdcarrayT_TextureDescription_t", "rdcarray< TextureDescription > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t = {"_p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t", "rdcarray< rdcpair< rdcstr,rdcstr > > *|rdcarray< rdcstrpair > *|rdcstrpairs *", 0, 0, (void*)&SwigPyBuiltin__rdcarrayT_rdcstrpair_t_clientdata, 0};
static swig_type_info _swigt__p_rdcarrayT_rdcstr_t = {"_p_rdcarrayT_rdcstr_t", "rdcarray< rdcstr > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcdatetime = {"_p_rdcdatetime", "rdcdatetime *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcpairT_rdcstr_rdcstr_t = {"_p_rdcpairT_rdcstr_rdcstr_t", "rdcstrpair *|rdcpair< rdcstr,rdcstr > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_rdcstr = {"_p_rdcstr", "rdcstr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_short = {"_p_short", "short *|int_least16_t *|int16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_signed_char = {"_p_signed_char", "signed char *|int_least8_t *|int_fast8_t *|int8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t = {"_p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t", "RENDERDOC_PreviewWindowCallback *|std::function< WindowingData (bool,rdcarray< WindowingSystem > const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fBugReport_const_RF_t = {"_p_std__functionT_bool_fBugReport_const_RF_t", "std::function< bool (BugReport const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fDialogButton_const_RF_t = {"_p_std__functionT_bool_fDialogButton_const_RF_t", "std::function< bool (enum DialogButton const &) > *|std::function< bool (DialogButton const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fEventBookmark_const_RF_t = {"_p_std__functionT_bool_fEventBookmark_const_RF_t", "std::function< bool (EventBookmark const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fExtensionMetadata_const_RF_t = {"_p_std__functionT_bool_fExtensionMetadata_const_RF_t", "std::function< bool (ExtensionMetadata const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fF_t = {"_p_std__functionT_bool_fF_t", "RENDERDOC_KillCallback *|std::function< bool () > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t = {"_p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t", "IEventBrowser::EventFilterCallback *|std::function< bool (ICaptureContext *,rdcstr const &,rdcstr const &,unsigned int,SDChunk const *,ActionDescription const *,rdcstr const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fICaptureViewer_pconst_RF_t = {"_p_std__functionT_bool_fICaptureViewer_pconst_RF_t", "std::function< bool (ICaptureViewer *const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fRemoteHost_const_RF_t = {"_p_std__functionT_bool_fRemoteHost_const_RF_t", "std::function< bool (RemoteHost const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_fShaderProcessingTool_const_RF_t = {"_p_std__functionT_bool_fShaderProcessingTool_const_RF_t", "std::function< bool (ShaderProcessingTool const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t = {"_p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t", "std::function< bool (rdcpair< rdcstr,rdcstr > const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t = {"_p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t", "IEventBrowser::AutoCompleteCallback *|std::function< rdcarray< rdcstr > (ICaptureContext *,rdcstr const &,rdcstr const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t = {"_p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t", "IEventBrowser::FilterParseCallback *|std::function< rdcstr (ICaptureContext *,rdcstr const &,rdcstr const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fF_t = {"_p_std__functionT_void_fF_t", "IMiniQtHelper::InvokeCallback *|std::function< void () > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t = {"_p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t", "IShaderViewer::RevertCallback *|std::function< void (ICaptureContext *,IShaderViewer *,ResourceId) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t = {"_p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t", "IShaderViewer::SaveCallback *|std::function< void (ICaptureContext *,IShaderViewer *,ResourceId,enum ShaderStage,enum ShaderEncoding,ShaderCompileFlags,rdcstr,bytebuf) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t = {"_p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t", "IMiniQtHelper::WidgetCallback *|std::function< void (ICaptureContext *,QWidget *,rdcstr) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t = {"_p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t", "IExtensionManager::ExtensionCallback *|std::function< void (ICaptureContext *,rdcarray< rdcpair< rdcstr,_object * > > const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fIReplayController_pF_t = {"_p_std__functionT_void_fIReplayController_pF_t", "std::function< void (IReplayController *) > *|IReplayManager::InvokeCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_fQWidget_pF_t = {"_p_std__functionT_void_fQWidget_pF_t", "std::function< void (QWidget *) > *|IMainWindow::ShortcutCallback *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_ffloatF_t = {"_p_std__functionT_void_ffloatF_t", "RENDERDOC_ProgressCallback *|std::function< void (float) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t = {"_p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t", "IReplayManager::DirectoryBrowseCallback *|std::function< void (rdcstr const &,rdcarray< PathEntry > const &) > *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_char = {"_p_unsigned_char", "unsigned char *|byte *|uint_least8_t *|uint_fast8_t *|uint8_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_int = {"_p_unsigned_int", "uintptr_t *|uint_least32_t *|uint_fast32_t *|uint32_t *|unsigned int *|xcb_window_t *|uint_fast16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long = {"_p_unsigned_long", "unsigned long *|Drawable *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_long_long = {"_p_unsigned_long_long", "uint_least64_t *|uint_fast64_t *|uint64_t *|unsigned long long *|uintmax_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_unsigned_short = {"_p_unsigned_short", "unsigned short *|uint_least16_t *|uint16_t *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_APIEvent,
  &_swigt__p_APIProperties,
  &_swigt__p_ActionDescription,
  &_swigt__p_AutoCompleteCallback,
  &_swigt__p_BufferDescription,
  &_swigt__p_BugReport,
  &_swigt__p_CaptureFileFormat,
  &_swigt__p_CaptureModifications,
  &_swigt__p_CaptureOptions,
  &_swigt__p_CaptureSettings,
  &_swigt__p_ContextMenu,
  &_swigt__p_D3D11Pipe__State,
  &_swigt__p_D3D12Pipe__State,
  &_swigt__p_DebugOverlay,
  &_swigt__p_DescriptorStoreDescription,
  &_swigt__p_DialogButton,
  &_swigt__p_DirectoryBrowseCallback,
  &_swigt__p_DockReference,
  &_swigt__p_EventBookmark,
  &_swigt__p_EventFilterCallback,
  &_swigt__p_ExecuteResult,
  &_swigt__p_ExtensionCallback,
  &_swigt__p_ExtensionMetadata,
  &_swigt__p_FilterParseCallback,
  &_swigt__p_FollowType,
  &_swigt__p_FrameDescription,
  &_swigt__p_GLPipe__State,
  &_swigt__p_IAPIInspector,
  &_swigt__p_IBufferViewer,
  &_swigt__p_ICaptureAccess,
  &_swigt__p_ICaptureContext,
  &_swigt__p_ICaptureDialog,
  &_swigt__p_ICaptureFile,
  &_swigt__p_ICaptureViewer,
  &_swigt__p_ICommentView,
  &_swigt__p_IDebugMessageView,
  &_swigt__p_IDescriptorViewer,
  &_swigt__p_IDeviceProtocolController,
  &_swigt__p_IDiagnosticLogView,
  &_swigt__p_IEventBrowser,
  &_swigt__p_IExtensionManager,
  &_swigt__p_IMainWindow,
  &_swigt__p_IMiniQtHelper,
  &_swigt__p_IPerformanceCounterViewer,
  &_swigt__p_IPipelineStateViewer,
  &_swigt__p_IPixelHistoryView,
  &_swigt__p_IPythonShell,
  &_swigt__p_IRGPInterop,
  &_swigt__p_IRemoteServer,
  &_swigt__p_IReplayManager,
  &_swigt__p_IReplayOutput,
  &_swigt__p_IResourceInspector,
  &_swigt__p_IShaderMessageViewer,
  &_swigt__p_IShaderViewer,
  &_swigt__p_IStatisticsViewer,
  &_swigt__p_ITextureViewer,
  &_swigt__p_ITimelineBar,
  &_swigt__p_InvokeCallback,
  &_swigt__p_KnownShaderTool,
  &_swigt__p_OffsetSizeDisplayMode,
  &_swigt__p_PanelMenu,
  &_swigt__p_PersistantConfig,
  &_swigt__p_PipeState,
  &_swigt__p_PipelineStage,
  &_swigt__p_QWidget,
  &_swigt__p_RemoteHost,
  &_swigt__p_ReplayOptions,
  &_swigt__p_ResourceDescription,
  &_swigt__p_ResourceId,
  &_swigt__p_ResultDetails,
  &_swigt__p_RevertCallback,
  &_swigt__p_SDChunk,
  &_swigt__p_SDFile,
  &_swigt__p_SDObject,
  &_swigt__p_SaveCallback,
  &_swigt__p_ShaderCompileFlags,
  &_swigt__p_ShaderDebugTrace,
  &_swigt__p_ShaderEncoding,
  &_swigt__p_ShaderProcessingTool,
  &_swigt__p_ShaderReflection,
  &_swigt__p_ShaderToolOutput,
  &_swigt__p_ShortcutCallback,
  &_swigt__p_Subresource,
  &_swigt__p_SwigPyObject,
  &_swigt__p_TextureDescription,
  &_swigt__p_TextureDisplay,
  &_swigt__p_TimeUnit,
  &_swigt__p_VKPipe__State,
  &_swigt__p_WidgetCallback,
  &_swigt__p_WindowMenu,
  &_swigt__p_WindowingData,
  &_swigt__p_WindowingSystem,
  &_swigt__p__XDisplay,
  &_swigt__p__object,
  &_swigt__p_bytebuf,
  &_swigt__p_char,
  &_swigt__p_int,
  &_swigt__p_long_long,
  &_swigt__p_p_IRemoteServer,
  &_swigt__p_rdcarrayT_ActionDescription_t,
  &_swigt__p_rdcarrayT_BufferDescription_t,
  &_swigt__p_rdcarrayT_BugReport_t,
  &_swigt__p_rdcarrayT_DebugMessage_t,
  &_swigt__p_rdcarrayT_Descriptor_t,
  &_swigt__p_rdcarrayT_DialogButton_t,
  &_swigt__p_rdcarrayT_EnvironmentModification_t,
  &_swigt__p_rdcarrayT_EventBookmark_t,
  &_swigt__p_rdcarrayT_ExtensionMetadata_t,
  &_swigt__p_rdcarrayT_ICaptureViewer_p_t,
  &_swigt__p_rdcarrayT_PixelModification_t,
  &_swigt__p_rdcarrayT_RemoteHost_t,
  &_swigt__p_rdcarrayT_ResourceDescription_t,
  &_swigt__p_rdcarrayT_SamplerDescriptor_t,
  &_swigt__p_rdcarrayT_ShaderEncoding_t,
  &_swigt__p_rdcarrayT_ShaderMessage_t,
  &_swigt__p_rdcarrayT_ShaderProcessingTool_t,
  &_swigt__p_rdcarrayT_ShaderSourcePrefix_t,
  &_swigt__p_rdcarrayT_TextureDescription_t,
  &_swigt__p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t,
  &_swigt__p_rdcarrayT_rdcstr_t,
  &_swigt__p_rdcdatetime,
  &_swigt__p_rdcpairT_rdcstr_rdcstr_t,
  &_swigt__p_rdcstr,
  &_swigt__p_short,
  &_swigt__p_signed_char,
  &_swigt__p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t,
  &_swigt__p_std__functionT_bool_fBugReport_const_RF_t,
  &_swigt__p_std__functionT_bool_fDialogButton_const_RF_t,
  &_swigt__p_std__functionT_bool_fEventBookmark_const_RF_t,
  &_swigt__p_std__functionT_bool_fExtensionMetadata_const_RF_t,
  &_swigt__p_std__functionT_bool_fF_t,
  &_swigt__p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t,
  &_swigt__p_std__functionT_bool_fICaptureViewer_pconst_RF_t,
  &_swigt__p_std__functionT_bool_fRemoteHost_const_RF_t,
  &_swigt__p_std__functionT_bool_fShaderProcessingTool_const_RF_t,
  &_swigt__p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t,
  &_swigt__p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t,
  &_swigt__p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t,
  &_swigt__p_std__functionT_void_fF_t,
  &_swigt__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t,
  &_swigt__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t,
  &_swigt__p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t,
  &_swigt__p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t,
  &_swigt__p_std__functionT_void_fIReplayController_pF_t,
  &_swigt__p_std__functionT_void_fQWidget_pF_t,
  &_swigt__p_std__functionT_void_ffloatF_t,
  &_swigt__p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t,
  &_swigt__p_unsigned_char,
  &_swigt__p_unsigned_int,
  &_swigt__p_unsigned_long,
  &_swigt__p_unsigned_long_long,
  &_swigt__p_unsigned_short,
  &_swigt__p_value_type,
};

static swig_cast_info _swigc__p_APIEvent[] = {  {&_swigt__p_APIEvent, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_APIProperties[] = {  {&_swigt__p_APIProperties, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ActionDescription[] = {  {&_swigt__p_ActionDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_AutoCompleteCallback[] = {  {&_swigt__p_AutoCompleteCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BufferDescription[] = {  {&_swigt__p_BufferDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_BugReport[] = {  {&_swigt__p_BugReport, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CaptureFileFormat[] = {  {&_swigt__p_CaptureFileFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CaptureModifications[] = {  {&_swigt__p_CaptureModifications, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CaptureOptions[] = {  {&_swigt__p_CaptureOptions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CaptureSettings[] = {  {&_swigt__p_CaptureSettings, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ContextMenu[] = {  {&_swigt__p_ContextMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_D3D11Pipe__State[] = {  {&_swigt__p_D3D11Pipe__State, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_D3D12Pipe__State[] = {  {&_swigt__p_D3D12Pipe__State, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DebugOverlay[] = {  {&_swigt__p_DebugOverlay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DescriptorStoreDescription[] = {  {&_swigt__p_DescriptorStoreDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DialogButton[] = {  {&_swigt__p_DialogButton, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DirectoryBrowseCallback[] = {  {&_swigt__p_DirectoryBrowseCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_DockReference[] = {  {&_swigt__p_DockReference, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EventBookmark[] = {  {&_swigt__p_EventBookmark, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EventFilterCallback[] = {  {&_swigt__p_EventFilterCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExecuteResult[] = {  {&_swigt__p_ExecuteResult, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExtensionCallback[] = {  {&_swigt__p_ExtensionCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExtensionMetadata[] = {  {&_swigt__p_ExtensionMetadata, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FilterParseCallback[] = {  {&_swigt__p_FilterParseCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FollowType[] = {  {&_swigt__p_FollowType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FrameDescription[] = {  {&_swigt__p_FrameDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_GLPipe__State[] = {  {&_swigt__p_GLPipe__State, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IAPIInspector[] = {  {&_swigt__p_IAPIInspector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IBufferViewer[] = {  {&_swigt__p_IBufferViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IRemoteServer[] = {{&_swigt__p_IRemoteServer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ICaptureAccess[] = {  {&_swigt__p_ICaptureFile, _p_ICaptureFileTo_p_ICaptureAccess, 0, 0},  {&_swigt__p_ICaptureAccess, 0, 0, 0},  {&_swigt__p_IRemoteServer, _p_IRemoteServerTo_p_ICaptureAccess, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ICaptureContext[] = {  {&_swigt__p_ICaptureContext, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ICaptureDialog[] = {  {&_swigt__p_ICaptureDialog, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ICaptureFile[] = {  {&_swigt__p_ICaptureFile, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ICaptureViewer[] = {  {&_swigt__p_ICaptureViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ICommentView[] = {  {&_swigt__p_ICommentView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IDebugMessageView[] = {  {&_swigt__p_IDebugMessageView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IDescriptorViewer[] = {  {&_swigt__p_IDescriptorViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IDeviceProtocolController[] = {  {&_swigt__p_IDeviceProtocolController, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IDiagnosticLogView[] = {  {&_swigt__p_IDiagnosticLogView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IEventBrowser[] = {  {&_swigt__p_IEventBrowser, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IExtensionManager[] = {  {&_swigt__p_IExtensionManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMainWindow[] = {  {&_swigt__p_IMainWindow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IMiniQtHelper[] = {  {&_swigt__p_IMiniQtHelper, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IPerformanceCounterViewer[] = {  {&_swigt__p_IPerformanceCounterViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IPipelineStateViewer[] = {  {&_swigt__p_IPipelineStateViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IPixelHistoryView[] = {  {&_swigt__p_IPixelHistoryView, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IPythonShell[] = {  {&_swigt__p_IPythonShell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IRGPInterop[] = {  {&_swigt__p_IRGPInterop, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IReplayManager[] = {  {&_swigt__p_IReplayManager, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IReplayOutput[] = {  {&_swigt__p_IReplayOutput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IResourceInspector[] = {  {&_swigt__p_IResourceInspector, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IShaderMessageViewer[] = {  {&_swigt__p_IShaderMessageViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IShaderViewer[] = {  {&_swigt__p_IShaderViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IStatisticsViewer[] = {  {&_swigt__p_IStatisticsViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ITextureViewer[] = {  {&_swigt__p_ITextureViewer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ITimelineBar[] = {  {&_swigt__p_ITimelineBar, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InvokeCallback[] = {  {&_swigt__p_InvokeCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_KnownShaderTool[] = {  {&_swigt__p_KnownShaderTool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OffsetSizeDisplayMode[] = {  {&_swigt__p_OffsetSizeDisplayMode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PanelMenu[] = {  {&_swigt__p_PanelMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PersistantConfig[] = {  {&_swigt__p_PersistantConfig, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PipeState[] = {  {&_swigt__p_PipeState, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PipelineStage[] = {  {&_swigt__p_PipelineStage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_QWidget[] = {  {&_swigt__p_QWidget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RemoteHost[] = {  {&_swigt__p_RemoteHost, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ReplayOptions[] = {  {&_swigt__p_ReplayOptions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ResourceDescription[] = {  {&_swigt__p_ResourceDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ResourceId[] = {  {&_swigt__p_ResourceId, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ResultDetails[] = {  {&_swigt__p_ResultDetails, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RevertCallback[] = {  {&_swigt__p_RevertCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDFile[] = {  {&_swigt__p_SDFile, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDChunk[] = {{&_swigt__p_SDChunk, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SDObject[] = {  {&_swigt__p_SDChunk, _p_SDChunkTo_p_SDObject, 0, 0},  {&_swigt__p_SDObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SaveCallback[] = {  {&_swigt__p_SaveCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShaderCompileFlags[] = {  {&_swigt__p_ShaderCompileFlags, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShaderDebugTrace[] = {  {&_swigt__p_ShaderDebugTrace, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShaderEncoding[] = {  {&_swigt__p_ShaderEncoding, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShaderProcessingTool[] = {  {&_swigt__p_ShaderProcessingTool, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShaderReflection[] = {  {&_swigt__p_ShaderReflection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShaderToolOutput[] = {  {&_swigt__p_ShaderToolOutput, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ShortcutCallback[] = {  {&_swigt__p_ShortcutCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Subresource[] = {  {&_swigt__p_Subresource, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SwigPyObject[] = {  {&_swigt__p_SwigPyObject, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TextureDescription[] = {  {&_swigt__p_TextureDescription, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TextureDisplay[] = {  {&_swigt__p_TextureDisplay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimeUnit[] = {  {&_swigt__p_TimeUnit, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VKPipe__State[] = {  {&_swigt__p_VKPipe__State, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WidgetCallback[] = {  {&_swigt__p_WidgetCallback, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WindowMenu[] = {  {&_swigt__p_WindowMenu, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WindowingData[] = {  {&_swigt__p_WindowingData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WindowingSystem[] = {  {&_swigt__p_WindowingSystem, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__XDisplay[] = {  {&_swigt__p__XDisplay, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p__object[] = {  {&_swigt__p__object, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_bytebuf[] = {  {&_swigt__p_bytebuf, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_int[] = {  {&_swigt__p_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_long_long[] = {  {&_swigt__p_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_IRemoteServer[] = {  {&_swigt__p_p_IRemoteServer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ActionDescription_t[] = {  {&_swigt__p_rdcarrayT_ActionDescription_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_BufferDescription_t[] = {  {&_swigt__p_rdcarrayT_BufferDescription_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_BugReport_t[] = {  {&_swigt__p_rdcarrayT_BugReport_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_DebugMessage_t[] = {  {&_swigt__p_rdcarrayT_DebugMessage_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_Descriptor_t[] = {  {&_swigt__p_rdcarrayT_Descriptor_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_DialogButton_t[] = {  {&_swigt__p_rdcarrayT_DialogButton_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_EnvironmentModification_t[] = {  {&_swigt__p_rdcarrayT_EnvironmentModification_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_EventBookmark_t[] = {  {&_swigt__p_rdcarrayT_EventBookmark_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ExtensionMetadata_t[] = {  {&_swigt__p_rdcarrayT_ExtensionMetadata_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ICaptureViewer_p_t[] = {  {&_swigt__p_rdcarrayT_ICaptureViewer_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_PixelModification_t[] = {  {&_swigt__p_rdcarrayT_PixelModification_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_RemoteHost_t[] = {  {&_swigt__p_rdcarrayT_RemoteHost_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ResourceDescription_t[] = {  {&_swigt__p_rdcarrayT_ResourceDescription_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_SamplerDescriptor_t[] = {  {&_swigt__p_rdcarrayT_SamplerDescriptor_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ShaderEncoding_t[] = {  {&_swigt__p_rdcarrayT_ShaderEncoding_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ShaderMessage_t[] = {  {&_swigt__p_rdcarrayT_ShaderMessage_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ShaderProcessingTool_t[] = {  {&_swigt__p_rdcarrayT_ShaderProcessingTool_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_ShaderSourcePrefix_t[] = {  {&_swigt__p_rdcarrayT_ShaderSourcePrefix_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_TextureDescription_t[] = {  {&_swigt__p_rdcarrayT_TextureDescription_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t[] = {  {&_swigt__p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcarrayT_rdcstr_t[] = {  {&_swigt__p_rdcarrayT_rdcstr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcdatetime[] = {  {&_swigt__p_rdcdatetime, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcpairT_rdcstr_rdcstr_t[] = {  {&_swigt__p_rdcpairT_rdcstr_rdcstr_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_rdcstr[] = {  {&_swigt__p_rdcstr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_short[] = {  {&_swigt__p_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_signed_char[] = {  {&_swigt__p_signed_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t[] = {  {&_swigt__p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fBugReport_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fBugReport_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fDialogButton_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fDialogButton_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fEventBookmark_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fEventBookmark_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fExtensionMetadata_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fExtensionMetadata_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fF_t[] = {  {&_swigt__p_std__functionT_bool_fF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fICaptureViewer_pconst_RF_t[] = {  {&_swigt__p_std__functionT_bool_fICaptureViewer_pconst_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fRemoteHost_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fRemoteHost_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_fShaderProcessingTool_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_fShaderProcessingTool_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t[] = {  {&_swigt__p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t[] = {  {&_swigt__p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t[] = {  {&_swigt__p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fF_t[] = {  {&_swigt__p_std__functionT_void_fF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t[] = {  {&_swigt__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t[] = {  {&_swigt__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t[] = {  {&_swigt__p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t[] = {  {&_swigt__p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fIReplayController_pF_t[] = {  {&_swigt__p_std__functionT_void_fIReplayController_pF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_fQWidget_pF_t[] = {  {&_swigt__p_std__functionT_void_fQWidget_pF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_ffloatF_t[] = {  {&_swigt__p_std__functionT_void_ffloatF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t[] = {  {&_swigt__p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_char[] = {  {&_swigt__p_unsigned_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_int[] = {  {&_swigt__p_unsigned_int, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long[] = {  {&_swigt__p_unsigned_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_long_long[] = {  {&_swigt__p_unsigned_long_long, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_unsigned_short[] = {  {&_swigt__p_unsigned_short, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_APIEvent,
  _swigc__p_APIProperties,
  _swigc__p_ActionDescription,
  _swigc__p_AutoCompleteCallback,
  _swigc__p_BufferDescription,
  _swigc__p_BugReport,
  _swigc__p_CaptureFileFormat,
  _swigc__p_CaptureModifications,
  _swigc__p_CaptureOptions,
  _swigc__p_CaptureSettings,
  _swigc__p_ContextMenu,
  _swigc__p_D3D11Pipe__State,
  _swigc__p_D3D12Pipe__State,
  _swigc__p_DebugOverlay,
  _swigc__p_DescriptorStoreDescription,
  _swigc__p_DialogButton,
  _swigc__p_DirectoryBrowseCallback,
  _swigc__p_DockReference,
  _swigc__p_EventBookmark,
  _swigc__p_EventFilterCallback,
  _swigc__p_ExecuteResult,
  _swigc__p_ExtensionCallback,
  _swigc__p_ExtensionMetadata,
  _swigc__p_FilterParseCallback,
  _swigc__p_FollowType,
  _swigc__p_FrameDescription,
  _swigc__p_GLPipe__State,
  _swigc__p_IAPIInspector,
  _swigc__p_IBufferViewer,
  _swigc__p_ICaptureAccess,
  _swigc__p_ICaptureContext,
  _swigc__p_ICaptureDialog,
  _swigc__p_ICaptureFile,
  _swigc__p_ICaptureViewer,
  _swigc__p_ICommentView,
  _swigc__p_IDebugMessageView,
  _swigc__p_IDescriptorViewer,
  _swigc__p_IDeviceProtocolController,
  _swigc__p_IDiagnosticLogView,
  _swigc__p_IEventBrowser,
  _swigc__p_IExtensionManager,
  _swigc__p_IMainWindow,
  _swigc__p_IMiniQtHelper,
  _swigc__p_IPerformanceCounterViewer,
  _swigc__p_IPipelineStateViewer,
  _swigc__p_IPixelHistoryView,
  _swigc__p_IPythonShell,
  _swigc__p_IRGPInterop,
  _swigc__p_IRemoteServer,
  _swigc__p_IReplayManager,
  _swigc__p_IReplayOutput,
  _swigc__p_IResourceInspector,
  _swigc__p_IShaderMessageViewer,
  _swigc__p_IShaderViewer,
  _swigc__p_IStatisticsViewer,
  _swigc__p_ITextureViewer,
  _swigc__p_ITimelineBar,
  _swigc__p_InvokeCallback,
  _swigc__p_KnownShaderTool,
  _swigc__p_OffsetSizeDisplayMode,
  _swigc__p_PanelMenu,
  _swigc__p_PersistantConfig,
  _swigc__p_PipeState,
  _swigc__p_PipelineStage,
  _swigc__p_QWidget,
  _swigc__p_RemoteHost,
  _swigc__p_ReplayOptions,
  _swigc__p_ResourceDescription,
  _swigc__p_ResourceId,
  _swigc__p_ResultDetails,
  _swigc__p_RevertCallback,
  _swigc__p_SDChunk,
  _swigc__p_SDFile,
  _swigc__p_SDObject,
  _swigc__p_SaveCallback,
  _swigc__p_ShaderCompileFlags,
  _swigc__p_ShaderDebugTrace,
  _swigc__p_ShaderEncoding,
  _swigc__p_ShaderProcessingTool,
  _swigc__p_ShaderReflection,
  _swigc__p_ShaderToolOutput,
  _swigc__p_ShortcutCallback,
  _swigc__p_Subresource,
  _swigc__p_SwigPyObject,
  _swigc__p_TextureDescription,
  _swigc__p_TextureDisplay,
  _swigc__p_TimeUnit,
  _swigc__p_VKPipe__State,
  _swigc__p_WidgetCallback,
  _swigc__p_WindowMenu,
  _swigc__p_WindowingData,
  _swigc__p_WindowingSystem,
  _swigc__p__XDisplay,
  _swigc__p__object,
  _swigc__p_bytebuf,
  _swigc__p_char,
  _swigc__p_int,
  _swigc__p_long_long,
  _swigc__p_p_IRemoteServer,
  _swigc__p_rdcarrayT_ActionDescription_t,
  _swigc__p_rdcarrayT_BufferDescription_t,
  _swigc__p_rdcarrayT_BugReport_t,
  _swigc__p_rdcarrayT_DebugMessage_t,
  _swigc__p_rdcarrayT_Descriptor_t,
  _swigc__p_rdcarrayT_DialogButton_t,
  _swigc__p_rdcarrayT_EnvironmentModification_t,
  _swigc__p_rdcarrayT_EventBookmark_t,
  _swigc__p_rdcarrayT_ExtensionMetadata_t,
  _swigc__p_rdcarrayT_ICaptureViewer_p_t,
  _swigc__p_rdcarrayT_PixelModification_t,
  _swigc__p_rdcarrayT_RemoteHost_t,
  _swigc__p_rdcarrayT_ResourceDescription_t,
  _swigc__p_rdcarrayT_SamplerDescriptor_t,
  _swigc__p_rdcarrayT_ShaderEncoding_t,
  _swigc__p_rdcarrayT_ShaderMessage_t,
  _swigc__p_rdcarrayT_ShaderProcessingTool_t,
  _swigc__p_rdcarrayT_ShaderSourcePrefix_t,
  _swigc__p_rdcarrayT_TextureDescription_t,
  _swigc__p_rdcarrayT_rdcpairT_rdcstr_rdcstr_t_t,
  _swigc__p_rdcarrayT_rdcstr_t,
  _swigc__p_rdcdatetime,
  _swigc__p_rdcpairT_rdcstr_rdcstr_t,
  _swigc__p_rdcstr,
  _swigc__p_short,
  _swigc__p_signed_char,
  _swigc__p_std__functionT_WindowingData_fbool_rdcarrayT_WindowingSystem_t_const_RF_t,
  _swigc__p_std__functionT_bool_fBugReport_const_RF_t,
  _swigc__p_std__functionT_bool_fDialogButton_const_RF_t,
  _swigc__p_std__functionT_bool_fEventBookmark_const_RF_t,
  _swigc__p_std__functionT_bool_fExtensionMetadata_const_RF_t,
  _swigc__p_std__functionT_bool_fF_t,
  _swigc__p_std__functionT_bool_fICaptureContext_p_rdcstr_const_R_rdcstr_const_R_unsigned_int_SDChunk_const_p_ActionDescription_const_p_rdcstr_const_RF_t,
  _swigc__p_std__functionT_bool_fICaptureViewer_pconst_RF_t,
  _swigc__p_std__functionT_bool_fRemoteHost_const_RF_t,
  _swigc__p_std__functionT_bool_fShaderProcessingTool_const_RF_t,
  _swigc__p_std__functionT_bool_frdcpairT_rdcstr_rdcstr_t_const_RF_t,
  _swigc__p_std__functionT_rdcarrayT_rdcstr_t_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t,
  _swigc__p_std__functionT_rdcstr_fICaptureContext_p_rdcstr_const_R_rdcstr_const_RF_t,
  _swigc__p_std__functionT_void_fF_t,
  _swigc__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceIdF_t,
  _swigc__p_std__functionT_void_fICaptureContext_p_IShaderViewer_p_ResourceId_ShaderStage_ShaderEncoding_ShaderCompileFlags_rdcstr_bytebufF_t,
  _swigc__p_std__functionT_void_fICaptureContext_p_QWidget_p_rdcstrF_t,
  _swigc__p_std__functionT_void_fICaptureContext_p_rdcarrayT_rdcpairT_rdcstr__object_p_t_t_const_RF_t,
  _swigc__p_std__functionT_void_fIReplayController_pF_t,
  _swigc__p_std__functionT_void_fQWidget_pF_t,
  _swigc__p_std__functionT_void_ffloatF_t,
  _swigc__p_std__functionT_void_frdcstr_const_R_rdcarrayT_PathEntry_t_const_RF_t,
  _swigc__p_unsigned_char,
  _swigc__p_unsigned_int,
  _swigc__p_unsigned_long,
  _swigc__p_unsigned_long_long,
  _swigc__p_unsigned_short,
  _swigc__p_value_type,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0, 0, 0, 0.0, 0, 0}};

#ifdef __cplusplus
}
#endif
static PyTypeObject *builtin_bases[2];

/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %d\n", swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %d %s\n", i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif



#ifdef __cplusplus
extern "C" {
#endif
  
  /* Python-specific SWIG API */
#define SWIG_newvarlink()                             SWIG_Python_newvarlink()
#define SWIG_addvarlink(p, name, get_attr, set_attr)  SWIG_Python_addvarlink(p, name, get_attr, set_attr)
#define SWIG_InstallConstants(d, constants)           SWIG_Python_InstallConstants(d, constants)
  
  /* -----------------------------------------------------------------------------
   * global variable support code.
   * ----------------------------------------------------------------------------- */
  
  typedef struct swig_globalvar {
    char       *name;                  /* Name of global variable */
    PyObject *(*get_attr)(void);       /* Return the current value */
    int       (*set_attr)(PyObject *); /* Set the value */
    struct swig_globalvar *next;
  } swig_globalvar;
  
  typedef struct swig_varlinkobject {
    PyObject_HEAD
    swig_globalvar *vars;
  } swig_varlinkobject;
  
  SWIGINTERN PyObject *
  swig_varlink_repr(swig_varlinkobject *SWIGUNUSEDPARM(v)) {
#if PY_VERSION_HEX >= 0x03000000
    return PyUnicode_InternFromString("<Swig global variables>");
#else
    return PyString_FromString("<Swig global variables>");
#endif
  }
  
  SWIGINTERN PyObject *
  swig_varlink_str(swig_varlinkobject *v) {
#if PY_VERSION_HEX >= 0x03000000
    PyObject *str = PyUnicode_InternFromString("(");
    PyObject *tail;
    PyObject *joined;
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      tail = PyUnicode_FromString(var->name);
      joined = PyUnicode_Concat(str, tail);
      Py_DecRef(str);
      Py_DecRef(tail);
      str = joined;
      if (var->next) {
        tail = PyUnicode_InternFromString(", ");
        joined = PyUnicode_Concat(str, tail);
        Py_DecRef(str);
        Py_DecRef(tail);
        str = joined;
      }
    }
    tail = PyUnicode_InternFromString(")");
    joined = PyUnicode_Concat(str, tail);
    Py_DecRef(str);
    Py_DecRef(tail);
    str = joined;
#else
    PyObject *str = PyString_FromString("(");
    swig_globalvar *var;
    for (var = v->vars; var; var=var->next) {
      PyString_ConcatAndDel(&str,PyString_FromString(var->name));
      if (var->next) PyString_ConcatAndDel(&str,PyString_FromString(", "));
    }
    PyString_ConcatAndDel(&str,PyString_FromString(")"));
#endif
    return str;
  }
  
  SWIGINTERN int
  swig_varlink_print(swig_varlinkobject *v, FILE *fp, int SWIGUNUSEDPARM(flags)) {
    char *tmp;
    PyObject *str = swig_varlink_str(v);
    fprintf(fp,"Swig global variables ");
    fprintf(fp,"%s\n", tmp = SWIG_Python_str_AsChar(str));
    SWIG_Python_str_DelForPy3(tmp);
    Py_DECREF(str);
    return 0;
  }
  
  SWIGINTERN void
  swig_varlink_dealloc(swig_varlinkobject *v) {
    swig_globalvar *var = v->vars;
    while (var) {
      swig_globalvar *n = var->next;
      free(var->name);
      free(var);
      var = n;
    }
  }
  
  SWIGINTERN PyObject *
  swig_varlink_getattr(swig_varlinkobject *v, char *n) {
    PyObject *res = NULL;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->get_attr)();
        break;
      }
      var = var->next;
    }
    if (res == NULL && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN int
  swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
    int res = 1;
    swig_globalvar *var = v->vars;
    while (var) {
      if (strcmp(var->name,n) == 0) {
        res = (*var->set_attr)(p);
        break;
      }
      var = var->next;
    }
    if (res == 1 && !PyErr_Occurred()) {
      PyErr_Format(PyExc_AttributeError, "Unknown C global variable '%s'", n);
    }
    return res;
  }
  
  SWIGINTERN PyTypeObject*
  swig_varlink_type(void) {
    static char varlink__doc__[] = "Swig var link object";
    static PyTypeObject varlink_type;
    static int type_init = 0;
    if (!type_init) {
      const PyTypeObject tmp = {
#if PY_VERSION_HEX >= 0x03000000
        PyVarObject_HEAD_INIT(NULL, 0)
#else
        PyObject_HEAD_INIT(NULL)
        0,                                  /* ob_size */
#endif
        (char *)"swigvarlink",              /* tp_name */
        sizeof(swig_varlinkobject),         /* tp_basicsize */
        0,                                  /* tp_itemsize */
        (destructor) swig_varlink_dealloc,  /* tp_dealloc */
        (printfunc) swig_varlink_print,     /* tp_print */
        (getattrfunc) swig_varlink_getattr, /* tp_getattr */
        (setattrfunc) swig_varlink_setattr, /* tp_setattr */
        0,                                  /* tp_compare */
        (reprfunc) swig_varlink_repr,       /* tp_repr */
        0,                                  /* tp_as_number */
        0,                                  /* tp_as_sequence */
        0,                                  /* tp_as_mapping */
        0,                                  /* tp_hash */
        0,                                  /* tp_call */
        (reprfunc) swig_varlink_str,        /* tp_str */
        0,                                  /* tp_getattro */
        0,                                  /* tp_setattro */
        0,                                  /* tp_as_buffer */
        0,                                  /* tp_flags */
        varlink__doc__,                     /* tp_doc */
        0,                                  /* tp_traverse */
        0,                                  /* tp_clear */
        0,                                  /* tp_richcompare */
        0,                                  /* tp_weaklistoffset */
#if PY_VERSION_HEX >= 0x02020000
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* tp_iter -> tp_weaklist */
#endif
#if PY_VERSION_HEX >= 0x02030000
        0,                                  /* tp_del */
#endif
#if PY_VERSION_HEX >= 0x02060000
        0,                                  /* tp_version_tag */
#endif
#if PY_VERSION_HEX >= 0x03040000
        0,                                  /* tp_finalize */
#endif
#ifdef COUNT_ALLOCS
        0,                                  /* tp_allocs */
        0,                                  /* tp_frees */
        0,                                  /* tp_maxalloc */
#if PY_VERSION_HEX >= 0x02050000
        0,                                  /* tp_prev */
#endif
        0                                   /* tp_next */
#endif
      };
      varlink_type = tmp;
      type_init = 1;
#if PY_VERSION_HEX < 0x02020000
      varlink_type.ob_type = &PyType_Type;
#else
      if (PyType_Ready(&varlink_type) < 0)
      return NULL;
#endif
    }
    return &varlink_type;
  }
  
  /* Create a variable linking object for use later */
  SWIGINTERN PyObject *
  SWIG_Python_newvarlink(void) {
    swig_varlinkobject *result = PyObject_NEW(swig_varlinkobject, swig_varlink_type());
    if (result) {
      result->vars = 0;
    }
    return ((PyObject*) result);
  }
  
  SWIGINTERN void 
  SWIG_Python_addvarlink(PyObject *p, char *name, PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
    swig_varlinkobject *v = (swig_varlinkobject *) p;
    swig_globalvar *gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
    if (gv) {
      size_t size = strlen(name)+1;
      gv->name = (char *)malloc(size);
      if (gv->name) {
        strncpy(gv->name,name,size);
        gv->get_attr = get_attr;
        gv->set_attr = set_attr;
        gv->next = v->vars;
      }
    }
    v->vars = gv;
  }
  
  SWIGINTERN PyObject *
  SWIG_globals(void) {
    static PyObject *_SWIG_globals = 0; 
    if (!_SWIG_globals) _SWIG_globals = SWIG_newvarlink();  
    return _SWIG_globals;
  }
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  SWIGINTERN void
  SWIG_Python_InstallConstants(PyObject *d, swig_const_info constants[]) {
    PyObject *obj = 0;
    size_t i;
    for (i = 0; constants[i].type; ++i) {
      switch(constants[i].type) {
      case SWIG_PY_POINTER:
        obj = SWIG_InternalNewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_PY_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        PyDict_SetItemString(d, constants[i].name, obj);
        Py_DECREF(obj);
      }
    }
  }
  
  /* -----------------------------------------------------------------------------*/
  /* Fix SwigMethods to carry the callback ptrs when needed */
  /* -----------------------------------------------------------------------------*/
  
  SWIGINTERN void
  SWIG_Python_FixMethods(PyMethodDef *methods,
    swig_const_info *const_table,
    swig_type_info **types,
    swig_type_info **types_initial) {
    size_t i;
    for (i = 0; methods[i].ml_name; ++i) {
      const char *c = methods[i].ml_doc;
      if (!c) continue;
      c = strstr(c, "swig_ptr: ");
      if (c) {
        int j;
        swig_const_info *ci = 0;
        const char *name = c + 10;
        for (j = 0; const_table[j].type; ++j) {
          if (strncmp(const_table[j].name, name, 
              strlen(const_table[j].name)) == 0) {
            ci = &(const_table[j]);
            break;
          }
        }
        if (ci) {
          void *ptr = (ci->type == SWIG_PY_POINTER) ? ci->pvalue : 0;
          if (ptr) {
            size_t shift = (ci->ptype) - types;
            swig_type_info *ty = types_initial[shift];
            size_t ldoc = (c - methods[i].ml_doc);
            size_t lptr = strlen(ty->name)+2*sizeof(void*)+2;
            char *ndoc = (char*)malloc(ldoc + lptr + 10);
            if (ndoc) {
              char *buff = ndoc;
              strncpy(buff, methods[i].ml_doc, ldoc);
              buff += ldoc;
              strncpy(buff, "swig_ptr: ", 10);
              buff += 10;
              SWIG_PackVoidPtr(buff, ptr, ty->name, lptr);
              methods[i].ml_doc = ndoc;
            }
          }
        }
      }
    }
  } 
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

#ifdef __cplusplus
extern "C"
#endif

SWIGEXPORT 
#if PY_VERSION_HEX >= 0x03000000
PyObject*
#else
void
#endif
SWIG_init(void) {
  PyObject *m, *d, *md;
#if PY_VERSION_HEX >= 0x03000000
  static struct PyModuleDef SWIG_module = {
# if PY_VERSION_HEX >= 0x03020000
    PyModuleDef_HEAD_INIT,
# else
    {
      PyObject_HEAD_INIT(NULL)
      NULL, /* m_init */
      0,    /* m_index */
      NULL, /* m_copy */
    },
# endif
    (char *) SWIG_name,
    NULL,
    -1,
    SwigMethods,
    NULL,
    NULL,
    NULL,
    NULL
  };
#endif
  
#if defined(SWIGPYTHON_BUILTIN)
  static SwigPyClientData SwigPyObject_clientdata = {
    0, 0, 0, 0, 0, 0, 0
  };
  static PyGetSetDef this_getset_def = {
    (char *)"this", &SwigPyBuiltin_ThisClosure, NULL, NULL, NULL
  };
  static SwigPyGetSet thisown_getset_closure = {
    (PyCFunction) SwigPyObject_own,
    (PyCFunction) SwigPyObject_own
  };
  static PyGetSetDef thisown_getset_def = {
    (char *)"thisown", SwigPyBuiltin_GetterClosure, SwigPyBuiltin_SetterClosure, NULL, &thisown_getset_closure
  };
  PyTypeObject *builtin_pytype;
  int builtin_base_count;
  swig_type_info *builtin_basetype;
  PyObject *tuple;
  PyGetSetDescrObject *static_getset;
  PyTypeObject *metatype;
  PyTypeObject *swigpyobject;
  SwigPyClientData *cd;
  PyObject *public_interface, *public_symbol;
  PyObject *this_descr;
  PyObject *thisown_descr;
  PyObject *self = 0;
  int i;
  PyObject *enum_module;
  PyObject *Enum_class;
  PyObject *Flag_class;
  
  (void)builtin_pytype;
  (void)builtin_base_count;
  (void)builtin_basetype;
  (void)tuple;
  (void)static_getset;
  (void)self;
  
  /* Metaclass is used to implement static member variables */
  metatype = SwigPyObjectType();
  assert(metatype);
#endif
  
  /* Fix SwigMethods to carry the callback ptrs when needed */
  SWIG_Python_FixMethods(SwigMethods, swig_const_table, swig_types, swig_type_initial);
  
#if PY_VERSION_HEX >= 0x03000000
  m = PyModule_Create(&SWIG_module);
#else
  m = Py_InitModule((char *) SWIG_name, SwigMethods);
#endif
  
  /* Try to find strong enum module */
  Enum_class = NULL;
  Flag_class = NULL;
#if PY_VERSION_HEX >= 0x03000000
  enum_module = PyImport_ImportModule("enum");
  
  if (enum_module) {
    Enum_class = PyObject_GetAttrString(enum_module, "IntEnum");
    Flag_class = PyObject_GetAttrString(enum_module, "IntFlag");
  }
#endif
  
  md = d = PyModule_GetDict(m);
  (void)md;
  
  SWIG_InitializeModule(0);
  
#ifdef SWIGPYTHON_BUILTIN
  swigpyobject = SwigPyObject_TypeOnce();
  
  SwigPyObject_stype = SWIG_MangledTypeQuery("_p_SwigPyObject");
  assert(SwigPyObject_stype);
  cd = (SwigPyClientData*) SwigPyObject_stype->clientdata;
  if (!cd) {
    SwigPyObject_stype->clientdata = &SwigPyObject_clientdata;
    SwigPyObject_clientdata.pytype = swigpyobject;
  } else if (swigpyobject->tp_basicsize != cd->pytype->tp_basicsize) {
    PyErr_SetString(PyExc_RuntimeError, "Import error: attempted to load two incompatible swig-generated modules.");
# if PY_VERSION_HEX >= 0x03000000
    return NULL;
# else
    return;
# endif
  }
  
  /* All objects have a 'this' attribute */
  this_descr = PyDescr_NewGetSet(SwigPyObject_type(), &this_getset_def);
  (void)this_descr;
  
  /* All objects have a 'thisown' attribute */
  thisown_descr = PyDescr_NewGetSet(SwigPyObject_type(), &thisown_getset_def);
  (void)thisown_descr;
  
  public_interface = PyList_New(0);
  public_symbol = 0;
  (void)public_symbol;
  
  PyDict_SetItemString(md, "__all__", public_interface);
  Py_DECREF(public_interface);
  for (i = 0; SwigMethods[i].ml_name != NULL; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, SwigMethods[i].ml_name);
  for (i = 0; swig_const_table[i].name != 0; ++i)
  SwigPyBuiltin_AddPublicSymbol(public_interface, swig_const_table[i].name);
#endif
  
  SWIG_InstallConstants(d,swig_const_table);
  
  
  PyDateTime_IMPORT;
  
  
  /* type '::CaptureSettings' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__CaptureSettings_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'CaptureSettings'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "CaptureSettings", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "CaptureSettings");
  d = md;
  
  /* type '::IMainWindow' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IMainWindow_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'MainWindow'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "MainWindow", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "MainWindow");
  d = md;
  
  /* type '::IEventBrowser' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IEventBrowser_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EventBrowser'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EventBrowser", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EventBrowser");
  d = md;
  
  /* type '::IAPIInspector' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IAPIInspector_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'APIInspector'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "APIInspector", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "APIInspector");
  d = md;
  
  /* type '::PipelineStage' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__PipelineStage_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "VertexInput",SWIG_From_int(static_cast< int >(PipelineStage::VertexInput)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "VertexShader",SWIG_From_int(static_cast< int >(PipelineStage::VertexShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "HullShader",SWIG_From_int(static_cast< int >(PipelineStage::HullShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TessControlShader",SWIG_From_int(static_cast< int >(PipelineStage::TessControlShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DomainShader",SWIG_From_int(static_cast< int >(PipelineStage::DomainShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TessEvalShader",SWIG_From_int(static_cast< int >(PipelineStage::TessEvalShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "GeometryShader",SWIG_From_int(static_cast< int >(PipelineStage::GeometryShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Rasterizer",SWIG_From_int(static_cast< int >(PipelineStage::Rasterizer)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ViewportsScissors",SWIG_From_int(static_cast< int >(PipelineStage::ViewportsScissors)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PixelShader",SWIG_From_int(static_cast< int >(PipelineStage::PixelShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "FragmentShader",SWIG_From_int(static_cast< int >(PipelineStage::FragmentShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ColorDepthOutput",SWIG_From_int(static_cast< int >(PipelineStage::ColorDepthOutput)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Blending",SWIG_From_int(static_cast< int >(PipelineStage::Blending)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "DepthTest",SWIG_From_int(static_cast< int >(PipelineStage::DepthTest)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "StencilTest",SWIG_From_int(static_cast< int >(PipelineStage::StencilTest)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ComputeShader",SWIG_From_int(static_cast< int >(PipelineStage::ComputeShader)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SampleMask",SWIG_From_int(static_cast< int >(PipelineStage::SampleMask)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "PipelineStage", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "PipelineStage", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'PipelineStage'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "PipelineStage", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PipelineStage");
  d = md;
  
  /* type '::IPipelineStateViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IPipelineStateViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'PipelineStateViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "PipelineStateViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PipelineStateViewer");
  d = md;
  
  /* type '::FollowType' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__FollowType_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OutputColor",SWIG_From_int(static_cast< int >(FollowType::OutputColor)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OutputDepth",SWIG_From_int(static_cast< int >(FollowType::OutputDepth)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ReadWrite",SWIG_From_int(static_cast< int >(FollowType::ReadWrite)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "ReadOnly",SWIG_From_int(static_cast< int >(FollowType::ReadOnly)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OutputDepthResolve",SWIG_From_int(static_cast< int >(FollowType::OutputDepthResolve)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "FollowType", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "FollowType", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'FollowType'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "FollowType", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "FollowType");
  d = md;
  
  /* type '::ITextureViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ITextureViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TextureViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TextureViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TextureViewer");
  d = md;
  
  /* type '::IBufferViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IBufferViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BufferViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BufferViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BufferViewer");
  d = md;
  
  /* type '::IResourceInspector' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IResourceInspector_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ResourceInspector'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ResourceInspector", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ResourceInspector");
  d = md;
  
  /* type '::ICaptureDialog' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ICaptureDialog_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'CaptureDialog'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "CaptureDialog", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "CaptureDialog");
  d = md;
  
  /* type '::IDebugMessageView' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IDebugMessageView_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DebugMessageView'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DebugMessageView", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DebugMessageView");
  d = md;
  
  /* type '::IDiagnosticLogView' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IDiagnosticLogView_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DiagnosticLogView'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DiagnosticLogView", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DiagnosticLogView");
  d = md;
  
  /* type '::ICommentView' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ICommentView_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'CommentView'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "CommentView", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "CommentView");
  d = md;
  
  /* type '::IStatisticsViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IStatisticsViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'StatisticsViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "StatisticsViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "StatisticsViewer");
  d = md;
  
  /* type '::ITimelineBar' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ITimelineBar_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'TimelineBar'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "TimelineBar", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TimelineBar");
  d = md;
  
  /* type '::IPerformanceCounterViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IPerformanceCounterViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'PerformanceCounterViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "PerformanceCounterViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PerformanceCounterViewer");
  d = md;
  
  /* type '::IPythonShell' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IPythonShell_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'PythonShell'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "PythonShell", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PythonShell");
  d = md;
  
  /* type '::IShaderViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IShaderViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ShaderViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ShaderViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ShaderViewer");
  d = md;
  
  /* type '::IShaderMessageViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IShaderMessageViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ShaderMessageViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ShaderMessageViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ShaderMessageViewer");
  d = md;
  
  /* type '::IDescriptorViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IDescriptorViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'DescriptorViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "DescriptorViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DescriptorViewer");
  d = md;
  
  /* type '::IPixelHistoryView' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IPixelHistoryView_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'PixelHistoryView'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "PixelHistoryView", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PixelHistoryView");
  d = md;
  
  /* type '::ICaptureViewer' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ICaptureViewer_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'CaptureViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "CaptureViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "CaptureViewer");
  d = md;
  
  /* type '::IReplayManager' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IReplayManager_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ReplayManager'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ReplayManager", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ReplayManager");
  d = md;
  
  /* type '::DockReference' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__DockReference_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LastUsedArea",SWIG_From_int(static_cast< int >(DockReference::LastUsedArea)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NewFloatingArea",SWIG_From_int(static_cast< int >(DockReference::NewFloatingArea)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EmptySpace",SWIG_From_int(static_cast< int >(DockReference::EmptySpace)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NoArea",SWIG_From_int(static_cast< int >(DockReference::NoArea)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "AddTo",SWIG_From_int(static_cast< int >(DockReference::AddTo)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LeftOf",SWIG_From_int(static_cast< int >(DockReference::LeftOf)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RightOf",SWIG_From_int(static_cast< int >(DockReference::RightOf)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TopOf",SWIG_From_int(static_cast< int >(DockReference::TopOf)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BottomOf",SWIG_From_int(static_cast< int >(DockReference::BottomOf)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LeftWindowSide",SWIG_From_int(static_cast< int >(DockReference::LeftWindowSide)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RightWindowSide",SWIG_From_int(static_cast< int >(DockReference::RightWindowSide)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TopWindowSide",SWIG_From_int(static_cast< int >(DockReference::TopWindowSide)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BottomWindowSide",SWIG_From_int(static_cast< int >(DockReference::BottomWindowSide)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MainToolArea",SWIG_From_int(static_cast< int >(DockReference::MainToolArea)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "LeftToolArea",SWIG_From_int(static_cast< int >(DockReference::LeftToolArea)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TransientPopupArea",SWIG_From_int(static_cast< int >(DockReference::TransientPopupArea)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "DockReference", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "DockReference", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'DockReference'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "DockReference", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DockReference");
  d = md;
  
  /* type '::CaptureModifications' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__CaptureModifications_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NoModifications",SWIG_From_int(static_cast< int >(CaptureModifications::NoModifications)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Renames",SWIG_From_int(static_cast< int >(CaptureModifications::Renames)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Bookmarks",SWIG_From_int(static_cast< int >(CaptureModifications::Bookmarks)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Notes",SWIG_From_int(static_cast< int >(CaptureModifications::Notes)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EditedShaders",SWIG_From_int(static_cast< int >(CaptureModifications::EditedShaders)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "All",SWIG_From_int(static_cast< int >(CaptureModifications::All)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "CaptureModifications", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "CaptureModifications", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'CaptureModifications'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "CaptureModifications", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "CaptureModifications");
  d = md;
  
  /* type '::EventBookmark' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__EventBookmark_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'EventBookmark'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "EventBookmark", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "EventBookmark");
  d = md;
  
  /* type '::IRGPInterop' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IRGPInterop_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'RGPInterop'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "RGPInterop", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "RGPInterop");
  d = md;
  
  /* type '::ICaptureContext' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ICaptureContext_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'CaptureContext'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "CaptureContext", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "CaptureContext");
  d = md;
  
  /* type '::ShaderToolOutput' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ShaderToolOutput_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ShaderToolOutput'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ShaderToolOutput", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ShaderToolOutput");
  d = md;
  
  /* type '::ShaderProcessingTool' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ShaderProcessingTool_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ShaderProcessingTool'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ShaderProcessingTool", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ShaderProcessingTool");
  d = md;
  
  /* type '::BugReport' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__BugReport_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'BugReport'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "BugReport", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "BugReport");
  d = md;
  
  /* type '::OffsetSizeDisplayMode' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__OffsetSizeDisplayMode_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Auto",SWIG_From_int(static_cast< int >(OffsetSizeDisplayMode::Auto)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Decimal",SWIG_From_int(static_cast< int >(OffsetSizeDisplayMode::Decimal)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Hexadecimal",SWIG_From_int(static_cast< int >(OffsetSizeDisplayMode::Hexadecimal)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Count",SWIG_From_int(static_cast< int >(OffsetSizeDisplayMode::Count)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "OffsetSizeDisplayMode", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "OffsetSizeDisplayMode", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'OffsetSizeDisplayMode'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "OffsetSizeDisplayMode", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "OffsetSizeDisplayMode");
  d = md;
  
  /* type '::TimeUnit' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__TimeUnit_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Seconds",SWIG_From_int(static_cast< int >(TimeUnit::Seconds)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Milliseconds",SWIG_From_int(static_cast< int >(TimeUnit::Milliseconds)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Microseconds",SWIG_From_int(static_cast< int >(TimeUnit::Microseconds)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Nanoseconds",SWIG_From_int(static_cast< int >(TimeUnit::Nanoseconds)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Count",SWIG_From_int(static_cast< int >(TimeUnit::Count)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "TimeUnit", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "TimeUnit", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'TimeUnit'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "TimeUnit", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "TimeUnit");
  d = md;
  
  /* type '::PersistantConfig' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__PersistantConfig_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'PersistantConfig'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "PersistantConfig", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PersistantConfig");
  d = md;
  
  /* type '::RemoteHost' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__RemoteHost_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'RemoteHost'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "RemoteHost", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "RemoteHost");
  d = md;
  
  /* type '::WindowMenu' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__WindowMenu_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Unknown",SWIG_From_int(static_cast< int >(WindowMenu::Unknown)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "File",SWIG_From_int(static_cast< int >(WindowMenu::File)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Window",SWIG_From_int(static_cast< int >(WindowMenu::Window)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Tools",SWIG_From_int(static_cast< int >(WindowMenu::Tools)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NewMenu",SWIG_From_int(static_cast< int >(WindowMenu::NewMenu)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Help",SWIG_From_int(static_cast< int >(WindowMenu::Help)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "WindowMenu", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "WindowMenu", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'WindowMenu'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "WindowMenu", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "WindowMenu");
  d = md;
  
  /* type '::PanelMenu' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__PanelMenu_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Unknown",SWIG_From_int(static_cast< int >(PanelMenu::Unknown)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EventBrowser",SWIG_From_int(static_cast< int >(PanelMenu::EventBrowser)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "PipelineStateViewer",SWIG_From_int(static_cast< int >(PanelMenu::PipelineStateViewer)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview",SWIG_From_int(static_cast< int >(PanelMenu::MeshPreview)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TextureViewer",SWIG_From_int(static_cast< int >(PanelMenu::TextureViewer)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "BufferViewer",SWIG_From_int(static_cast< int >(PanelMenu::BufferViewer)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "PanelMenu", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "PanelMenu", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'PanelMenu'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "PanelMenu", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "PanelMenu");
  d = md;
  
  /* type '::ContextMenu' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ContextMenu_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Unknown",SWIG_From_int(static_cast< int >(ContextMenu::Unknown)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "EventBrowser_Event",SWIG_From_int(static_cast< int >(ContextMenu::EventBrowser_Event)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview_Vertex",SWIG_From_int(static_cast< int >(ContextMenu::MeshPreview_Vertex)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview_VSInVertex",SWIG_From_int(static_cast< int >(ContextMenu::MeshPreview_VSInVertex)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview_VSOutVertex",SWIG_From_int(static_cast< int >(ContextMenu::MeshPreview_VSOutVertex)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview_GSOutVertex",SWIG_From_int(static_cast< int >(ContextMenu::MeshPreview_GSOutVertex)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview_TaskOutVertex",SWIG_From_int(static_cast< int >(ContextMenu::MeshPreview_TaskOutVertex)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "MeshPreview_MeshOutVertex",SWIG_From_int(static_cast< int >(ContextMenu::MeshPreview_MeshOutVertex)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TextureViewer_Thumbnail",SWIG_From_int(static_cast< int >(ContextMenu::TextureViewer_Thumbnail)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TextureViewer_InputThumbnail",SWIG_From_int(static_cast< int >(ContextMenu::TextureViewer_InputThumbnail)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "TextureViewer_OutputThumbnail",SWIG_From_int(static_cast< int >(ContextMenu::TextureViewer_OutputThumbnail)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "ContextMenu", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "ContextMenu", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'ContextMenu'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "ContextMenu", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ContextMenu");
  d = md;
  
  /* type '::DialogButton' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__DialogButton_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "OK",SWIG_From_int(static_cast< int >(DialogButton::OK)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Save",SWIG_From_int(static_cast< int >(DialogButton::Save)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "SaveAll",SWIG_From_int(static_cast< int >(DialogButton::SaveAll)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Open",SWIG_From_int(static_cast< int >(DialogButton::Open)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Yes",SWIG_From_int(static_cast< int >(DialogButton::Yes)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "YesToAll",SWIG_From_int(static_cast< int >(DialogButton::YesToAll)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "No",SWIG_From_int(static_cast< int >(DialogButton::No)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "NoToAll",SWIG_From_int(static_cast< int >(DialogButton::NoToAll)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Abort",SWIG_From_int(static_cast< int >(DialogButton::Abort)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Retry",SWIG_From_int(static_cast< int >(DialogButton::Retry)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Ignore",SWIG_From_int(static_cast< int >(DialogButton::Ignore)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Close",SWIG_From_int(static_cast< int >(DialogButton::Close)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Cancel",SWIG_From_int(static_cast< int >(DialogButton::Cancel)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Discard",SWIG_From_int(static_cast< int >(DialogButton::Discard)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Help",SWIG_From_int(static_cast< int >(DialogButton::Help)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Apply",SWIG_From_int(static_cast< int >(DialogButton::Apply)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "Reset",SWIG_From_int(static_cast< int >(DialogButton::Reset)));
  SWIG_Python_SetConstant(d, d == md ? public_interface : NULL, "RestoreDefaults",SWIG_From_int(static_cast< int >(DialogButton::RestoreDefaults)));
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  if (Enum_class == NULL) SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  if (Enum_class == NULL) {
    PyDict_SetItemString(d, "this", this_descr);
    PyDict_SetItemString(d, "thisown", thisown_descr);
  }
  if (Enum_class) {
    PyObject *constructor = Enum_class;
    if(Flag_class) constructor = Flag_class;
    builtin_pytype->tp_base = (PyTypeObject *)PyObject_CallFunction(constructor, "sO", "DialogButton", d);
    PyObject_SetAttrString((PyObject *)builtin_pytype->tp_base, "__doc__", PyUnicode_FromString(builtin_pytype->tp_doc));
    PyModule_AddObject(m, "DialogButton", (PyObject *)builtin_pytype->tp_base);
    Py_DECREF(d);
    builtin_pytype->tp_dict = NULL;
  } else {
    if (PyType_Ready(builtin_pytype) < 0) {
      PyErr_SetString(PyExc_TypeError, "Could not create type 'DialogButton'.");
#if PY_VERSION_HEX >= 0x03000000
      return NULL;
#else
      return;
#endif
    }
    Py_INCREF(builtin_pytype);
    PyModule_AddObject(m, "DialogButton", (PyObject *)builtin_pytype);
  }
  SwigPyBuiltin_AddPublicSymbol(public_interface, "DialogButton");
  d = md;
  
  /* type '::ExtensionMetadata' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__ExtensionMetadata_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ExtensionMetadata'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ExtensionMetadata", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ExtensionMetadata");
  d = md;
  
  /* type '::IMiniQtHelper' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IMiniQtHelper_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'MiniQtHelper'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "MiniQtHelper", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "MiniQtHelper");
  d = md;
  
  /* type '::IExtensionManager' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__IExtensionManager_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'ExtensionManager'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "ExtensionManager", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "ExtensionManager");
  d = md;
  
  /* type '::rdcarray< EventBookmark >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_EventBookmark_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_EventBookmark'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_EventBookmark", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_EventBookmark");
  d = md;
  
  /* type '::rdcarray< ShaderProcessingTool >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_ShaderProcessingTool_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_ShaderProcessingTool'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_ShaderProcessingTool", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_ShaderProcessingTool");
  d = md;
  
  /* type '::rdcarray< rdcstrpair >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_rdcstrpair_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_rdcstrpair'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_rdcstrpair", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_rdcstrpair");
  d = md;
  
  /* type '::rdcarray< BugReport >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_BugReport_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_BugReport'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_BugReport", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_BugReport");
  d = md;
  
  /* type '::rdcarray< ExtensionMetadata >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_ExtensionMetadata_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_ExtensionMetadata'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_ExtensionMetadata", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_ExtensionMetadata");
  d = md;
  
  /* type '::rdcarray< DialogButton >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_DialogButton_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_DialogButton'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_DialogButton", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_DialogButton");
  d = md;
  
  /* type '::rdcarray< RemoteHost >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_RemoteHost_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_RemoteHost'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_RemoteHost", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_RemoteHost");
  d = md;
  
  /* type '::rdcarray< ICaptureViewer * >' */
  builtin_pytype = (PyTypeObject *)&SwigPyBuiltin__rdcarrayT_ICaptureViewer_p_t_type;
  builtin_pytype->tp_dict = d = PyDict_New();
  SwigPyBuiltin_SetMetaType(builtin_pytype, metatype);
  builtin_pytype->tp_new = PyType_GenericNew;
  builtin_base_count = 0;
  builtin_bases[builtin_base_count] = NULL;
  SwigPyBuiltin_InitBases(builtin_pytype, builtin_bases);
  PyDict_SetItemString(d, "this", this_descr);
  PyDict_SetItemString(d, "thisown", thisown_descr);
  if (PyType_Ready(builtin_pytype) < 0) {
    PyErr_SetString(PyExc_TypeError, "Could not create type 'rdcarray_of_ptr_ICaptureViewer'.");
#if PY_VERSION_HEX >= 0x03000000
    return NULL;
#else
    return;
#endif
  }
  Py_INCREF(builtin_pytype);
  PyModule_AddObject(m, "rdcarray_of_ptr_ICaptureViewer", (PyObject *)builtin_pytype);
  SwigPyBuiltin_AddPublicSymbol(public_interface, "rdcarray_of_ptr_ICaptureViewer");
  d = md;
  
  interfaceCheckTypes = swig_type_initial;
  interfaceCheckNumTypes = sizeof(swig_type_initial)/sizeof(swig_type_initial[0]);
  
#if PY_VERSION_HEX >= 0x03000000
  return m;
#else
  return;
#endif
}

